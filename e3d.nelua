require("filestream")
require("io")
require("string")
require("sequence")
require("hashmap")
require("stringbuilder")
require("memory")
require("allocators.default")
require("math")
require("coroutine")
require("raylib")
require("rlgl")

global e3d = @record{}

-----------------------------
--                         --
--        CONSTANTS        --
--                         --
-----------------------------

--[[ RAM logical memory map
	heap:    8 MiB
	tmem:    4 MiB  (1024*1024 pixels (32bpp))
	globals: 256KiB (65536 words)
	locals:  256KiB (65536 words)
	args:    256KiB (65536 words)
	rom:     64KiB  (65536 bytes)
	TOTAL: 12 MiB + 832KiB

	0x000000 - 0x7FFFFF: heap
	0x800000 - 0xBFFFFF: tmem
	0xC00000 - 0xC3FFFF: globals
	0xC40000 - 0xC7FFFF: locals
	0xC80000 - 0xCBFFFF: args
	0xCC0000 - 0xCCFFFF: rom
]]

global e3d.VSCREEN_W <comptime> = 320
global e3d.VSCREEN_H <comptime> = 240
global e3d.SCREEN_W <comptime> = (e3d.VSCREEN_W * 3)
global e3d.SCREEN_H <comptime> = (e3d.VSCREEN_H * 3)

global e3d.TMEM_WIDTH <comptime> = 1024
global e3d.TMEM_HEIGHT <comptime> = 1024

global e3d.HEAP_SIZE      <comptime> = (1024*1024*8) -- 8MiB
global e3d.TMEM_SIZE      <comptime> = (e3d.TMEM_WIDTH*e3d.TMEM_HEIGHT) -- ?MiB (2048*2048 pixels (32bpp))
global e3d.GLOBALS_SIZE   <comptime> = 65536 -- 256KiB (65536 words)
global e3d.LOCALS_SIZE    <comptime> = 65536 -- 256KiB (65536 words)
global e3d.ARGS_SIZE      <comptime> = 65536 -- 256KiB (65536 words)
global e3d.ROM_SIZE       <comptime> = 65536 -- 64KiB (65536 bytes)
global e3d.OPSTACK_SIZE   <comptime> = 65536 -- 256KiB (65536 words)
global e3d.BYTECODE_SIZE  <comptime> = 65536 -- 64KiB (65536 bytes)
global e3d.CALLSTACK_SIZE <comptime> = 256
global e3d.API_FUNCS_SIZE <comptime> = 65536
global e3d.CAMERAS_COUNT  <comptime> = 8

global e3d.TMEM_START_ADDR <comptime> = 0x800000
global e3d.GLOBALS_START_ADDR <comptime> = 0xC00000
global e3d.LOCALS_START_ADDR <comptime> = 0xC40000
global e3d.ARGS_START_ADDR <comptime> = 0xC80000
global e3d.ROM_START_ADDR <comptime> = 0xCC0000
global e3d.RAM_MAX_ADDR <comptime> = 0xCCFFFF

-- emulate a PS1-like controller
global e3d.ControllerButtons = @enum {
	UP = 0,
	DOWN,
	LEFT,
	RIGHT,
	TRIANGLE,
	CROSS,
	SQUARE,
	CIRCLE,
	L1,
	L2,
	R1,
	R2,
	SELECT,
	START,
	COUNT -- not an actual button; used to count the number of buttons
}

global e3d.Token = @enum {
	INT_LITERAL = 128, -- start at 128 to avoid conflicts with ASCII chars
	FLOAT_LITERAL,
	STRING,  -- string literal
	VOID,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT_ID, -- struct type id
	STRUCT,
	FUNCTION,
	ENUM,
	ID,
	ELSE,
	IF,
	RETURN,
	BREAK,
	CONTINUE,
	SIZEOF,
	FOR,
	WHILE,
	LNOT,
	NOT,
	ASSIGN,
	COND,
	LOR,
	LAND,
	OR,
	XOR,
	AND,
	EQ,
	NE,
	LT,
	GT,
	LE,
	GE,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	ADD,
	SUB,
	MUL,
	DIV,
	MOD,
	ARROW,
	DOT,
	BRAK
}

global e3d.Opcode = @enum {
	GET_G = 0,
	GET_GX,
	SET_G,
	SET_GX,
	NEW_L,
	DEL_L,
	GET_L,
	GET_LX,
	SET_L,
	SET_LX,
	GET_A,
	GET_AX,
	SET_A,
	SET_AX,
	GET_M,
	GET_MX,
	SET_M,
	SET_MX,
	ADDROF_G,
	ADDROF_L,
	ADDROF_A,
	PUSH_ZERO,
	PUSH_ONE,
	PUSH_CHAR,
	PUSH_INT,
	PUSH_FLOAT,
	PUSH_VEC2_ZERO,
	PUSH_VEC3_ZERO,
	DISCARD,
	NOT,
	OR,
	XOR,
	AND,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	NEG,
	NEGF,
	NEGV,
	ADD,
	ADDF,
	ADDV,
	ADDP,
	SUB,
	SUBF,
	SUBV,
	SUBP,
	MUL,
	MULF,
	MULV,
	DIV,
	DIVU,
	DIVF,
	DIVV,
	MOD,
	MODU,
	MODF,
	LNOT,
	EQ,
	EQF,
	EQV,
	NE,
	NEF,
	NEV,
	LTI,
	LTU,
	LTF,
	LTV,
	GTI,
	GTU,
	GTF,
	GTV,
	LEI,
	LEU,
	LEF,
	LEV,
	GEI,
	GEU,
	GEF,
	GEV,
	JUMP,
	JUMP_Z,
	JUMP_ZD,
	JUMP_NZ,
	JUMP_NZD,
	CALL,
	CALL_PTR,
	RETURN,
	FTOI,
	ITOF,
	API
}

global e3d.Class = @enum {
	KEYWORD = 0,
	API,
	CONSTANT,
	STRUCT,
	FUNCTION,
	MEMORY, -- only used when writing values into memory using pointers
	GLOBAL,
	ARG,
	LOCAL
}

global e3d.EVMType = @enum {
	VOID = 0,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT,
	STRING,
	FUNC_POINTER,
	POINTER = 16 -- repeatedly added to type to indicate pointer levels
}

global e3d.MulVMode = @enum {
	INT_V2 = 0,
	INT_V3,
	FLOAT_V2,
	FLOAT_V3,
	V2_INT,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

global e3d.DivVMode = @enum {
	V2_INT = 0,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

global e3d.Hook = @enum {
	INIT = 0,
	UPDATE,
	DRAW2D,
	DRAW3D
}

global e3d.StatusCode = @enum {
	OK = 0,
	ERR_MISALIGNED_PTR,
	ERR_OOB_PTR
}

-------------------------
--                     --
--        TYPES        --
--                     --
-------------------------

global e3d.EVM <forwarddecl> = @record {}

global e3d.Identifier <forwarddecl> = @record {}

global e3d.APIFunction: type = @function(vm: *e3d.EVM): boolean

global e3d.GPU = @record {
	cameras: [e3d.CAMERAS_COUNT]rl.camera,
	gfx_texture: rl.texture,
	gfx_shader: rl.shader,
	gfx_rendertex: rl.renderTexture,
	
	-- shader uniform locations
	tex_mode_loc: cint,
	tex_x_loc: cint,
	tex_y_loc: cint,
	tex_w_loc: cint,
	tex_h_loc: cint,
	fog_mode_loc: cint,
	fog_start_loc: cint,
	fog_end_loc: cint,
	fog_color_loc: cint,

	update_tex: boolean,
	triangle_mode: boolean,
	triangle_vert_index: integer,
	triangle_vert_color: rl.color,
	triangle_vert_uv: rl.vector2,
	triangle_vert_pos: rl.vector3,
	
	-- graphics state
	current_camera: uinteger,
	cullmode: uinteger,
	wiremode: boolean,
	tex_mode: cint,
	tex_x: cint,
	tex_y: cint,
	tex_w: cint,
	tex_h: cint,
	fog_mode: cint,
	fog_start: float32,
	fog_end: float32,
	fog_color: rl.vector4,
	bgcolor: rl.color
}

global e3d.EVMValue = @union {
	i: int32, -- int
	u: uint32, -- pointer, string, func_ptr
	f: float32
}

global e3d.CallFrame = @record {
	pc: uinteger,
	lbp: uinteger,
	argc: uint16
}

global e3d.Struct = @record {
	is_complete: boolean,
	size: uinteger,
	name: string,
	member_map: hashmap(string, uinteger),
	members: sequence(*e3d.Identifier)
}

global e3d.TypeInfo = @record {
	type_id: uinteger,
	structref: *e3d.Struct -- only used when base_type is e3d.EVMType.STRUCT
}

global e3d.LoopInfo = @record {
	loop_start: uinteger,
	loop_step: uinteger,
	loop_end: uinteger,
	break_count: uinteger,
	step_count: uinteger,
	del_l_count: uinteger,
	has_step: boolean
}

e3d.Identifier = @record {
	name: string,
	token: uinteger,
	class: uinteger,
	index: uinteger,
	type_info: e3d.TypeInfo,
	is_array: boolean,
	const_val: uint32, -- only used for constants (enum values)
	func: e3d.APIFunction, -- only used when registering api functions
	argdata: sequence(e3d.TypeInfo) -- only used to track function arguments
}

e3d.EVM = @record {
	-- vm vars
	heap: [e3d.HEAP_SIZE]uint8,
	tmem: [e3d.TMEM_SIZE]rl.color,
	globals: [e3d.GLOBALS_SIZE]e3d.EVMValue,
	locals: [e3d.GLOBALS_SIZE]e3d.EVMValue,
	args: [e3d.ARGS_SIZE]e3d.EVMValue,
	rom: [e3d.ROM_SIZE]uint8,
	opstack: [e3d.OPSTACK_SIZE]e3d.EVMValue,
	bytecode: [e3d.BYTECODE_SIZE]uint8,
	callstack: [e3d.CALLSTACK_SIZE]e3d.CallFrame,
	api_funcs: [e3d.API_FUNCS_SIZE]e3d.APIFunction,
	cf: e3d.CallFrame,
	rom_len: uinteger,
	bytecode_len: uinteger,
	globals_len: uinteger,
	lsp: uinteger,
	asp: uinteger,
	ap: uinteger,   -- ap for current function
	osp: uinteger,
	csp: uinteger,
	hook_addresses: [4]uint16,
	hook_flags: [4]boolean,
	current_hook: uinteger,
	
	-- compiler vars
	src: string,
	src_index: uinteger,
	prev_src_index: uinteger,
	token: uinteger,
	token_val: uinteger,
	token_valf: float32,
	prev_token: uinteger,
	prev_scope_size: uint16,
	line: uinteger,
	expr_type: e3d.TypeInfo,
	local_index: uinteger,
	mlcomment_level: uinteger,
	prev_opcode: uint8,
	has_id: boolean,
	skip_next_id_lookup: boolean,
	compile_err: boolean,
	current_id: *e3d.Identifier,
	current_id_name: string,
	current_func_id: *e3d.Identifier,
	struct_vec2: *e3d.Struct,
	struct_vec3: *e3d.Struct,
	sb: stringbuilder,
	keywords: hashmap(string, *e3d.Identifier),
	api_ids: hashmap(string, *e3d.Identifier),
	struct_ids: hashmap(string, *e3d.Identifier),
	sym_tables: sequence(*hashmap(string, *e3d.Identifier)),
	scope_sizes: sequence(uinteger),
	loop_info_stack: sequence(e3d.LoopInfo),
	loop_break_stack: sequence(uint16),
	loop_step_stack: sequence(uint16),
	loop_del_l_stack: sequence(uint16),
	
	-- general vars
	gpu: e3d.GPU,
	error: string,
	init_time: float64
}

global e3d.btnmap: [e3d.ControllerButtons.COUNT]cint

global e3d._type_names: []string = {
	"void",
	"int",
	"float",
	"vec2",
	"vec3",
	"struct",
	"string",
	"function",
	"unmapped type (8)",
	"unmapped type (9)",
	"unmapped type (10)",
	"unmapped type (11)",
	"unmapped type (12)",
	"unmapped type (13)",
	"unmapped type (14)",
	"unmapped type (15)"
}

global e3d._token_names: []string = {
	"int literal",
	"float literal",
	"string",
	"void",
	"int",
	"float",
	"vec2",
	"vec3",
	"struct identifier",
	"struct",
	"function",
	"num",
	"identifier",
	"else",
	"if",
	"return",
	"break",
	"continue",
	"sizeof",
	"for",
	"while",
	"!",
	"~",
	"=",
	"?",
	"||",
	"&&",
	"|",
	"^",
	"&",
	"==",
	"!=",
	"<",
	">",
	"<=",
	">=",
	"<<",
	">>",
	">>>",
	"+",
	"-",
	"*",
	"/",
	"%",
	"->",
	".",
	"["
}

---------------------------------------
--                                   --
--        NAMESPACE FUNCTIONS        --
--                                   --
---------------------------------------

function e3d.set_default_btnmap(): void
	e3d.btnmap[e3d.ControllerButtons.UP]       = rl.keyboardKey.UP
	e3d.btnmap[e3d.ControllerButtons.DOWN]     = rl.keyboardKey.DOWN
	e3d.btnmap[e3d.ControllerButtons.LEFT]     = rl.keyboardKey.LEFT
	e3d.btnmap[e3d.ControllerButtons.RIGHT]    = rl.keyboardKey.RIGHT
	e3d.btnmap[e3d.ControllerButtons.TRIANGLE] = rl.keyboardKey.W
	e3d.btnmap[e3d.ControllerButtons.CROSS]    = rl.keyboardKey.S
	e3d.btnmap[e3d.ControllerButtons.SQUARE]   = rl.keyboardKey.A
	e3d.btnmap[e3d.ControllerButtons.CIRCLE]   = rl.keyboardKey.D
	e3d.btnmap[e3d.ControllerButtons.L1]       = rl.keyboardKey.Q
	e3d.btnmap[e3d.ControllerButtons.L2]       = rl.keyboardKey.ONE
	e3d.btnmap[e3d.ControllerButtons.R1]       = rl.keyboardKey.E
	e3d.btnmap[e3d.ControllerButtons.R2]       = rl.keyboardKey.THREE
	e3d.btnmap[e3d.ControllerButtons.SELECT]   = rl.keyboardKey.RIGHT_SHIFT
	e3d.btnmap[e3d.ControllerButtons.START]    = rl.keyboardKey.ENTER
end

function e3d.get_btn_keycode(btn: integer): cint
	return e3d.btnmap[btn]
end

function e3d.set_btn_keycode(btn: integer, keycode: cint): void
	e3d.btnmap[btn] = keycode
end

function e3d.get_type_name(info: e3d.TypeInfo): string
	local sb: stringbuilder
	local full_type: uinteger = info.type_id
	local base_type: uinteger = info.type_id & (e3d.EVMType.POINTER - 1)

	if base_type < e3d.EVMType.VEC3 then
		sb:write(e3d._type_names[base_type])
	else
		sb:write(info.structref.name)
	end

	while full_type >= e3d.EVMType.POINTER do
		sb:writebyte('*'_u8)
		full_type = full_type - e3d.EVMType.POINTER
	end

	return sb:__tostring()
end

function e3d.get_token_string(token: uinteger): string
	if token == 0 then
		return "EOF"
	elseif token < e3d.Token.INT_LITERAL then
		return string.format("%c", token)
	else
		return e3d._token_names[token - e3d.Token.INT_LITERAL]
	end
end

function e3d.size_of_type(info: e3d.TypeInfo): uint16
	-- returns size in words
	if (info.type_id >= e3d.EVMType.VEC2) and (info.type_id <= e3d.EVMType.STRUCT) then
		return info.structref.size
	end
	
	return 1
end

function e3d.size_pointed_to(info: e3d.TypeInfo): uint16
	-- returns size in words
	local type_pointed_to: uinteger = info.type_id - e3d.EVMType.POINTER
	
	if (type_pointed_to >= e3d.EVMType.VEC2) and (type_pointed_to <= e3d.EVMType.STRUCT) then
		return info.structref.size
	end
	
	return 1
end

function e3d.GPU:texture(x: int32, y: int32, w: int32, h: int32): void
	self.tex_x = (@cint)(x)
	self.tex_y = (@cint)(y)
	self.tex_w = (@cint)(w)
	self.tex_h = (@cint)(h)
	
	rl.setShaderValue(self.gfx_shader, self.tex_x_loc, &self.tex_x, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_y_loc, &self.tex_y, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_w_loc, &self.tex_w, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_h_loc, &self.tex_h, rl.shaderUniformDataType.UNIFORM_INT)
end

function e3d.GPU:enable_render_state(): void
	switch self.cullmode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
	end

	if self.wiremode then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end
end

function e3d.GPU:disable_render_state(): void
	rlgl.enableBackfaceCulling()
	rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
	rlgl.disableWireMode()
end

function e3d.GPU:reset(): void
	for i = 0, < #self.cameras do
		self.cameras[i] = {
			position={0,0,0},
			target={0,0,0},
			up={0,1,0},
			fovy=45,
			projection=rl.cameraProjection.PERSPECTIVE
		}
	end

	self.current_camera = 0
	self.cullmode = 0
	self.wiremode = false
	self.bgcolor = {0x00, 0x00, 0x00, 0xFF}
	self.triangle_vert_color = {0xFF, 0xFF, 0xFF, 0xFF}
	
	self.tex_mode = 0
	rl.setShaderValue(self.gfx_shader, self.tex_mode_loc, &self.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)
	
	self.fog_mode = 0
	self.fog_start = 700.0
	self.fog_end = 1000.0
	self.fog_color = {1.0, 1.0, 1.0, 1.0}
	rl.setShaderValue(self.gfx_shader, self.fog_mode_loc, &self.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.fog_start_loc, &self.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_end_loc, &self.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_color_loc, &self.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)

	self:texture(0, 0, 64, 64)
end

function e3d.GPU:init(tmem: *rl.color): void
	rl.setConfigFlags(rl.configFlags.VSYNC_HINT | rl.configFlags.WINDOW_HIGHDPI) -- enable vsync and HighDPI
	rl.setTraceLogLevel(rl.traceLogLevel.ERROR) -- only log errors

	rl.initWindow(e3d.SCREEN_W, e3d.SCREEN_H, "ERA-3D")
	rl.setTargetFPS(30)

	rl.setExitKey(rl.keyboardKey.NULL)

	self.gfx_rendertex = rl.loadRenderTexture(e3d.VSCREEN_W, e3d.VSCREEN_H)

	local img: rl.image = rl.loadImage("test.png")
	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	memory.copy(tmem, img.data, e3d.TMEM_SIZE * #rl.color)
	self.gfx_texture = rl.loadTextureFromImage(img)
	rl.unloadImage(img)
	
	self.gfx_shader = rl.loadShader(nilptr, "shader.fs")
	
	self.tex_mode_loc = rl.getShaderLocation(self.gfx_shader, "texMode")
	self.tex_x_loc = rl.getShaderLocation(self.gfx_shader, "texX")
	self.tex_y_loc = rl.getShaderLocation(self.gfx_shader, "texY")
	self.tex_w_loc = rl.getShaderLocation(self.gfx_shader, "texW")
	self.tex_h_loc = rl.getShaderLocation(self.gfx_shader, "texH")
	self.fog_mode_loc = rl.getShaderLocation(self.gfx_shader, "fogMode")
	self.fog_start_loc = rl.getShaderLocation(self.gfx_shader, "fogStart")
	self.fog_end_loc = rl.getShaderLocation(self.gfx_shader, "fogEnd")
	self.fog_color_loc = rl.getShaderLocation(self.gfx_shader, "fogColor")

	self:reset()
end

function e3d.GPU:cleanup(): void
	rl.unloadShader(self.gfx_shader)
	rl.unloadTexture(self.gfx_texture)
	rl.unloadRenderTexture(self.gfx_rendertex)

	rl.closeWindow()
end
