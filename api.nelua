require("e3d")

function e3d.EVM:get_argi(i: uint16): int32 <forwarddecl> end
function e3d.EVM:get_argu(i: uint16): uint32 <forwarddecl> end
function e3d.EVM:get_argf(i: uint16): float32 <forwarddecl> end
function e3d.EVM:get_argv2(i: uint16): rl.vector2 <forwarddecl> end
function e3d.EVM:get_argv3(i: uint16): rl.vector3 <forwarddecl> end
function e3d.EVM:pushi(val: int32): void <forwarddecl> end
function e3d.EVM:pushu(val: uint32): void <forwarddecl> end
function e3d.EVM:pushf(val: float32): void <forwarddecl> end
function e3d.EVM:pushv2(val: rl.vector2): void <forwarddecl> end
function e3d.EVM:pushv3(val: rl.vector3): void <forwarddecl> end

--[[
	API FUNCTIONS TO IMPLEMENT:
	
	// math
	bool feq(float a, float b);
	// ... ?
	
	// basic graphics
	void print2d(int x, int y, nchar* fmt, ...);
	void print3d(vec3 pos, nchar* fmt, ...);
	
	// advanced graphics
	// ortho(), etc.?
	void normal(vec3 norm);
	void matrixmode(int mode);
	
	// lighting
	void lightmode(int mode);
	void light(???);
	void ambient(???);
	
	// fog
	void fogmode(int mode);
	void fogstart(float start);
	void fogend(float end);
	void fogcolor(int color);
	
	// memory
	char* alloc(int size);
	char* realloc(char* ptr, int size);
	void free(char* ptr);
	void memset(char* ptr, int nbytes, char value);
	void memcpy(char* a, char* b, int nbytes);
	int strlen(char* str);
	char* strdup(char* str);
	char* strcat(char* a, char* b);
	char* strfmt(char* fmt, ...);
	
	// i/o
	// ...
]]

-- DEBUG API FUNCTIONS (TODO: remove)

local function api_halt(vm: *e3d.EVM): boolean
	vm.error = "- PROGRAM HALTED -\n"
	return false
end

local function api_print_int(vm: *e3d.EVM): boolean
	local v: int32 = vm:get_argi(0)
	local hex: int32 = vm:get_argi(1)
	if hex ~= 0 then
		io.printf("0x%08X\n", v)
	else
		io.printf("%d\n", v)
	end
	return true
end

local function api_print_float(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)
	io.printf("%f\n", v)
	return true
end

local function api_print_vec2(vm: *e3d.EVM): boolean
	local v: rl.vector2 = vm:get_argv2(0)
	io.printf("(%f, %f)\n", v.x, v.y)
	return true
end

local function api_print_vec3(vm: *e3d.EVM): boolean
	local v: rl.vector3 = vm:get_argv3(0)
	io.printf("(%f, %f, %f)\n", v.x, v.y, v.z)
	return true
end

-- API FUNCTIONS:

local function api_btn(vm: *e3d.EVM): boolean
	local b: int32 = math.clamp(vm:get_argi(0), e3d.ControllerButtons.UP, e3d.ControllerButtons.START)

	vm:pushi(rl.isKeyDown(e3d.btnmap[b]) and 1 or 0)
	
	return true
end

local function api_btnu(vm: *e3d.EVM): boolean
	local b: int32 = math.clamp(vm:get_argi(0), e3d.ControllerButtons.UP, e3d.ControllerButtons.START)

	vm:pushi(rl.isKeyReleased(e3d.btnmap[b]) and 1 or 0)
	
	return true
end

local function api_btnd(vm: *e3d.EVM): boolean
	local b: int32 = math.clamp(vm:get_argi(0), e3d.ControllerButtons.UP, e3d.ControllerButtons.START)

	vm:pushi(rl.isKeyPressed(e3d.btnmap[b]) and 1 or 0)
	
	return true
end

local function api_imin(vm: *e3d.EVM): boolean
	-- signature:
	-- int imin(int a, int b);
	
	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	
	if a < b then
		vm:pushi(a)
	else
		vm:pushi(b)
	end
	
	return true
end

local function api_imax(vm: *e3d.EVM): boolean
	-- signature:
	-- int imax(int a, int b);
	
	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	
	if a < b then
		vm:pushi(a)
	else
		vm:pushi(b)
	end
	
	return true
end

local function api_imid(vm: *e3d.EVM): boolean
	-- signature:
	-- int imid(int a, int b, int c);

	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	local c: int32 = vm:get_argi(2)

	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	if c < b then
		local t: int32 = c
		c = b
		b = t
	end
	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	
	vm:pushi(b)

	return true
end

local function api_iwrap(vm: *e3d.EVM): boolean
	-- signature:
	-- int iwrap(int v, int min, int max);

	local v: int32 = vm:get_argi(0)
	local min: int32 = vm:get_argi(1)
	local max: int32 = vm:get_argi(2)
	
	local range_size: int32 = max - min + 1;

	if v < min then
		v = v + range_size * ((min - v) /// range_size + 1)
	end

	vm:pushi(min + (v - min) % range_size)
	
	return true
end

local function api_fmin(vm: *e3d.EVM): boolean
	-- signature:
	-- int fmin(float a, float b);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)

	if a < b then
		vm:pushf(a)
	else
		vm:pushf(b)
	end

	return true
end

local function api_fmax(vm: *e3d.EVM): boolean
	-- signature:
	-- int fmax(float a, float b);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)

	if a > b then
		vm:pushf(a)
	else
		vm:pushf(b)
	end

	return true
end

local function api_fmid(vm: *e3d.EVM): boolean
	-- signature:
	-- int fmid(float a, float b, float c);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)
	local c: float32 = vm:get_argf(2)

	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	if c < b then
	    local t: float32 = c
	    c = b
	    b = t
	end
	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	
	vm:pushf(b)

	return true
end

local function api_fwrap(vm: *e3d.EVM): boolean
	-- signature:
	-- float fwrap(float x, float min, float max);

	local x: float32 = vm:get_argf(0)
	local min: float32 = vm:get_argf(1)
	local max: float32 = vm:get_argf(2)
	
	if min == max then
        vm:pushf(min)
		return true
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    vm:pushf(min + ((temp + ((x - min) %%% temp)) %%% temp))
	
	return true
end

local function api_isign(vm: *e3d.EVM): boolean
	local x: int32 = vm:get_argi(0)

	vm:pushi(math.sign(x))

	return true
end

local function api_fsign(vm: *e3d.EVM): boolean
	local x: float32 = vm:get_argf(0)

	vm:pushf(math.sign(x))

	return true
end

local function api_fract(vm: *e3d.EVM): boolean
	local x: float32 = vm:get_argf(0)

	vm:pushf(math.fract(x))

	return true
end

local function api_deg(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.deg(v))

	return true
end

local function api_rad(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.rad(v))

	return true
end

local function api_sin(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.sin(v))

	return true
end

local function api_cos(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.cos(v))

	return true
end

local function api_floor(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.floor(v))

	return true
end

local function api_ceil(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.ceil(v))

	return true
end

local function api_round(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.round(v))

	return true
end

local function api_randomize(vm: *e3d.EVM): boolean
	math.randomseed()

	return true
end

local function api_randomizex(vm: *e3d.EVM): boolean
	local seed: uint32 = vm:get_argu(0)

	math.randomseed(seed)

	return true
end

local function api_irand(vm: *e3d.EVM): boolean
	local min: int32 = vm:get_argi(0)
	local max: int32 = vm:get_argi(1)

	if max < min then
		min, max = max, min
	end

	vm:pushi(math.random(min, max))

	return true
end

local function api_irandx(vm: *e3d.EVM): boolean
	vm:pushi(math.random(0)) -- get int will all random bits

	return true
end

local function api_frand(vm: *e3d.EVM): boolean
	local min: float32 = vm:get_argf(0)
	local max: float32 = vm:get_argf(1)

	if max < min then
		min, max = max, min
	end

	local x: float32 = math.random() -- gets a float in [0, 1)

	vm:pushf(min + x * (max - min))

	return true
end

local function api_frandx(vm: *e3d.EVM): boolean
	vm:pushf(math.random())

	return true
end

local function api_time(vm: *e3d.EVM): boolean
	vm:pushf((@float32)(rl.getTime() - vm.init_time))
	
	return true
end

local function api_vec2len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2len(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	vm:pushf(math.sqrt(v.x * v.x + v.y * v.y))

	return true
end

local function api_vec2lensq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2lensq(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	vm:pushf(v.x * v.x + v.y * v.y)

	return true
end

local function api_vec2norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2norm(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	local l: float32 = v.x * v.x + v.y * v.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
	end

	vm:pushv2(v)

	return true
end

local function api_vec2dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2dot(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(a.x * b.x + a.y * b.y)

	return true
end

local function api_vec2cross(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2cross(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(a.x * b.y - a.y * b.x)

	return true
end

local function api_vec2dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2dist(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)))
	
	return true
end

local function api_vec2distsq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2distsq(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	
	vm:pushf((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
	
	return true
end

local function api_vec2direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2direction(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local direction: rl.vector2 = b - a;

	local l: float32 = direction.x * direction.x + direction.y * direction.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
	end

	vm:pushv2(direction)

	return true
end

local function api_vec2angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2angle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(math.atan2(b.y - a.y, b.x - a.x))

	return true
end

local function api_vec2lineangle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2lineangle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(rl.vector2LineAngle(a, b))

	return true
end

local function api_vec2lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2lerp(vec2 a, vec2 b, float amount);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local amount: float32 = vm:get_argf(4)

	a:lerp(b, amount)

	vm:pushv2(a)

	return true
end

local function api_vec2reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2reflect(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	a:reflect(b)
	
	vm:pushv2(a)
	
	return true
end

local function api_vec2rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2rotate(vec2 v, float angle);

	local v: rl.vector2 = vm:get_argv2(0)
	local angle: float32 = vm:get_argf(2)

	v:rotate(angle)
	
	vm:pushv2(v)

	return true
end

local function api_vec2movetoward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2movetoward(vec2 a, vec2 b, float delta);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local delta: float32 = vm:get_argf(4)

	local dest: rl.vector2 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushv2(b)
	else
		local temp: rl.vector2 = {
			dest.x / length * delta,
			dest.y / length * delta
		}
		vm:pushv2(a + temp)
	end

	return true
end

local function api_vec2invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2invert(vec2 v);
	
	local v: rl.vector2 = vm:get_argv2(0)

	v:invert()

	vm:pushv2(v)

	return true
end

local function api_vec3len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3len(vec3 v);
	
	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(math.sqrt(x + y + z))
	
	return true
end

local function api_vec3lensq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3lensq(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(x + y + z)
	
	return true
end

local function api_vec3norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3norm(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	vm:pushv3(v)
	
	return true
end

local function api_vec3dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3dot(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	vm:pushf(a.x * b.x + a.y * b.y + a.z * b.z)
	
	return true
end

local function api_vec3cross(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3cross(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	local v: rl.vector3 = {
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	}

	vm:pushv3(v)
	
	return true
end

local function api_vec3dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3dist(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(math.sqrt(x + y + z))
	
	return true
end

local function api_vec3distsq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3distsq(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(x + y + z)
	
	return true
end

local function api_vec3direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec3direction(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local direction: rl.vector3 = b - a;

	local x: float32 = direction.x * direction.x
	local y: float32 = direction.y * direction.y
	local z: float32 = direction.z * direction.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
		direction.z = direction.z / l
	end

	vm:pushv3(direction)

	return true
end

local function api_vec3angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3angle(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	vm:pushf(a:angle(b))

	return true
end
local function api_vec3lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3lerp(vec3 a, vec3 b, float amount);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local amount: float32 = vm:get_argf(6)

	a:lerp(b, amount)
	
	vm:pushv3(a)

	return true
end
local function api_vec3reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3reflect(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	a:reflect(b)
	
	vm:pushv3(a)

	return true
end
local function api_vec3rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3rotate(vec3 v, vec3 axis, float angle);

	local v: rl.vector3 = vm:get_argv3(0)
	local axis: rl.vector3 = vm:get_argv3(3)
	local angle: float32 = vm:get_argf(6)

	v:rotateByAxisAngle(axis, angle)
	
	vm:pushv3(v)

	return true
end
local function api_vec3movetoward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3movetoward(vec3 a, vec3 b, float delta);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local delta: float32 = vm:get_argf(6)

	local dest: rl.vector3 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushv3(b)
	else
		local temp: rl.vector3 = {
			dest.x / length * delta,
			dest.y / length * delta,
			dest.z / length * delta
		}
		vm:pushv3(a + temp)
	end

	return true
end
local function api_vec3invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3invert(vec3 a);

	local v: rl.vector3 = vm:get_argv3(0)

	v:invert()
	
	vm:pushv3(v)

	return true
end

local function api_camera(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera(int id);

	local id: int32 = vm:get_argi(0)

	vm.gpu.current_camera = math.clamp(id, 0, e3d.CAMERAS_COUNT - 1)

	return true
end

local function api_campos(vm: *e3d.EVM): boolean
	-- signature:
	-- void campos(vec3 pos);

	local pos: rl.vector3 = vm:get_argv3(0)

	vm.gpu.cameras[vm.gpu.current_camera].position = pos

	return true
end

local function api_camtarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void camtarget(vec3 target);

	local target: rl.vector3 = vm:get_argv3(0)

	vm.gpu.cameras[vm.gpu.current_camera].target = target

	return true
end

local function api_camup(vm: *e3d.EVM): boolean
	-- signature:
	-- void camup(vec3 up);

	local up: rl.vector3 = vm:get_argv3(0)

	vm.gpu.cameras[vm.gpu.current_camera].up = up

	return true
end

local function api_camfov(vm: *e3d.EVM): boolean
	-- signature:
	-- void camfov(float fov);

	local fov: float32 = vm:get_argf(0)

	vm.gpu.cameras[vm.gpu.current_camera].fovy = fov

	return true
end

local function api_camproj(vm: *e3d.EVM): boolean
	-- signature:
	-- void camproj(int mode);

	local proj: float32 = vm:get_argi(0)

	vm.gpu.cameras[vm.gpu.current_camera].projection = (@cint)(math.clamp(proj, 0, 1))

	return true
end

local function _v3norm(v: rl.vector3): rl.vector3
	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	return v
end

local function api_camright(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 camright();

	-- get camera
	local cam: rl.camera = vm.gpu.cameras[vm.gpu.current_camera]

	-- calculate forward vector
	local forward: rl.vector3 = _v3norm({
			cam.target.x - cam.position.x,
			cam.target.y - cam.position.y,
			cam.target.z - cam.position.z
		}
	)

	-- get normalized up vector
    local up: rl.vector3 = _v3norm(cam.up)

	-- calculate cross of forward and up
	vm:pushv3({
			(forward.y * up.z) - (forward.z * up.y),
			(forward.z * up.x) - (forward.x * up.z),
			(forward.x * up.y) - (forward.y * up.x)
		}
	)

	return true
end

local function api_camforward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 camforward();

	local cam: rl.camera = vm.gpu.cameras[vm.gpu.current_camera]

	vm:pushv3(
		_v3norm({
				cam.target.x - cam.position.x,
				cam.target.y - cam.position.y,
				cam.target.z - cam.position.z
			}
		)
	)

	return true
end

local function api_bgcolor(vm: *e3d.EVM): boolean
	-- signature:
	-- void bgcolor(int col);

	local col: uint32 = vm:get_argu(0)
	
	vm.gpu.bgcolor = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		0xFF
	}

	return true
end

local function api_texturemode(vm: *e3d.EVM): boolean
	-- signature:
	-- void texturemode(int mode);

	local mode: uint32 = vm:get_argu(0)

	if mode > 1 then
		mode = 1
	end

	vm.gpu.tex_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.tex_mode_loc, &vm.gpu.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function api_cullmode(vm: *e3d.EVM): boolean
	-- signature:
	-- void cullmode(int mode);

	local mode: uint32 = vm:get_argu(0)

	switch mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
			mode = 2
	end

	vm.gpu.cullmode = mode

	return true
end

local function api_wiremode(vm: *e3d.EVM): boolean
	-- signature:
	-- void wiremode(int mode);

	local enable: boolean = vm:get_argu(0) ~= 0

	if enable then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	vm.gpu.wiremode = enable

	return true
end

local function api_texture(vm: *e3d.EVM): boolean
	-- signature:
	-- void texture(int x, int y, int w, int h);

	local x: int32 = vm:get_argi(0)
	local y: int32 = vm:get_argi(1)
	local w: int32 = vm:get_argi(2)
	local h: int32 = vm:get_argi(3)

	w = math.clamp(w, 1, 256)
	h = math.clamp(h, 1, 256)
	x = math.clamp(x, 0, 1024 - w)
	y = math.clamp(y, 0, 1024 - h)

	vm.gpu:texture(x, y, w, h)

	return true
end

local function api_sprite2d(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2d(int srcx, int srcy, int srcw, int srch, int destx, int desy);

	local srcx: int32 = vm:get_argi(0)
	local srcy: int32 = vm:get_argi(1)
	local srcw: int32 = vm:get_argi(2)
	local srch: int32 = vm:get_argi(3)
	local destx: int32 = vm:get_argi(4)
	local desty: int32 = vm:get_argi(5)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(srcw), (@float32)(srch) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function api_ssprite2d(vm: *e3d.EVM): boolean
	-- signature:
	-- void ssprite2d(int srcx, int srcy, int srcw, int srch, int destx, int desy, int destw, int desth);

	local srcx: int32 = vm:get_argi(0)
	local srcy: int32 = vm:get_argi(1)
	local srcw: int32 = vm:get_argi(2)
	local srch: int32 = vm:get_argi(3)
	local destx: int32 = vm:get_argi(4)
	local desty: int32 = vm:get_argi(5)
	local destw: int32 = vm:get_argi(6)
	local desth: int32 = vm:get_argi(7)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function api_meshbegin(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshbegin(int mode);

	local mode: uint32 = vm:get_argu(0)

	switch mode do
		case 0 then
			vm.gpu.triangle_mode = false
			mode = rlgl.LINES
		case 1 then
			vm.gpu.triangle_mode = true
			vm.gpu.triangle_vert_index = 0
			mode = rlgl.QUADS
		else
			vm.gpu.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(vm.gpu.gfx_shader)

	rlgl.setTexture(vm.gpu.gfx_texture.id)
	
	rlgl.begin(mode)
	
	return true
end

local function api_meshend(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshend();

	rlgl.ending()

	rl.endShaderMode()
	
	return true
end

local function api_vertex(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	rlgl.vertex3f(v.x, v.y, v.z)
	
	if vm.gpu.triangle_mode then
		if vm.gpu.triangle_vert_index == 0 then
			vm.gpu.triangle_vert_pos = v
		elseif vm.gpu.triangle_vert_index == 2 then
			-- send copy of first vertex to allow textured tris
			rlgl.color4ub(
				vm.gpu.triangle_vert_color.r,
				vm.gpu.triangle_vert_color.g,
				vm.gpu.triangle_vert_color.b,
				vm.gpu.triangle_vert_color.a
			)
			rlgl.texCoord2f(
				vm.gpu.triangle_vert_uv.x,
				vm.gpu.triangle_vert_uv.y
			)
			rlgl.vertex3f(
				vm.gpu.triangle_vert_pos.x,
				vm.gpu.triangle_vert_pos.y,
				vm.gpu.triangle_vert_pos.z
			)
			
			vm.gpu.triangle_vert_index = 0
			return true
		end

		vm.gpu.triangle_vert_index = vm.gpu.triangle_vert_index + 1
	end
	
	return true
end

local function api_vertex2d(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex2d(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	rlgl.vertex2f(v.x, v.y)
	
	if vm.gpu.triangle_mode then
		if vm.gpu.triangle_vert_index == 0 then
			vm.gpu.triangle_vert_pos.x = v.x
			vm.gpu.triangle_vert_pos.y = v.y
		elseif vm.gpu.triangle_vert_index == 2 then
			-- send copy of first vertex to allow textured tris
			rlgl.color4ub(
				vm.gpu.triangle_vert_color.r,
				vm.gpu.triangle_vert_color.g,
				vm.gpu.triangle_vert_color.b,
				vm.gpu.triangle_vert_color.a
			)
			rlgl.texCoord2f(
				vm.gpu.triangle_vert_uv.x,
				vm.gpu.triangle_vert_uv.y
			)
			rlgl.vertex2f(
				vm.gpu.triangle_vert_pos.x,
				vm.gpu.triangle_vert_pos.y
			)
			
			vm.gpu.triangle_vert_index = 0
			return true
		end

		vm.gpu.triangle_vert_index = vm.gpu.triangle_vert_index + 1
	end
	
	return true
end

local function api_texcoord(vm: *e3d.EVM): boolean
	-- signature:
	-- void texcoord(vec2 uv);

	local v: rl.vector2 = vm:get_argv2(0)
	
	rlgl.texCoord2f(v.x, v.y)

	if vm.gpu.triangle_mode and (vm.gpu.triangle_vert_index == 0) then
		vm.gpu.triangle_vert_uv = v
	end
	
	return true
end

local function api_color(vm: *e3d.EVM): boolean
	-- signature:
	-- void color(int col);

	local col: uint32 = vm:get_argu(0)
	local r: cuchar = (@cuchar)(col >> 24)
	local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
	local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
	local a: cuchar = (@cuchar)(col & 0xFF)
	
	rlgl.color4ub(r, g, b, a)

	if vm.gpu.triangle_mode and (vm.gpu.triangle_vert_index == 0) then
		vm.gpu.triangle_vert_color = {r, g, b, a}
	end
	
	return true
end

-- void normal(vec3 norm);
-- void matrixmode(int mode);

local function api_pushmatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void pushmatrix();

	rlgl.pushMatrix()
	
	return true
end

local function api_popmatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void popmatrix();

	rlgl.popMatrix()
	
	return true
end

local function api_identity(vm: *e3d.EVM): boolean
	-- signature:
	-- void identity();

	rlgl.loadIdentity()
	
	return true
end

local function api_translate(vm: *e3d.EVM): boolean
	-- signature:
	-- void translate(vec3 pos);

	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.translatef(v.x, v.y, v.z)
	
	return true
end

local function api_rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- void rotate(vec3 rot);

	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.rotatef(v.x, 1, 0, 0)
	rlgl.rotatef(v.y, 0, 1, 0)
	rlgl.rotatef(v.z, 0, 0, 1)
	
	return true
end

local function api_scale(vm: *e3d.EVM): boolean
	-- signature:
	-- void scale(vec3 sca);

	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.scalef(v.x, v.y, v.z)
	
	return true
end

function e3d.EVM:_register_builtins(): void
	local keyword_ids: []e3d.Identifier = {
		{name="void",   token=e3d.Token.VOID},
		{name="int",    token=e3d.Token.INT},
		{name="float",  token=e3d.Token.FLOAT},
		{name="vec2",   token=e3d.Token.VEC2},
		{name="vec3",   token=e3d.Token.VEC3},
		{name="enum",   token=e3d.Token.ENUM},
		{name="struct", token=e3d.Token.STRUCT},
		{name="if",     token=e3d.Token.IF},
		{name="else",   token=e3d.Token.ELSE},
		{name="return", token=e3d.Token.RETURN},
		{name="sizeof", token=e3d.Token.SIZEOF},
		{name="for",    token=e3d.Token.FOR},
		{name="while",  token=e3d.Token.WHILE}
	}

	local constructor_ids: []e3d.Identifier = {
		{name="vec2zero", type_info={e3d.EVMType.VEC2}},
		{name="vec3zero", type_info={e3d.EVMType.VEC3}}
	}

	self.keywords:reserve(#keyword_ids)
	for i = 0, < #keyword_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = keyword_ids[i]
		id.class = e3d.Class.KEYWORD
		self.keywords[id.name] = id
	end

	-- vector construction functions are special cases,
	-- they are translated directly to opcodes
	for i = 0, < #constructor_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constructor_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		self.api_ids[id.name] = id
	end

	-- define vec2 struct
	local sid: *e3d.Struct = new(@e3d.Struct)
	local v2x: *e3d.Identifier = new(@e3d.Identifier)
	local v2y: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec2"
	v2x.name = "x"
	v2x.index = 0
	v2x.type_info = {e3d.EVMType.FLOAT}

	v2y.name = "y"
	v2y.index = 1
	v2y.type_info = {e3d.EVMType.FLOAT}

	sid:_add_member(v2x)
	sid:_add_member(v2y)
	sid.is_complete = true
	self.struct_vec2 = sid

	-- define vec3 struct
	sid = new(@e3d.Struct)
	local v3x: *e3d.Identifier = new(@e3d.Identifier)
	local v3y: *e3d.Identifier = new(@e3d.Identifier)
	local v3z: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec3"
	v3x.name = "x"
	v3x.index = 0
	v3x.type_info = {e3d.EVMType.FLOAT}

	v3y.name = "y"
	v3y.index = 1
	v3y.type_info = {e3d.EVMType.FLOAT}

	v3z.name = "z"
	v3z.index = 2
	v3z.type_info = {e3d.EVMType.FLOAT}

	sid:_add_member(v3x)
	sid:_add_member(v3y)
	sid:_add_member(v3z)
	sid.is_complete = true
	self.struct_vec3 = sid
end

function e3d.EVM:_register_api(): void
	local api_ids: []e3d.Identifier = {
		{name="halt", type_info={e3d.EVMType.VOID}, func=api_halt},
		
		{name="print_int",   type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_print_int},
		{name="print_float", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}},                          func=api_print_float},
		{name="print_vec2",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},                           func=api_print_vec2},
		{name="print_vec3",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},                           func=api_print_vec3},
		
		{name="btn",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}}, func=api_btn},
		{name="btnu", type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}}, func=api_btnu},
		{name="btnd", type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}}, func=api_btnd},
		
		{name="imin",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=api_imin},
		{name="imax",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=api_imax},
		{name="imid",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_imid},
		{name="iwrap", type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_iwrap},

		{name="fmin",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=api_fmin},
		{name="fmax",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=api_fmax},
		{name="fmid",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_fmid},
		{name="fwrap", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_fwrap},
		
		{name="isign", type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}},   func=api_isign},
		{name="fsign", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_fsign},
		{name="fract", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_fract},

		{name="deg",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_deg},
		{name="rad",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_rad},
		{name="sin",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_sin},
		{name="cos",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_cos},
		{name="floor",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_floor},
		{name="ceil",   type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_ceil},
		{name="round",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_round},

		{name="randomize",  type_info={e3d.EVMType.VOID},                                                                      func=api_randomize},
		{name="randomizex", type_info={e3d.EVMType.VOID},  argdata={{type_id=e3d.EVMType.INT}},                                func=api_randomizex},
		{name="irand",      type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},     func=api_irand},
		{name="irandx",     type_info={e3d.EVMType.INT},                                                                       func=api_irandx},
		{name="frand",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_frand},
		{name="frandx",     type_info={e3d.EVMType.FLOAT},                                                                     func=api_frandx},
		
		{name="time", type_info={e3d.EVMType.FLOAT}, func=api_time},
		
		{name="vec2len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2len},
		{name="vec2lensq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2lensq},
		{name="vec2norm",      type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2norm},
		{name="vec2dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2dot},
		{name="vec2cross",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2cross},
		{name="vec2dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2dist},
		{name="vec2distsq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2distsq},
		{name="vec2direction", type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2direction},
		{name="vec2angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2angle},
		{name="vec2lineangle", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2lineangle},
		{
			name="vec2lerp",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec2lerp
		},
		{name="vec2reflect", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}},  func=api_vec2reflect},
		{name="vec2rotate",  type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.FLOAT}}, func=api_vec2rotate},
		{
			name="vec2movetoward",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec2movetoward
		},
		{name="vec2invert", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}}, func=api_vec2invert},
		
		{name="vec3len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3len},
		{name="vec3lensq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3lensq},
		{name="vec3norm",      type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3norm},
		{name="vec3dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3dot},
		{name="vec3cross",     type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3cross},
		{name="vec3dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3dist},
		{name="vec3distsq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3distsq},
		{name="vec3direction", type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3direction},
		{name="vec3angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3angle},
		{
			name="vec3lerp",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3lerp
		},
		{name="vec3reflect", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}},  func=api_vec3reflect},
		{
			name="vec3rotate",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3rotate
		},
		{
			name="vec3movetoward",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3movetoward
		},
		{name="vec3invert", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_vec3invert},
		
		{name="camera",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_camera},
		{name="campos",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_campos},
		{name="camtarget",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_camtarget},
		{name="camup",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_camup},
		{name="camfov",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_camfov},
		{name="camproj",    type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_camproj},
		{name="camright",   type_info={e3d.EVMType.VEC3},                                        func=api_camright},
		{name="camforward", type_info={e3d.EVMType.VEC3},                                        func=api_camforward},
		
		{name="bgcolor",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_bgcolor},
		{name="texturemode", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_texturemode},
		{name="cullmode",    type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_cullmode},
		{name="wiremode",    type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_wiremode},

		{
			name="sprite2d",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_sprite2d
		},
		{
			name="ssprite2d",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_ssprite2d
		},

		{name="meshbegin", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_meshbegin},
		{name="meshend",   type_info={e3d.EVMType.VOID},                                      func=api_meshend},
		{
			name="texture",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_texture
		},
		{name="vertex",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_vertex},
		{name="vertex2d",   type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}}, func=api_vertex2d},
		{name="texcoord",   type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}}, func=api_texcoord},
		{name="color",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},  func=api_color},
		{name="pushmatrix", type_info={e3d.EVMType.VOID},                                       func=api_pushmatrix},
		{name="popmatrix",  type_info={e3d.EVMType.VOID},                                       func=api_popmatrix},
		{name="identity",   type_info={e3d.EVMType.VOID},                                       func=api_identity},
		{name="translate",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_translate},
		{name="rotate",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_rotate},
		{name="scale",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_scale}
	}

	self.api_ids:reserve(#api_ids + 2)
	for i = 0, < #api_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = api_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		id.index = i
		self.api_ids[id.name] = id
		self.api_funcs[i] = id.func
	end
end
