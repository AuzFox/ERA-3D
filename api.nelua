require("e3d")

local GL_DEPTH_BUFFER_BIT <comptime> = 0x00000100
local function glClear(mask: cint): void <cimport> end

function e3d.EVM:get_argi(i: uint16): int32 <forwarddecl> end
function e3d.EVM:get_argu(i: uint16): uint32 <forwarddecl> end
function e3d.EVM:get_argf(i: uint16): float32 <forwarddecl> end
function e3d.EVM:get_argv2(i: uint16): rl.vector2 <forwarddecl> end
function e3d.EVM:get_argv3(i: uint16): rl.vector3 <forwarddecl> end
function e3d.EVM:get_argstr(i: uint16): e3d.EVMString <forwarddecl> end
function e3d.EVM:pushi(val: int32): void <forwarddecl> end
function e3d.EVM:pushu(val: uint32): void <forwarddecl> end
function e3d.EVM:pushf(val: float32): void <forwarddecl> end
function e3d.EVM:pushv2(val: rl.vector2): void <forwarddecl> end
function e3d.EVM:pushv3(val: rl.vector3): void <forwarddecl> end
function e3d.EVM:pushstr(val: e3d.EVMString): void <forwarddecl> end

function e3d.EVM:get_ram8(addr: uint32): uint8 <forwarddecl> end
function e3d.EVM:set_ram8(addr: uint32, val: uint8): boolean <forwarddecl> end
function e3d.EVM:get_ram32(addr: uint32): uint32 <forwarddecl> end
function e3d.EVM:set_ram32(addr: uint32, val: uint32): boolean <forwarddecl> end

--[[
	API FUNCTIONS TO IMPLEMENT:
	
	// math
	bool feq(float a, float b);
	// ... ?
	
	// basic graphics
	void print2d(int x, int y, nchar* fmt, ...);
	void print3d(vec3 pos, nchar* fmt, ...);
	
	// advanced graphics
	// ortho(), etc.?
	void normal(vec3 norm);
	void matrixmode(int mode);
	
	// lighting
	void lightmode(int mode);
	void light(???);
	void ambient(???);
	
	// memory
	void* alloc(int size);
	void* alloc(int size);
	void* realloc(void* ptr, int size);
	void free(void* ptr);
	void memset(void* ptr, int nbytes, int value);
	void memcpy(void* a, void* b, int nbytes);
	string strdup(string str);
	string strcat(string a, string b);
	string strfmt(string fmt, ...);
	
	// i/o
	// ...
]]

-- DEBUG API FUNCTIONS (TODO: remove)

local function api_halt(vm: *e3d.EVM): boolean
	vm.error = "- PROGRAM HALTED -\n"
	return false
end

local function api_printc(vm: *e3d.EVM): boolean
	local v: uint32 = vm:get_argu(0)
	io.printf("%c\n", (cchar)(v & 0xFF))
	return true
end

local function api_prints(vm: *e3d.EVM): boolean
	local s: e3d.EVMString = vm:get_argstr(0)

	local addr: uint32 = s.data

	for i = 0, < s.len do
		local c: uint8

		if addr > e3d.RAM_MAX_ADDR then
			io.write("\n")
			io.flush()
			vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
			return false
		end
	
		c = vm:get_ram8(addr)

		io.writef("%c", c)
		
		addr = addr + 1
	end
	
	io.write("\n")
	io.flush()

	return true
end

local function api_printi(vm: *e3d.EVM): boolean
	local v: int32 = vm:get_argi(0)
	local hex: int32 = vm:get_argi(1)
	if hex ~= 0 then
		io.printf("0x%08X\n", v)
	else
		io.printf("%d\n", v)
	end
	return true
end

local function api_printf(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)
	io.printf("%f\n", v)
	return true
end

local function api_printv2(vm: *e3d.EVM): boolean
	local v: rl.vector2 = vm:get_argv2(0)
	io.printf("(%f, %f)\n", v.x, v.y)
	return true
end

local function api_printv3(vm: *e3d.EVM): boolean
	local v: rl.vector3 = vm:get_argv3(0)
	io.printf("(%f, %f, %f)\n", v.x, v.y, v.z)
	return true
end

-- API FUNCTIONS:

local function api_pressed(vm: *e3d.EVM): boolean
	local b: uint32 = vm:get_argu(0)
	local p: uint32 = vm:get_argu(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushu(0)
	else
		vm:pushu(rl.isKeyPressed(code) and 1 or 0)
	end
	
	return true
end

local function api_released(vm: *e3d.EVM): boolean
	local b: uint32 = vm:get_argu(0)
	local p: uint32 = vm:get_argu(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushu(0)
	else
		vm:pushu(rl.isKeyReleased(code) and 1 or 0)
	end
	
	return true
end

local function api_held(vm: *e3d.EVM): boolean
	local b: uint32 = vm:get_argu(0)
	local p: uint32 = vm:get_argu(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushu(0)
	else
		vm:pushu(rl.isKeyDown(code) and 1 or 0)
	end
	
	return true
end

local function api_mini(vm: *e3d.EVM): boolean
	-- signature:
	-- int mini(int a, int b);
	
	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	
	if a < b then
		vm:pushi(a)
	else
		vm:pushi(b)
	end
	
	return true
end

local function api_maxi(vm: *e3d.EVM): boolean
	-- signature:
	-- int maxi(int a, int b);
	
	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	
	if a < b then
		vm:pushi(a)
	else
		vm:pushi(b)
	end
	
	return true
end

local function api_midi(vm: *e3d.EVM): boolean
	-- signature:
	-- int midi(int a, int b, int c);

	local a: int32 = vm:get_argi(0)
	local b: int32 = vm:get_argi(1)
	local c: int32 = vm:get_argi(2)

	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	if c < b then
		local t: int32 = c
		c = b
		b = t
	end
	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	
	vm:pushi(b)

	return true
end

local function api_wrapi(vm: *e3d.EVM): boolean
	-- signature:
	-- int wrapi(int v, int min, int max);

	local v: int32 = vm:get_argi(0)
	local min: int32 = vm:get_argi(1)
	local max: int32 = vm:get_argi(2)
	
	local range_size: int32 = max - min + 1;

	if v < min then
		v = v + range_size * ((min - v) /// range_size + 1)
	end

	vm:pushi(min + (v - min) % range_size)
	
	return true
end

local function api_minf(vm: *e3d.EVM): boolean
	-- signature:
	-- int minf(float a, float b);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)

	if a < b then
		vm:pushf(a)
	else
		vm:pushf(b)
	end

	return true
end

local function api_maxf(vm: *e3d.EVM): boolean
	-- signature:
	-- int maxf(float a, float b);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)

	if a > b then
		vm:pushf(a)
	else
		vm:pushf(b)
	end

	return true
end

local function api_midf(vm: *e3d.EVM): boolean
	-- signature:
	-- int midf(float a, float b, float c);

	local a: float32 = vm:get_argf(0)
	local b: float32 = vm:get_argf(1)
	local c: float32 = vm:get_argf(2)

	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	if c < b then
	    local t: float32 = c
	    c = b
	    b = t
	end
	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	
	vm:pushf(b)

	return true
end

local function api_wrapf(vm: *e3d.EVM): boolean
	-- signature:
	-- float wrapf(float x, float min, float max);

	local x: float32 = vm:get_argf(0)
	local min: float32 = vm:get_argf(1)
	local max: float32 = vm:get_argf(2)
	
	if min == max then
        vm:pushf(min)
		return true
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    vm:pushf(min + ((temp + ((x - min) %%% temp)) %%% temp))
	
	return true
end

local function api_signi(vm: *e3d.EVM): boolean
	local x: int32 = vm:get_argi(0)

	vm:pushi(math.sign(x))

	return true
end

local function api_signf(vm: *e3d.EVM): boolean
	local x: float32 = vm:get_argf(0)

	vm:pushf(math.sign(x))

	return true
end

local function api_fract(vm: *e3d.EVM): boolean
	local x: float32 = vm:get_argf(0)

	vm:pushf(math.fract(x))

	return true
end

local function api_deg(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.deg(v))

	return true
end

local function api_rad(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.rad(v))

	return true
end

local function api_sin(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.sin(v))

	return true
end

local function api_cos(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.cos(v))

	return true
end

local function api_floor(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.floor(v))

	return true
end

local function api_ceil(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.ceil(v))

	return true
end

local function api_round(vm: *e3d.EVM): boolean
	local v: float32 = vm:get_argf(0)

	vm:pushf(math.round(v))

	return true
end

local function api_randomize(vm: *e3d.EVM): boolean
	math.randomseed()

	return true
end

local function api_randomizeEx(vm: *e3d.EVM): boolean
	local seed: uint32 = vm:get_argu(0)

	math.randomseed(seed)

	return true
end

local function api_randi(vm: *e3d.EVM): boolean
	local min: int32 = vm:get_argi(0)
	local max: int32 = vm:get_argi(1)

	if max < min then
		min, max = max, min
	end

	vm:pushi(math.random(min, max))

	return true
end

local function api_randiEx(vm: *e3d.EVM): boolean
	vm:pushi(math.random(0)) -- get int will all random bits

	return true
end

local function api_randf(vm: *e3d.EVM): boolean
	local min: float32 = vm:get_argf(0)
	local max: float32 = vm:get_argf(1)

	if max < min then
		min, max = max, min
	end

	local x: float32 = math.random() -- gets a float in [0, 1)

	vm:pushf(min + x * (max - min))

	return true
end

local function api_randfEx(vm: *e3d.EVM): boolean
	vm:pushf(math.random())

	return true
end

local function api_time(vm: *e3d.EVM): boolean
	vm:pushf((@float32)(rl.getTime() - vm.init_time))
	
	return true
end

local function api_vec2Len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Len(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	vm:pushf(math.sqrt(v.x * v.x + v.y * v.y))

	return true
end

local function api_vec2LenSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LenSq(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	vm:pushf(v.x * v.x + v.y * v.y)

	return true
end

local function api_vec2Norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Norm(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	local l: float32 = v.x * v.x + v.y * v.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
	end

	vm:pushv2(v)

	return true
end

local function api_vec2Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Dot(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(a.x * b.x + a.y * b.y)

	return true
end

local function api_vec2Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Cross(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(a.x * b.y - a.y * b.x)

	return true
end

local function api_vec2Dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Dist(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)))
	
	return true
end

local function api_vec2DistSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2DistSq(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	
	vm:pushf((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
	
	return true
end

local function api_vec2Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Direction(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local direction: rl.vector2 = b - a;

	local l: float32 = direction.x * direction.x + direction.y * direction.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
	end

	vm:pushv2(direction)

	return true
end

local function api_vec2Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Angle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(math.atan2(b.y - a.y, b.x - a.x))

	return true
end

local function api_vec2LineAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LineAngle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	vm:pushf(rl.vector2LineAngle(a, b))

	return true
end

local function api_vec2Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Lerp(vec2 a, vec2 b, float amount);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local amount: float32 = vm:get_argf(4)

	a:lerp(b, amount)

	vm:pushv2(a)

	return true
end

local function api_vec2Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Reflect(vec2 a, vec2 b);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)

	a:reflect(b)
	
	vm:pushv2(a)
	
	return true
end

local function api_vec2Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Rotate(vec2 v, float angle);

	local v: rl.vector2 = vm:get_argv2(0)
	local angle: float32 = vm:get_argf(2)

	v:rotate(angle)
	
	vm:pushv2(v)

	return true
end

local function api_vec2MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2MoveToward(vec2 a, vec2 b, float delta);

	local a: rl.vector2 = vm:get_argv2(0)
	local b: rl.vector2 = vm:get_argv2(2)
	local delta: float32 = vm:get_argf(4)

	local dest: rl.vector2 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushv2(b)
	else
		local temp: rl.vector2 = {
			dest.x / length * delta,
			dest.y / length * delta
		}
		vm:pushv2(a + temp)
	end

	return true
end

local function api_vec2Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Invert(vec2 v);
	
	local v: rl.vector2 = vm:get_argv2(0)

	v:invert()

	vm:pushv2(v)

	return true
end

local function api_vec3Len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Len(vec3 v);
	
	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(math.sqrt(x + y + z))
	
	return true
end

local function api_vec3LenSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3LenSq(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(x + y + z)
	
	return true
end

local function api_vec3Norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Norm(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	vm:pushv3(v)
	
	return true
end

local function api_vec3Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Dot(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	vm:pushf(a.x * b.x + a.y * b.y + a.z * b.z)
	
	return true
end

local function api_vec3Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Cross(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	local v: rl.vector3 = {
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	}

	vm:pushv3(v)
	
	return true
end

local function api_vec3Dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Dist(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(math.sqrt(x + y + z))
	
	return true
end

local function api_vec3DistSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3DistSq(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushf(x + y + z)
	
	return true
end

local function api_vec3Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec3Direction(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local direction: rl.vector3 = b - a;

	local x: float32 = direction.x * direction.x
	local y: float32 = direction.y * direction.y
	local z: float32 = direction.z * direction.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
		direction.z = direction.z / l
	end

	vm:pushv3(direction)

	return true
end

local function api_vec3Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Angle(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	vm:pushf(a:angle(b))

	return true
end
local function api_vec3Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Lerp(vec3 a, vec3 b, float amount);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local amount: float32 = vm:get_argf(6)

	a:lerp(b, amount)
	
	vm:pushv3(a)

	return true
end
local function api_vec3Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Reflect(vec3 a, vec3 b);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)

	a:reflect(b)
	
	vm:pushv3(a)

	return true
end
local function api_vec3Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Rotate(vec3 v, vec3 axis, float angle);

	local v: rl.vector3 = vm:get_argv3(0)
	local axis: rl.vector3 = vm:get_argv3(3)
	local angle: float32 = vm:get_argf(6)

	v:rotateByAxisAngle(axis, angle)
	
	vm:pushv3(v)

	return true
end
local function api_vec3MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3MoveToward(vec3 a, vec3 b, float delta);

	local a: rl.vector3 = vm:get_argv3(0)
	local b: rl.vector3 = vm:get_argv3(3)
	local delta: float32 = vm:get_argf(6)

	local dest: rl.vector3 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushv3(b)
	else
		local temp: rl.vector3 = {
			dest.x / length * delta,
			dest.y / length * delta,
			dest.z / length * delta
		}
		vm:pushv3(a + temp)
	end

	return true
end
local function api_vec3Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Invert(vec3 a);

	local v: rl.vector3 = vm:get_argv3(0)

	v:invert()
	
	vm:pushv3(v)

	return true
end


local function api_camera3D(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera3D(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	-- copy Raylib's BeginMode3D(),
	-- but we don't need to push a new projection matrix or enable depth testing

	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
    rlgl.loadIdentity()

	local aspect: float32 = (@float32)(vm.gpu.viewport_w) / (@float32)(vm.gpu.viewport_h)

	-- 0.01 is the near clipping value
	-- 1000.0 is the far clipping value
	-- TODO: allow setting near/far?
	if cam.projection == rl.cameraProjection.PERSPECTIVE then
		local top: float64 = 0.01 * math.tan(cam.fovy * 0.5 * (math.pi / 180.0))
		local right: float64 = top * aspect

		rlgl.frustum(-right, right, -top, top, 0.01, 1000.0)
	elseif cam.projection == rl.cameraProjection.ORTHOGRAPHIC then
		local top: float64 = cam.fovy / 2.0
		local right: float64 = top * aspect

		rlgl.ortho(-right, right, -top, top, 0.01, 1000.0)
	end

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	local mat_view: rl.matrix = rl.matrix.lookAt(cam.position, cam.target, cam.up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	return true
end

local function api_getCamPos(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCamPos(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)

	vm:pushv3(vm.gpu.cameras[id].position)

	return true
end

local function api_setCamPos(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCamPos(int id, vec3 pos);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local pos: rl.vector3 = vm:get_argv3(1)

	vm.gpu.cameras[id].position = pos

	return true
end

local function api_getCamTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCamTarget(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)

	vm:pushv3(vm.gpu.cameras[id].target)

	return true
end

local function api_setCamTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCamTarget(int id, vec3 target);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local target: rl.vector3 = vm:get_argv3(1)

	vm.gpu.cameras[id].target = target

	return true
end

local function api_getCamUp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCamUp(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)

	vm:pushv3(vm.gpu.cameras[id].up)

	return true
end

local function api_setCamUp(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCamUp(int id, vec3 up);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local up: rl.vector3 = vm:get_argv3(1)

	vm.gpu.cameras[id].up = up

	return true
end

local function api_getCamFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCamFOV(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)

	vm:pushf(vm.gpu.cameras[id].fovy)

	return true
end

local function api_setCamFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCamFOV(int id, float fov);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local fov: float32 = vm:get_argf(1)

	vm.gpu.cameras[id].fovy = fov

	return true
end

local function api_getCamProj(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCamProj(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)

	vm:pushi((@int32)(vm.gpu.cameras[id].projection))

	return true
end

local function api_setCamProj(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCamProj(int id, int mode);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local proj: float32 = vm:get_argi(1)

	vm.gpu.cameras[id].projection = (@cint)(math.clamp(proj, 0, 1))

	return true
end

local function _v3norm(v: rl.vector3): rl.vector3
	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	return v
end

local function api_getCamRight(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCamRight(int id);

	-- get camera
	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	-- calculate forward vector
	local forward: rl.vector3 = _v3norm({
			cam.target.x - cam.position.x,
			cam.target.y - cam.position.y,
			cam.target.z - cam.position.z
		}
	)

	-- get normalized up vector
    local up: rl.vector3 = _v3norm(cam.up)

	-- calculate cross of forward and up
	vm:pushv3({
			(forward.y * up.z) - (forward.z * up.y),
			(forward.z * up.x) - (forward.x * up.z),
			(forward.x * up.y) - (forward.y * up.x)
		}
	)

	return true
end

local function api_getCamForward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCamForward(int id);

	local id: uinteger = math.clamp(vm:get_argu(0), 0, e3d.CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	vm:pushv3(
		_v3norm({
				cam.target.x - cam.position.x,
				cam.target.y - cam.position.y,
				cam.target.z - cam.position.z
			}
		)
	)

	return true
end

local function api_getTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getTextureMode();

	vm:pushi((@int32)(vm.gpu.tex_mode))

	return true
end

local function api_setTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setTextureMode(int mode);

	local mode: uint32 = vm:get_argu(0)

	if mode > 2 then
		mode = 2
	end

	vm.gpu.tex_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.tex_mode_loc, &vm.gpu.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function api_getCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCullMode();

	vm:pushi((@int32)(vm.gpu.cull_mode))

	return true
end

local function api_setCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCullMode(int mode);

	local mode: uint32 = vm:get_argu(0)

	switch mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
			mode = 2
	end

	vm.gpu.cull_mode = mode

	return true
end

local function api_getWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getWireMode();

	vm:pushi(vm.gpu.wire_mode and 1 or 0)

	return true
end

local function api_setWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setWireMode(int mode);

	local enable: boolean = vm:get_argu(0) ~= 0

	if enable then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	vm.gpu.wire_mode = enable

	return true
end

local function api_getFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogMode();

	vm:pushi((@int32)(vm.gpu.fog_mode))

	return true
end

local function api_setFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogMode(int mode);

	local mode: uint32 = vm:get_argu(0)

	if mode > 1 then
		mode = 1
	end

	vm.gpu.fog_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_mode_loc, &vm.gpu.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function api_getFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogStart();

	vm:pushf(vm.gpu.fog_start)

	return true
end

local function api_setFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogStart(float start);

	local start: float32 = vm:get_argf(0)

	start = math.clamp(start, 0.0, 1000.0)
	
	vm.gpu.fog_start = start
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_start_loc, &vm.gpu.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	
	return true
end

local function api_getFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogEnd();

	vm:pushf(vm.gpu.fog_end)

	return true
end

local function api_setFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogEnd(float end);
	
	local fend: float32 = vm:get_argf(0)
	
	fend = math.clamp(fend, 0.0, 1000.0)
	
	vm.gpu.fog_end = fend
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_end_loc, &vm.gpu.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)

	return true
end

local function api_getFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogColor();
	
	local ray_col: rl.color = rl.colorFromNormalized(vm.gpu.fog_color)

	local r: uint32 = (@uint32)(ray_col.r)
	local g: uint32 = (@uint32)(ray_col.g)
	local b: uint32 = (@uint32)(ray_col.b)
	local a: uint32 = (@uint32)(ray_col.a)
	
	vm:pushu((r << 24) | (g << 16) | (b << 8) | a)

	return true
end

local function api_setFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogColor(float color);

	local col: uint32 = vm:get_argu(0)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	vm.gpu.fog_color = rl.colorNormalize(ray_col)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_color_loc, &vm.gpu.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)

	return true
end

local function api_texture(vm: *e3d.EVM): boolean
	-- signature:
	-- void texture(int x, int y, int w, int h);

	local x: int32 = vm:get_argi(0)
	local y: int32 = vm:get_argi(1)
	local w: int32 = vm:get_argi(2)
	local h: int32 = vm:get_argi(3)

	w = math.clamp(w, 1, 256)
	h = math.clamp(h, 1, 256)
	x = math.clamp(x, 0, 1024 - w)
	y = math.clamp(y, 0, 1024 - h)

	vm.gpu:texture(x, y, w, h)

	return true
end

local function api_clear(vm: *e3d.EVM): boolean
	-- signature:
	-- void clear(int col);

	local col: uint32 = vm:get_argu(0)

	local alpha: cuchar = (@cuchar)(col & 0xFF)

	if alpha ~= 0 then
		local clear_color: rl.color = {
			(@cuchar)(col >> 24),
			(@cuchar)((col & 0xFF0000) >> 16),
			(@cuchar)((col & 0x00FF00) >> 8),
			0xFF
		}

		rl.clearBackground(clear_color)
	else
		glClear(GL_DEPTH_BUFFER_BIT) -- clear the depth buffer, but not the color buffer
	end

	return true
end

local function api_viewport(vm: *e3d.EVM): boolean
	-- signature:
	-- void viewport(int x, int y, int w, int h);

	local x: cint = (@cint)(vm:get_argi(0))
	local y: cint = (@cint)(vm:get_argi(1))
	local w: cint = (@cint)(vm:get_argi(2))
	local h: cint = (@cint)(vm:get_argi(3))

	w = math.clamp(w, 1, e3d.VSCREEN_W)
	h = math.clamp(h, 1, e3d.VSCREEN_H)
	x = math.clamp(x, 0, e3d.VSCREEN_W - w)
	y = math.clamp(y, 0, e3d.VSCREEN_H - h)

	y = e3d.VSCREEN_H - (y + h) -- flip y

	vm.gpu.viewport_w = w
	vm.gpu.viewport_h = h

	rlgl.viewport(x, y, w, h)
	rlgl.scissor(x, y, w, h)

	return true
end

local function api_sprite2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2D(int srcx, int srcy, int srcw, int srch, int destx, int desy);

	local srcx: int32 = vm:get_argi(0)
	local srcy: int32 = vm:get_argi(1)
	local srcw: int32 = vm:get_argi(2)
	local srch: int32 = vm:get_argi(3)
	local destx: int32 = vm:get_argi(4)
	local desty: int32 = vm:get_argi(5)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(srcw), (@float32)(srch) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function api_spriteEx2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void spriteEx2D(int srcx, int srcy, int srcw, int srch, int destx, int desy, int destw, int desth);

	local srcx: int32 = vm:get_argi(0)
	local srcy: int32 = vm:get_argi(1)
	local srcw: int32 = vm:get_argi(2)
	local srch: int32 = vm:get_argi(3)
	local destx: int32 = vm:get_argi(4)
	local desty: int32 = vm:get_argi(5)
	local destw: int32 = vm:get_argi(6)
	local desth: int32 = vm:get_argi(7)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function api_beginMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void beginMesh(int mode);

	local mode: uint32 = vm:get_argu(0)

	switch mode do
		case 0 then
			vm.gpu.triangle_mode = false
			mode = rlgl.LINES
		case 1 then
			vm.gpu.triangle_mode = true
			vm.gpu.triangle_vert_index = 0
			mode = rlgl.QUADS
		else
			vm.gpu.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(vm.gpu.gfx_shader)

	rlgl.setTexture(vm.gpu.gfx_texture.id)
	
	rlgl.begin(mode)
	
	return true
end

local function api_endMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void endMesh();

	rlgl.ending()

	rl.endShaderMode()
	
	return true
end

local function api_vertex(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex(vec3 v);

	local v: rl.vector3 = vm:get_argv3(0)

	rlgl.vertex3f(v.x, v.y, v.z)
	
	if vm.gpu.triangle_mode then
		if vm.gpu.triangle_vert_index == 0 then
			vm.gpu.triangle_vert_pos = v
		elseif vm.gpu.triangle_vert_index == 2 then
			-- send copy of first vertex to allow textured tris
			rlgl.color4ub(
				vm.gpu.triangle_vert_color.r,
				vm.gpu.triangle_vert_color.g,
				vm.gpu.triangle_vert_color.b,
				vm.gpu.triangle_vert_color.a
			)
			rlgl.texCoord2f(
				vm.gpu.triangle_vert_uv.x,
				vm.gpu.triangle_vert_uv.y
			)
			rlgl.vertex3f(
				vm.gpu.triangle_vert_pos.x,
				vm.gpu.triangle_vert_pos.y,
				vm.gpu.triangle_vert_pos.z
			)
			
			vm.gpu.triangle_vert_index = 0
			return true
		end

		vm.gpu.triangle_vert_index = vm.gpu.triangle_vert_index + 1
	end
	
	return true
end

local function api_vertex2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex2D(vec2 v);

	local v: rl.vector2 = vm:get_argv2(0)

	rlgl.vertex2f(v.x, v.y)
	
	if vm.gpu.triangle_mode then
		if vm.gpu.triangle_vert_index == 0 then
			vm.gpu.triangle_vert_pos.x = v.x
			vm.gpu.triangle_vert_pos.y = v.y
		elseif vm.gpu.triangle_vert_index == 2 then
			-- send copy of first vertex to allow textured tris
			rlgl.color4ub(
				vm.gpu.triangle_vert_color.r,
				vm.gpu.triangle_vert_color.g,
				vm.gpu.triangle_vert_color.b,
				vm.gpu.triangle_vert_color.a
			)
			rlgl.texCoord2f(
				vm.gpu.triangle_vert_uv.x,
				vm.gpu.triangle_vert_uv.y
			)
			rlgl.vertex2f(
				vm.gpu.triangle_vert_pos.x,
				vm.gpu.triangle_vert_pos.y
			)
			
			vm.gpu.triangle_vert_index = 0
			return true
		end

		vm.gpu.triangle_vert_index = vm.gpu.triangle_vert_index + 1
	end
	
	return true
end

local function api_vertUV(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertUV(vec2 uv);

	local v: rl.vector2 = vm:get_argv2(0)
	
	rlgl.texCoord2f(v.x, v.y)

	if vm.gpu.triangle_mode and (vm.gpu.triangle_vert_index == 0) then
		vm.gpu.triangle_vert_uv = v
	end
	
	return true
end

local function api_vertColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertColor(int col);

	local col: uint32 = vm:get_argu(0)
	local r: cuchar = (@cuchar)(col >> 24)
	local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
	local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
	local a: cuchar = (@cuchar)(col & 0xFF)
	
	rlgl.color4ub(r, g, b, a)

	if vm.gpu.triangle_mode and (vm.gpu.triangle_vert_index == 0) then
		vm.gpu.triangle_vert_color = {r, g, b, a}
	end
	
	return true
end

-- void normal(vec3 norm);

local function api_matrixMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void matrixMode(int mode);

	local mode: uint32 = vm:get_argu(0)

	if mode > 1 then
		mode = 1
	end

	switch mode do
		case 0 then
			rlgl.matrixMode(rlgl.PROJECTION)
		case 1 then
			rlgl.matrixMode(rlgl.MODELVIEW)
	end

	return true
end

local function api_pushMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void pushMatrix();

	rlgl.pushMatrix()
	
	return true
end

local function api_popMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void popMatrix();

	rlgl.popMatrix()
	
	return true
end

local function api_identity(vm: *e3d.EVM): boolean
	-- signature:
	-- void identity();

	rlgl.loadIdentity()
	
	return true
end

local function api_translate(vm: *e3d.EVM): boolean
	-- signature:
	-- void translate(vec3 pos);

	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.translatef(v.x, v.y, v.z)
	
	return true
end

local function api_rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- void rotate(vec3 rot);

	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.rotatef(v.x, 1, 0, 0)
	rlgl.rotatef(v.y, 0, 1, 0)
	rlgl.rotatef(v.z, 0, 0, 1)
	
	return true
end

local function api_scale(vm: *e3d.EVM): boolean
	-- signature:
	-- void scale(vec3 sca);
	
	local v: rl.vector3 = vm:get_argv3(0)
	
	rlgl.scalef(v.x, v.y, v.z)
	
	return true
end

local function api_peek8(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek8(int addr);

	local addr: uint32 = vm:get_argu(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
		return false
	end

	vm:pushu(vm:get_ram8(addr))

	return true
end

local function api_poke8(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke8(int addr, int val);

	local addr: uint32 = vm:get_argu(0)
	local val: uint8 = (@uint8)(vm:get_argu(1) & 0xFF)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte write address 0x%08X\n", addr)
		return false
	end

	if not vm:set_ram8(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

local function api_peek32(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek32(int addr);

	local addr: uint32 = vm:get_argu(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", addr)
		return false
	end

	vm:pushu(vm:get_ram32(addr))

	return true
end

local function api_poke32(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke32(int addr, int val);

	local addr: uint32 = vm:get_argu(0)
	local val: uint32 = vm:get_argu(1)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word write address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word write address 0x%08X\n", addr)
		return false
	end

	if not vm:set_ram32(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write word to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

function e3d.EVM:register_builtins(): void
	local keyword_ids: []e3d.Identifier = {
		{name="void",     token=e3d.Token.VOID},
		{name="int",      token=e3d.Token.INT},
		{name="float",    token=e3d.Token.FLOAT},
		{name="vec2",     token=e3d.Token.VEC2},
		{name="vec3",     token=e3d.Token.VEC3},
		{name="string",   token=e3d.Token.STRING},
		{name="enum",     token=e3d.Token.ENUM},
		{name="struct",   token=e3d.Token.STRUCT},
		{name="if",       token=e3d.Token.IF},
		{name="else",     token=e3d.Token.ELSE},
		{name="return",   token=e3d.Token.RETURN},
		{name="break",    token=e3d.Token.BREAK},
		{name="continue", token=e3d.Token.CONTINUE},
		{name="sizeof",   token=e3d.Token.SIZEOF},
		{name="for",      token=e3d.Token.FOR},
		{name="while",    token=e3d.Token.WHILE}
	}

	local constant_ids: []e3d.Identifier = {
		{name="true",  type_info={e3d.EVMType.INT}, const_val=1},
		{name="false", type_info={e3d.EVMType.INT}, const_val=0},
		{name="null",  type_info={e3d.EVMType.INT}, const_val=0} -- TODO: change value to actual null address
	}

	local constructor_ids: []e3d.Identifier = {
		{name="vec2Zero", type_info={e3d.EVMType.VEC2}},
		{name="vec3Zero", type_info={e3d.EVMType.VEC3}}
	}

	self.keywords:reserve(#keyword_ids)
	for i = 0, < #keyword_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = keyword_ids[i]
		id.class = e3d.Class.KEYWORD
		self.keywords[id.name] = id
	end

	self.constants:reserve(#constant_ids)
	for i = 0, < #constant_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constant_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.CONSTANT
		self.constants[id.name] = id
	end

	-- vector construction functions are special cases,
	-- they are translated directly to opcodes
	for i = 0, < #constructor_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constructor_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		self.api_ids[id.name] = id
	end

	-- define vec2 struct
	local sid: *e3d.Struct = new(@e3d.Struct)
	local v2x: *e3d.Identifier = new(@e3d.Identifier)
	local v2y: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec2"
	v2x.name = "x"
	v2x.index = 0
	v2x.type_info = {e3d.EVMType.FLOAT}

	v2y.name = "y"
	v2y.index = 1
	v2y.type_info = {e3d.EVMType.FLOAT}

	sid:add_member(v2x)
	sid:add_member(v2y)
	sid.is_complete = true
	self.struct_vec2 = sid

	-- define vec3 struct
	sid = new(@e3d.Struct)
	local v3x: *e3d.Identifier = new(@e3d.Identifier)
	local v3y: *e3d.Identifier = new(@e3d.Identifier)
	local v3z: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec3"
	v3x.name = "x"
	v3x.index = 0
	v3x.type_info = {e3d.EVMType.FLOAT}

	v3y.name = "y"
	v3y.index = 1
	v3y.type_info = {e3d.EVMType.FLOAT}

	v3z.name = "z"
	v3z.index = 2
	v3z.type_info = {e3d.EVMType.FLOAT}

	sid:add_member(v3x)
	sid:add_member(v3y)
	sid:add_member(v3z)
	sid.is_complete = true
	self.struct_vec3 = sid

	-- define string struct
	sid = new(@e3d.Struct)
	local string_len: *e3d.Identifier = new(@e3d.Identifier)
	local string_data: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "string"
	string_len.name = "len"
	string_len.index = 0
	string_len.type_info = {e3d.EVMType.INT}

	string_data.name = "data"
	string_data.index = 1
	string_data.type_info = {e3d.EVMType.VOID + e3d.EVMType.POINTER}

	sid:add_member(string_len)
	sid:add_member(string_data)
	sid.is_complete = true
	self.struct_string = sid
end

function e3d.EVM:register_api(): void
	local api_ids: []e3d.Identifier = {
		{name="halt", type_info={e3d.EVMType.VOID}, func=api_halt},
		
		{name="printc",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},                            func=api_printc},
		{name="prints",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.STRING}},                         func=api_prints},
		{name="printi",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_printi},
		{name="printf",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}},                          func=api_printf},
		{name="printv2", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},                           func=api_printv2},
		{name="printv3", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},                           func=api_printv3},
		
		{
			name="pressed",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_pressed
		},
		{
			name="released",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_released
		},
		{
			name="held",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_held
		},
		
		{name="mini",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=api_mini},
		{name="maxi",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=api_maxi},
		{name="midi",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_midi},
		{name="wrapi", type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=api_wrapi},

		{name="minf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=api_minf},
		{name="maxf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=api_maxf},
		{name="midf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_midf},
		{name="wrapf", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_wrapf},
		
		{name="signi", type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}},   func=api_signi},
		{name="signf", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_signf},
		{name="fract", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_fract},

		{name="deg",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_deg},
		{name="rad",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_rad},
		{name="sin",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_sin},
		{name="cos",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_cos},
		{name="floor",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_floor},
		{name="ceil",   type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_ceil},
		{name="round",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_round},

		{name="randomize",   type_info={e3d.EVMType.VOID},                                                                      func=api_randomize},
		{name="randomizeEx", type_info={e3d.EVMType.VOID},  argdata={{type_id=e3d.EVMType.INT}},                                func=api_randomizeEx},
		{name="randi",       type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},     func=api_randi},
		{name="randiEx",     type_info={e3d.EVMType.INT},                                                                       func=api_randiEx},
		{name="randf",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=api_randf},
		{name="randfEx",     type_info={e3d.EVMType.FLOAT},                                                                     func=api_randfEx},
		
		{name="time", type_info={e3d.EVMType.FLOAT}, func=api_time},
		
		{name="vec2Len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2Len},
		{name="vec2LenSq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2LenSq},
		{name="vec2Norm",      type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}},                             func=api_vec2Norm},
		{name="vec2Dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2Dot},
		{name="vec2Cross",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2Cross},
		{name="vec2Dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2Dist},
		{name="vec2DistSq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2DistSq},
		{name="vec2Direction", type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2Direction},
		{name="vec2Angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2Angle},
		{name="vec2LineAngle", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=api_vec2LineAngle},
		{
			name="vec2Lerp",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec2Lerp
		},
		{name="vec2Reflect", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}},  func=api_vec2Reflect},
		{name="vec2Rotate",  type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.FLOAT}}, func=api_vec2Rotate},
		{
			name="vec2MoveToward",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec2MoveToward
		},
		{name="vec2Invert", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}}, func=api_vec2Invert},
		
		{name="vec3Len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3Len},
		{name="vec3LenSq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3LenSq},
		{name="vec3Norm",      type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}},                             func=api_vec3Norm},
		{name="vec3Dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3Dot},
		{name="vec3Cross",     type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3Cross},
		{name="vec3Dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3Dist},
		{name="vec3DistSq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3DistSq},
		{name="vec3Direction", type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3Direction},
		{name="vec3Angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=api_vec3Angle},
		{
			name="vec3Lerp",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3Lerp
		},
		{name="vec3Reflect", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}},  func=api_vec3Reflect},
		{
			name="vec3Rotate",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3Rotate
		},
		{
			name="vec3MoveToward",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_vec3MoveToward
		},
		{name="vec3Invert", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}}, func=api_vec3Invert},
		
		{name="camera3D", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=api_camera3D},
		{
			name="getCamPos",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamPos
		},
		{
			name="setCamPos",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=api_setCamPos
		},
		{
			name="getCamTarget",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamTarget
		},
		{
			name="setCamTarget",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=api_setCamTarget
		},
		{
			name="getCamUp",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamUp
		},
		{
			name="setCamUp",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=api_setCamUp
		},
		{
			name="getCamFOV",
			type_info={e3d.EVMType.FLOAT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamFOV
		},
		{
			name="setCamFOV",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=api_setCamFOV
		},
		{
			name="getCamProj",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamProj
		},
		{
			name="setCamProj",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_setCamProj
		},
		{
			name="getCamRight",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamRight
		},
		{
			name="getCamForward",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_getCamForward
		},
		
		{
			name="viewport",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_viewport
		},
		{
			name="texture",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_texture
		},
		{name="getTextureMode",  type_info={e3d.EVMType.INT},                                         func=api_getTextureMode},
		{name="setTextureMode",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_setTextureMode},
		{name="getCullMode",     type_info={e3d.EVMType.INT},                                         func=api_getCullMode},
		{name="setCullMode",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_setCullMode},
		{name="getWireMode",     type_info={e3d.EVMType.INT},                                         func=api_getWireMode},
		{name="setWireMode",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_setWireMode},
		{name="getFogMode",      type_info={e3d.EVMType.INT},                                         func=api_getFogMode},
		{name="setFogMode",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_setFogMode},
		{name="getFogStart",     type_info={e3d.EVMType.FLOAT},                                       func=api_getFogStart},
		{name="setFogStart",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_setFogStart},
		{name="getFogEnd",       type_info={e3d.EVMType.FLOAT},                                       func=api_getFogEnd},
		{name="setFogEnd",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=api_setFogEnd},
		{name="getFogColor",     type_info={e3d.EVMType.INT},                                         func=api_getFogColor},
		{name="setFogColor",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_setFogColor},
		{name="matrixMode",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_matrixMode},
		{name="clear",           type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_clear},
		{name="pushMatrix",      type_info={e3d.EVMType.VOID},                                        func=api_pushMatrix},
		{name="popMatrix",       type_info={e3d.EVMType.VOID},                                        func=api_popMatrix},
		{name="identity",        type_info={e3d.EVMType.VOID},                                        func=api_identity},
		{name="translate",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_translate},
		{name="rotate",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_rotate},
		{name="scale",           type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_scale},
		{name="vertex",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=api_vertex},
		{name="vertex2D",        type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},  func=api_vertex2D},
		{name="vertUV",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},  func=api_vertUV},
		{name="vertColor",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_vertColor},
		{name="beginMesh",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=api_beginMesh},
		{name="endMesh",         type_info={e3d.EVMType.VOID},                                        func=api_endMesh},
		{
			name="sprite2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_sprite2D
		},
		{
			name="spriteEx2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_spriteEx2D
		},

		{
			name="peek8",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_peek8
		},
		{
			name="poke8",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_poke8
		},
		{
			name="peek32",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=api_peek32
		},
		{
			name="poke32",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=api_poke32
		},
	}

	self.api_ids:reserve(#api_ids + 2)
	for i = 0, < #api_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = api_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		id.index = i
		self.api_ids[id.name] = id
		self.api_funcs[i] = id.func
	end
end
