require("blipkit")
require("raylib")

-- TODO: implement playback from SEQBANK

global SoundchipBank = @enum {
	SYSTEM = 0,
	WAVBANK0 = 1,
	WAVBANK1,
	SEQBANK0 = 1,
	SEQBANK1,
	SEQBANK2,
	SEQBANK3,
	SEQBANK4,
	SEQBANK5,
	SEQBANK6,
	SEQBANK7
}

-- playflags byte:
-- M L 0 0 0 0 PM
-- M = mute
-- L = loop
-- PM = playmode (2 bits)
global PlayFlags = @enum {
	PLAY_SONG = 0,
	PLAY_PATTERN,
	PLAY_SAMPLE,
	PLAY_MASK = 0b00000011,
	MUTE      = 0b10000000,
	LOOP      = 0b01000000
}

global SOUNDCHIP_TRACK_COUNT <comptime> = 8
global SOUNDCHIP_SAMPLE_RATE <comptime> = 22050 -- 22050hz sample rate
global SOUNDCHIP_FRAMES_PER_UPDATE <comptime> = 2048
global SOUNDCHIP_EMPTY_VALUE <comptime> = 0xFF
global SOUNDCHIP_NOTE_MUTE <comptime> = 0xFE
global SOUNDCHIP_NOTE_RELEASE <comptime> = 0xFD
global SOUNDCHIP_MIN_OCTAVE <comptime> = 0
global SOUNDCHIP_MAX_OCTAVE <comptime> = 7
global SOUNDCHIP_OCTAVE_SIZE <comptime> = 12

global SOUNDCHIP_SONG_SIZE <comptime> = 256 * 8
global SOUNDCHIP_PATTERN_ROW_SIZE <comptime> = 5
global SOUNDCHIP_PATTERN_SIZE <comptime> = 64 * SOUNDCHIP_PATTERN_ROW_SIZE
global SOUNDCHIP_PATTERN_COUNT <comptime> = 256
global SOUNDCHIP_INSTRUMENT_SIZE <comptime> = 11
global SOUNDCHIP_INSTRUMENT_COUNT <comptime> = 256
global SOUNDCHIP_GROOVE_SIZE <comptime> = 64
global SOUNDCHIP_GROOVE_COUNT <comptime> = 16

global SOUNDCHIP_PATTERN_DATA_START <comptime> = SOUNDCHIP_SONG_SIZE
global SOUNDCHIP_INSTRUMENT_DATA_START <comptime> = SOUNDCHIP_PATTERN_DATA_START + (SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)
global SOUNDCHIP_GROOVE_DATA_START <comptime> = SOUNDCHIP_INSTRUMENT_DATA_START + (SOUNDCHIP_INSTRUMENT_COUNT * SOUNDCHIP_INSTRUMENT_SIZE)
global SOUNDCHIP_WAVMEM_SIZE <comptime> = ((7 * 1024 * 1024) /// 2) -- 7 MiB of 16 bit audio samples
global SOUNDCHIP_SEQMEM_SIZE <comptime> = 256 * 1024 -- 256 KiB
global SOUNDCHIP_AOBMEM_SIZE <comptime> = SOUNDCHIP_FRAMES_PER_UPDATE * 2 -- 8 KiB

global SOUNDCHIP_WMPBANK_SIZE <comptime> = ((13 * 1024 * 1024) + (512 * 1024)) -- 1MiB + 256 KiB
global SOUNDCHIP_WAVMAP_SIZE <comptime> = (512 * 8) -- 4KiB

global SoundChip <forwarddecl> = @record {}

global AudioState = @record {
	playing_flags: uint8
}

global TrackContext = @record {
	bk_track: BKTrack,
	bk_clock: BKClock,
	bk_divider: BKDivider,
	bk_instrument: BKInstrument,
	soundchip: *SoundChip,
	track_index: uint8
}

-- track state object, stored in sysmem
global TrackState = @record {
	playflags: uint8,
	bpm: uint8,
	volume: uint8,
	pan: uint8,
	song_id: uint8,
	song_pos: uint8,
	pattern_id: uint8,
	pattern_pos: uint8,
	groove_id: uint8,
	groove_pos: uint8
}

SoundChip = @record {
	seqmem: [SOUNDCHIP_SEQMEM_SIZE]uint8, -- song, chain, phrase, instrument, and state data
	wavmem: [SOUNDCHIP_WAVMEM_SIZE]BKFrame, -- sample wave data
	aobmem: [SOUNDCHIP_AOBMEM_SIZE]BKFrame, -- working audio buffer
	track_contexts: [SOUNDCHIP_TRACK_COUNT]TrackContext,
	preview_bk_track: BKTrack,
	bk_context: BKContext,
	bk_data: BKData,
	audio_stream: rl.audioStream,
	current_wavbank: uint8, -- which region of memory to use for sample data
	current_seqbank: uint8, -- which region of memory to use for sequencer data
	bk_data_flags: BKEnum, -- flags describing sample data format

	-- memory pointers
	sysmem_ptr: *[0]uint8,
	wmpbank_ptr: *[0]uint8,
	wavbank_ptr: *[0]BKFrame,
	seqbank_ptr: *[0]uint8,
	song_data: *[0]uint8,
	pattern_data: *[0]uint8,
	instrument_data: *[0]uint8,
	groove_data: *[0]uint8,
	audio_state: *AudioState,
	track_state: *[0]uint8
}

function SoundChip:getTrackState(id: uinteger): *TrackState
    return (@*TrackState)(&self.track_state[id * #TrackState])
end

function SoundChip:getPattern(id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.pattern_data[id * SOUNDCHIP_PATTERN_SIZE])
end

function SoundChip:getPatternRow(id: uinteger, row: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.pattern_data[(id * SOUNDCHIP_PATTERN_SIZE) + (row * SOUNDCHIP_PATTERN_ROW_SIZE)])
end

function SoundChip:getInstrument(id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.instrument_data[id * SOUNDCHIP_INSTRUMENT_SIZE])
end

function SoundChip:setBPM(): void
end

function SoundChip:setInstrument(track: uint8, instrument: uint8): void
	local idata: *[0]uint8 = self:getInstrument(instrument)
	local flags: uint8 = idata[0]
	local sample_start: uint32 = ((@uint32)(idata[1]) << 16) | ((@uint32)(idata[2]) << 8) | (@uint32)(idata[3])
	local sample_end: uint32 = ((@uint32)(idata[4]) << 16) | ((@uint32)(idata[5]) << 8) | (@uint32)(idata[6])
	local attack: uint8 = idata[7]
	local decay: uint8 = idata[8]
	local sustain: uint8 = idata[9]
	local release: uint8 = idata[10]

	local tc: *TrackContext = &self.track_contexts[track]
	local range: [2]BKInt = {sample_start, sample_end}

	BKSetPtr(&tc.bk_track, BK_SAMPLE_RANGE, &range, #BKInt * 2)
	BKSetAttr(&tc.bk_track, BK_SAMPLE_REPEAT, (flags & 0b10000000 ~= 0) and BK_REPEAT or BK_NO_REPEAT)
	local percentage: float32 = (@float32)(sustain) / 255.0
	local value: BKInt = (@BKInt)(percentage * (@float32)(BK_MAX_VOLUME))
	BKInstrumentSetEnvelopeADSR(&tc.bk_instrument, attack, decay, value, release)
end

function SoundChip:playPreviewNote(note: uint8): void
	if note ~= SOUNDCHIP_EMPTY_VALUE then
		local bknote: BKInt
		if note == SOUNDCHIP_NOTE_MUTE then
			bknote = BK_NOTE_MUTE
		elseif note == SOUNDCHIP_NOTE_RELEASE then
			bknote = BK_NOTE_RELEASE
		else
			bknote = (@BKInt)(note) * BK_FINT20_UNIT
		end

		BKSetAttr(&self.preview_bk_track, BK_NOTE, bknote)
	end
end

function SoundChip:stopPreviewNote(note: uint8): void
	BKSetAttr(&self.preview_bk_track, BK_NOTE, BK_NOTE_MUTE)
end

function SoundChip:stopTrack(track: uint8): void
	local tc: *TrackContext = &self.track_contexts[track]
	self.audio_state.playing_flags = self.audio_state.playing_flags & ~(0x80 >> track)
	BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
end

local function trackCallback(info: *BKCallbackInfo, userdata: pointer): BKEnum
	local tc: *TrackContext = (@*TrackContext)(userdata)
	local sc: *SoundChip = tc.soundchip
	local track_index: uinteger = tc.track_index
	
	-- is track playing?
	if (sc.audio_state.playing_flags & (0x80 >> track_index)) ~= 0 then
		local state: *TrackState = sc:getTrackState(track_index)

		if (state.playflags & PlayFlags.MUTE) ~= 0 then
			BKSetAttr(&tc.bk_track, BK_MASTER_VOLUME, 0)
		end

		if state.pattern_id == SOUNDCHIP_EMPTY_VALUE then
			sc:stopTrack(track_index)
			return 0
		end

		local playmode: uint8 = state.playflags & PlayFlags.PLAY_MASK

		if playmode >= PlayFlags.PLAY_SAMPLE then
			return 0
		end
		
		state.pattern_pos = math.min(63, state.pattern_pos)

		local pattern_row: *[0]uint8 = sc:getPatternRow(state.pattern_id, state.pattern_pos)

		local note: uint8 = pattern_row[0]
		local volume: uint8 = pattern_row[1]
		local instrument: uint8 = pattern_row[2]
		local pan: uint8 = pattern_row[3]

		if instrument ~= SOUNDCHIP_EMPTY_VALUE then
			BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
			sc:setInstrument(track_index, instrument)
		end

		if volume ~= SOUNDCHIP_EMPTY_VALUE then
			local percentage: float32 = (@float32)(volume) / 254.0
			local value: BKInt = (@BKInt)(percentage * (@float32)(BK_MAX_VOLUME))
			BKSetAttr(&tc.bk_track, BK_VOLUME, value) -- note volume
		end

		if note ~= SOUNDCHIP_EMPTY_VALUE then
			local bknote: BKInt
			if note == SOUNDCHIP_NOTE_MUTE then
				bknote = BK_NOTE_MUTE
			elseif note == SOUNDCHIP_NOTE_RELEASE then
				bknote = BK_NOTE_RELEASE
			else
				bknote = (@BKInt)(note) * BK_FINT20_UNIT
			end

			BKSetAttr(&tc.bk_track, BK_NOTE, bknote)
		end

		state.pattern_pos = state.pattern_pos + 1
		if state.pattern_pos > 63 then
			state.pattern_pos = 0

			if playmode == PlayFlags.PLAY_PATTERN then
				if (state.playflags & PlayFlags.LOOP) == 0 then
					sc:stopTrack(track_index)
				end
				return 0	
			end

			state.song_pos = state.song_pos + 1

			state.pattern_id = sc.song_data[(@uint8)(state.song_pos * 8 + track_index)]
			if state.pattern_id == SOUNDCHIP_EMPTY_VALUE then
				if (state.playflags & PlayFlags.LOOP) ~= 0 then
					-- TODO: search upward for first empty song row for track,
					--       play from the song row after that
					sc:stopTrack(track_index)
				else
					sc:stopTrack(track_index)
				end
			end
		end
	else
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end

	return 0
end

function SoundChip:stopAllTracks(): void
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		self:stopTrack(i)
	end

	self:stopPreviewNote()
end

function SoundChip:playTrack(track: uint8, song_row: uint8): void
	local state: *TrackState = self:getTrackState(track)
	local pattern_id: uint8 = self.song_data[((@uinteger)(song_row) * 8) + track]

	if pattern_id == SOUNDCHIP_EMPTY_VALUE then
		self:stopTrack(track)
	else
		self.audio_state.playing_flags = self.audio_state.playing_flags | (0x80 >> track)
		state.playflags = PlayFlags.PLAY_SONG
		state.song_pos = song_row
		state.pattern_id = pattern_id
		state.pattern_pos = 0
	end
end

function SoundChip:playSongRow(song_row: uint8): void
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		self:playTrack(i, song_row)
	end
end

function SoundChip:playPattern(track: uint8, pattern: uint8): void
	if pattern == SOUNDCHIP_EMPTY_VALUE then
		self:stopTrack(track)
	else
		self.audio_state.playing_flags = self.audio_state.playing_flags | (0x80 >> track)
		local state: *TrackState = self:getTrackState(track)

		state.playflags = PlayFlags.PLAY_PATTERN
		state.pattern_id = pattern
		state.pattern_pos = 0
	end
end

function SoundChip:playWavEx(track: uint8, start: uint32, send: uint32, note: uint8, volume: uint8, flags: uint8): void
	local tc: *TrackContext = &self.track_contexts[track]
	local state: *TrackState = self:getTrackState(track)
	
	local range: [2]BKInt = {start, send}
	BKSetPtr(&tc.bk_track, BK_SAMPLE_RANGE, &range, #BKInt * 2)
	BKSetAttr(&tc.bk_track, BK_SAMPLE_REPEAT, (flags & 0b10000000 ~= 0) and BK_REPEAT or BK_NO_REPEAT)
	BKInstrumentSetEnvelopeADSR(&tc.bk_instrument, 0, 0, BK_MAX_VOLUME, 4)
		
	BKSetAttr(&tc.bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME /// 4)
	if volume ~= SOUNDCHIP_EMPTY_VALUE then
		local percentage: float32 = (@float32)(volume) / 254.0
		local value: BKInt = (@BKInt)(percentage * (@float32)(BK_MAX_VOLUME))
		BKSetAttr(&tc.bk_track, BK_VOLUME, value)-- note volume
	end

	if note ~= SOUNDCHIP_EMPTY_VALUE then
		local bknote: BKInt
		if note == SOUNDCHIP_NOTE_MUTE then
			bknote = BK_NOTE_MUTE
		elseif note == SOUNDCHIP_NOTE_RELEASE then
			bknote = BK_NOTE_RELEASE
		else
			bknote = (@BKInt)(note) * BK_FINT20_UNIT
		end
		
		BKSetAttr(&tc.bk_track, BK_NOTE, bknote)
	else
		self:stopTrack(track)
		return
	end

	self.audio_state.playing_flags = self.audio_state.playing_flags | (0x80 >> track)
	state.playflags = PlayFlags.PLAY_SAMPLE
end

function SoundChip:playWav(track: uint8, id: uint32, volume: uint8): void
	-- get wavmap entry pointer
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[(84 + (512 * 12)) + (id * 12)])

	-- get start
	local start: uint32 = ((@uint32)(entry_ptr[0]) << 24) | ((@uint32)(entry_ptr[1]) << 16) | ((@uint32)(entry_ptr[2]) << 8) | (@uint32)(entry_ptr[3])

	-- get send
	local send: uint32 = ((@uint32)(entry_ptr[4]) << 24) | ((@uint32)(entry_ptr[5]) << 16) | ((@uint32)(entry_ptr[6]) << 8) | (@uint32)(entry_ptr[7])

	self:playWavEx(track, start, send, BK_C_4, volume, 0)
end

function SoundChip:muteTrack(track: uint8): void
	local state: *TrackState = self:getTrackState(track)
	state.playflags = state.playflags | PlayFlags.MUTE
end

function SoundChip:unmuteTrack(track: uint8): void
	local state: *TrackState = self:getTrackState(track)
	state.playflags = state.playflags & ~PlayFlags.MUTE
end

function SoundChip:updateAudio(): void
	if rl.isAudioStreamProcessed(self.audio_stream) then
		BKContextGenerate(&self.bk_context, &self.aobmem[0], SOUNDCHIP_FRAMES_PER_UPDATE)
		rl.updateAudioStream(self.audio_stream, &self.aobmem[0], SOUNDCHIP_FRAMES_PER_UPDATE)
	end
end

local function isLittleEndian(): boolean
	local x: uint32 <volatile> = 0x01234567
	local p: *uint8 = (@*uint8)(&x)
	return $p == 0x67
end

-- custom version of BKDataSetData that doesn't allocate separate storage
local function setBKDataPointer(data: *BKData, frame_data: pointer, data_size: BKUInt, num_channels: BKUInt, params: BKEnum): void
	local num_bits: BKUInt = 16
	local num_frames: BKInt
	local packet_size: BKInt
	local data_size_bits: BKInt = data_size * 8

	if num_bits <= 8 then
		packet_size = (num_bits * num_channels)
	else
		packet_size = (num_bits + 3) /// 4 * 4 * num_channels
	end

	num_frames = data_size_bits /// packet_size * num_channels

	data.frames = (@*BKFrame)(frame_data)
	data.numFrames = num_frames /// num_channels
	data.numChannels = num_channels
	data.numBits = num_bits
end

function SoundChip:setBankPointers(wavbank_index: uint8, seqbank_index: uint8): void
	local wp: pointer

	self.current_wavbank = wavbank_index
	self.current_seqbank = seqbank_index

	if self.current_wavbank == SoundchipBank.SYSTEM then
		wp = &self.wavmem[0]
	else
		local index: uinteger = self.current_wavbank - SoundchipBank.WAVBANK0
		wp = &self.wavbank_ptr[(7*1024*1024) * index]
	end

	setBKDataPointer(&self.bk_data, wp, 7*1024*1024, 2, self.bk_data_flags)
	BKSetAttr(&self.bk_data, BK_SAMPLE_PITCH, 0)

	if self.current_seqbank == SoundchipBank.SYSTEM then
		self.song_data = (@*[0]uint8)(&self.seqmem[0])
		self.pattern_data = (@*[0]uint8)(&self.seqmem[SOUNDCHIP_PATTERN_DATA_START])
		self.instrument_data = (@*[0]uint8)(&self.seqmem[SOUNDCHIP_INSTRUMENT_DATA_START])
		self.groove_data = (@*[0]uint8)(&self.seqmem[SOUNDCHIP_GROOVE_DATA_START])
	else
		local index: uint64 = self.current_seqbank - SoundchipBank.SEQBANK0
		index = index * SOUNDCHIP_SEQMEM_SIZE
		self.song_data = (@*[0]uint8)(&self.seqbank_ptr[index])
		self.pattern_data = (@*[0]uint8)(&self.seqbank_ptr[index + SOUNDCHIP_PATTERN_DATA_START])
		self.instrument_data = (@*[0]uint8)(&self.seqbank_ptr[index + SOUNDCHIP_INSTRUMENT_DATA_START])
		self.groove_data = (@*[0]uint8)(&self.seqbank_ptr[index + SOUNDCHIP_GROOVE_DATA_START])
	end
end

function SoundChip:loadWavBank(bank: uint8): void
	-- load wavbank
	local src: *[0]BKFrame = &self.wavbank_ptr[SOUNDCHIP_WAVMEM_SIZE * bank]
	memory.copy(&self.wavmem, src, SOUNDCHIP_WAVMEM_SIZE * 2)

	-- load wmpbank
	local wavmap_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[(84 + (512 * 12))])
	local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.wmpbank_ptr[(SOUNDCHIP_WAVMAP_SIZE * bank)])
	memory.copy(wavmap_ptr, bank_ptr, SOUNDCHIP_WAVMAP_SIZE)
end

function SoundChip:loadSeqBank(bank: uint8): void
	local src: *[0]uint8 = &self.seqbank_ptr[SOUNDCHIP_SEQMEM_SIZE * bank]
	memory.copy(&self.seqmem, src, SOUNDCHIP_SEQMEM_SIZE)
end

function SoundChip:loadAudioSample(filename: string, bank_index: uint32, start_index: uint32): (boolean, uint32)
	local wave: rl.wave = rl.loadWave(filename)

	if not rl.isWaveReady(wave) then
		return false, 0
	end

	start_index = start_index * 2

	--print(wave.channels, wave.sampleSize, wave.sampleRate, wave.frameCount)

	local frames: *[0]BKFrame = (@*[0]BKFrame)(wave.data)
	local frame_count: uint32

	if wave.channels == 1 then
		for i: uint64 = 0, < wave.frameCount do
			local frame: BKFrame = frames[i]
			self.wavbank_ptr[start_index + (i * 2)] = frame
			self.wavbank_ptr[start_index + (i * 2) + 1] = frame
		end
		frame_count = wave.frameCount
	elseif wave.channels == 2 then
		for i: uint64 = 0, < wave.frameCount * 2 do
			local frame: BKFrame = frames[i]
			self.wavbank_ptr[start_index + i] = frame
		end
		frame_count = wave.frameCount
	end

	rl.unloadWave(wave)

	return true, frame_count
end

function SoundChip:resetSoundchip(): void
	self.audio_state.playing_flags = 0

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]
		local state: *TrackState = self:getTrackState(i)
		state.playflags = 0
		state.bpm = 154
		state.volume = 127
		state.pan = 0
		state.song_id = 0
		state.song_pos = 0
		state.pattern_id = 0
		state.pattern_pos = 0
		state.groove_id = 0
		state.groove_pos = 0
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end

	self:stopPreviewNote()
end

function SoundChip:init(sysmem_ptr: *[0]uint8, wavbank_ptr: *[0]BKFrame, seqbank_ptr: *[0]uint8, wmpbank_ptr: *[0]uint8): void
	self.sysmem_ptr = sysmem_ptr
	self.wmpbank_ptr = wmpbank_ptr
	self.wavbank_ptr = wavbank_ptr
	self.seqbank_ptr = seqbank_ptr

	rl.initAudioDevice()

	rl.setAudioStreamBufferSizeDefault(SOUNDCHIP_FRAMES_PER_UPDATE)

	-- create audio stream (22050hz, 16 bit stereo)
	self.audio_stream = rl.loadAudioStream(SOUNDCHIP_SAMPLE_RATE, 16, 2)

	-- init BlipKit stuff
	BKContextInit(&self.bk_context, 2, SOUNDCHIP_SAMPLE_RATE)

	BKDataInit(&self.bk_data)
	self.bk_data_flags = BK_16_BIT_SIGNED
	if isLittleEndian() then
		self.bk_data_flags = self.bk_data_flags | BK_LITTLE_ENDIAN
	else
		self.bk_data_flags = self.bk_data_flags | BK_BIG_ENDIAN
	end

	self:setBankPointers(
		SoundchipBank.SYSTEM,
		SoundchipBank.SYSTEM
	)
	self.audio_state = (@*AudioState)(&self.sysmem_ptr[0])
	self.track_state = (@*[0]uint8)(&self.sysmem_ptr[1])

	local success: boolean
	local i0_start: uint32 = 0
	local i0_count: uint32 = 0
	--local i1_start: uint32 = 0
	--local i1_count: uint32 = 0
	--local i2_start: uint32 = 0
	--local i2_count: uint32 = 0
	--local i3_start: uint32 = 0
	--local i3_count: uint32 = 0

	--success, i0_count = self:loadAudioSample("test_data/175_thebasix.wav", 0, i0_start)
	--i1_start = i0_start + i0_count
	--success, i1_count = self:loadAudioSample("test_data/bd.wav", 0, i1_start)
	--i2_start = i1_start + i1_count
	--success, i2_count = self:loadAudioSample("test_data/recog.wav", 0, i2_start)
	--i3_start = i2_start + i2_count
	--success, i3_count = self:loadAudioSample("test_data/pluck.wav", 0, i3_start)
	success, i0_count = self:loadAudioSample("test_data/175_thebasix.wav", 0, 0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]

		local callback: BKCallback = {
			func = trackCallback,
			userInfo = tc
		}

		--[[
			openmpt tempo calculations:
			https://wiki.openmpt.org/Manual:_Song_Properties#Modern_Tempo_Mode

			bpm
			rpb (rows per beat)
			tpr (ticks per row)

			ticks per second = (bpm * rpb * tpr) / 60 seconds

			(125 bpm * 4 rpb * 6 tpr) / 60 secs = 50 ticks per second!!! (same as LSDJ)

			set clock to ticks per second, set divider to ticks per row
		]]

		tc.soundchip = self
		tc.track_index = i

		BKClockInit(&tc.bk_clock, BKTimeFromSeconds(&self.bk_context, 1.0 / ((175.0 * 4.0 * 6.0) / 60.0)), nilptr)

		BKTrackInit(&tc.bk_track, BK_SQUARE)
		BKSetAttr(&tc.bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME /// 4) -- mix volume
		BKSetAttr(&tc.bk_track, BK_VOLUME, BK_MAX_VOLUME /// 4) -- note volume
		BKTrackAttach(&tc.bk_track, &self.bk_context)

		local range: [2]BKInt = {0, 88200}
		BKSetPtr(&tc.bk_track, BK_SAMPLE, &self.bk_data, 0)
		BKSetPtr(&tc.bk_track, BK_SAMPLE_RANGE, &range, #BKInt * 2)
		BKSetAttr(&tc.bk_track, BK_SAMPLE_REPEAT, 1)

		BKInstrumentInit(&tc.bk_instrument)
		BKInstrumentSetEnvelopeADSR(&tc.bk_instrument, 0, 3, BK_MAX_VOLUME, 3)
		BKSetPtr(&tc.bk_track, BK_INSTRUMENT, &tc.bk_instrument, 0)
		
		BKDividerInit(&tc.bk_divider, 6, &callback)
		BKDividerAttachToClock(&tc.bk_divider, &tc.bk_clock)
		BKClockAttach(&tc.bk_clock, &self.bk_context, nilptr)
	end

	BKTrackInit(&self.preview_bk_track, BK_SQUARE)
	BKSetAttr(&self.preview_bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME // 8) -- mix volume
	BKSetAttr(&self.preview_bk_track, BK_VOLUME, BK_MAX_VOLUME /// 4) -- note volume
	BKTrackAttach(&self.preview_bk_track, &self.bk_context)

	self:resetSoundchip()

	-- reset seqbanks
	for i = SoundchipBank.SEQBANK0, <= SoundchipBank.SEQBANK7 do
		local index: uint64 = i - SoundchipBank.SEQBANK0
		index = index * SOUNDCHIP_SEQMEM_SIZE
		local song_data: *[0]uint8 = (@*[0]uint8)(&self.seqbank_ptr[index])
		local pattern_data: *[0]uint8 = (@*[0]uint8)(&self.seqbank_ptr[index + SOUNDCHIP_PATTERN_DATA_START])
		local groove_data: *[0]uint8 = (@*[0]uint8)(&self.seqbank_ptr[index + SOUNDCHIP_GROOVE_DATA_START])

		-- reset song
		memory.set(song_data, SOUNDCHIP_EMPTY_VALUE, SOUNDCHIP_SONG_SIZE)

		-- reset patterns, each pattern row set to all EMPTY
		memory.set(pattern_data, SOUNDCHIP_EMPTY_VALUE, SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)

		-- reset grooves
		memory.set(groove_data, 6, SOUNDCHIP_GROOVE_COUNT * SOUNDCHIP_GROOVE_SIZE)
	end

	local instr0: *[0]uint8 = self:getInstrument(0)
	--local instr1: *[0]uint8 = self:getInstrument(1)
	--local instr2: *[0]uint8 = self:getInstrument(2)
	--local instr3: *[0]uint8 = self:getInstrument(3)

	instr0[0] = 0
	instr0[1] = (i0_start >> 16) & 0xFF
	instr0[2] = (i0_start >> 8) & 0xFF
	instr0[3] = (i0_start) & 0xFF
	instr0[4] = ((i0_start + i0_count) >> 16) & 0xFF
	instr0[5] = ((i0_start + i0_count) >> 8) & 0xFF
	instr0[6] = ((i0_start + i0_count)) & 0xFF
	instr0[7] = 0
	instr0[8] = 0
	instr0[9] = 255
	instr0[10] = 4

	--instr1[0] = 0
	--instr1[1] = (i1_start >> 16) & 0xFF
	--instr1[2] = (i1_start >> 8) & 0xFF
	--instr1[3] = (i1_start) & 0xFF
	--instr1[4] = ((i1_start + i1_count) >> 16) & 0xFF
	--instr1[5] = ((i1_start + i1_count) >> 8) & 0xFF
	--instr1[6] = ((i1_start + i1_count)) & 0xFF
	--instr1[7] = 0
	--instr1[8] = 0
	--instr1[9] = 255
	--instr1[10] = 4

	--instr2[0] = 0
	--instr2[1] = (i2_start >> 16) & 0xFF
	--instr2[2] = (i2_start >> 8) & 0xFF
	--instr2[3] = (i2_start) & 0xFF
	--instr2[4] = ((i2_start + i2_count) >> 16) & 0xFF
	--instr2[5] = ((i2_start + i2_count) >> 8) & 0xFF
	--instr2[6] = ((i2_start + i2_count)) & 0xFF
	--instr2[7] = 0
	--instr2[8] = 0
	--instr2[9] = 255
	--instr2[10] = 4

	--instr3[0] = 0
	--instr3[1] = (i3_start >> 16) & 0xFF
	--instr3[2] = (i3_start >> 8) & 0xFF
	--instr3[3] = (i3_start) & 0xFF
	--instr3[4] = ((i3_start + i3_count) >> 16) & 0xFF
	--instr3[5] = ((i3_start + i3_count) >> 8) & 0xFF
	--instr3[6] = ((i3_start + i3_count)) & 0xFF
	--instr3[7] = 0
	--instr3[8] = 0
	--instr3[9] = 255
	--instr3[10] = 4

	rl.playAudioStream(self.audio_stream)
end

function SoundChip:cleanup(): void
	rl.closeAudioDevice()
	rl.unloadAudioStream(self.audio_stream)

	BKDispose(&self.bk_data)
	
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]
		
		BKDispose(&tc.bk_track)
		BKDispose(&tc.bk_divider)
		BKDispose(&tc.bk_clock)
	end
	
	BKDispose(&self.preview_bk_track)
	BKDispose(&self.bk_context)
end
