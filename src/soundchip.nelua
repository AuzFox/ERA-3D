require("blipkit")
require("raylib")

global SOUNDCHIP_TRACK_COUNT <comptime> = 8
global SOUNDCHIP_SAMPLE_RATE <comptime> = 22050 -- 22050hz sample rate
global SOUNDCHIP_FRAMES_PER_UPDATE <comptime> = 2048
global SOUNDCHIP_EMPTY_VALUE <comptime> = 0xFF
global SOUNDCHIP_NOTE_MUTE <comptime> = 0xFE
global SOUNDCHIP_NOTE_RELEASE <comptime> = 0xFD

global SOUNDCHIP_SONG_SIZE <comptime> = 256 * 8
global SOUNDCHIP_CHAIN_SIZE <comptime> = 16 * 2
global SOUNDCHIP_CHAIN_COUNT <comptime> = 256
global SOUNDCHIP_PHRASE_SIZE <comptime> = 16 * 8
global SOUNDCHIP_PHRASE_COUNT <comptime> = 256
global SOUNDCHIP_INSTRUMENT_SIZE <comptime> = 8
global SOUNDCHIP_INSTRUMENT_COUNT <comptime> = 256
global SOUNDCHIP_GROOVE_SIZE <comptime> = 16
global SOUNDCHIP_GROOVE_COUNT <comptime> = 16
global SOUNDCHIP_AUDIO_STATE_SIZE <comptime> = 2
global SOUNDCHIP_TRACK_STATE_SIZE <comptime> = 16

global SOUNDCHIP_CHAIN_DATA_START <comptime> = SOUNDCHIP_SONG_SIZE
global SOUNDCHIP_PHRASE_DATA_START <comptime> = SOUNDCHIP_CHAIN_DATA_START + (SOUNDCHIP_CHAIN_COUNT * SOUNDCHIP_CHAIN_SIZE)
global SOUNDCHIP_INSTRUMENT_DATA_START <comptime> = SOUNDCHIP_PHRASE_DATA_START + (SOUNDCHIP_PHRASE_COUNT * SOUNDCHIP_PHRASE_SIZE)
global SOUNDCHIP_GROOVE_DATA_START <comptime> = SOUNDCHIP_INSTRUMENT_DATA_START + (SOUNDCHIP_INSTRUMENT_COUNT * SOUNDCHIP_INSTRUMENT_SIZE)
global SOUNDCHIP_AUDIO_STATE_START <comptime> = SOUNDCHIP_GROOVE_DATA_START + (SOUNDCHIP_GROOVE_COUNT * SOUNDCHIP_GROOVE_SIZE)
global SOUNDCHIP_TRACK_STATE_START <comptime> = SOUNDCHIP_AUDIO_STATE_START + SOUNDCHIP_AUDIO_STATE_SIZE
global SOUNDCHIP_WMEM_SIZE <comptime> = ((15*1024*1024)///2) -- 15 MiB of 16 bit audio samples
global SOUNDCHIP_SMEM_SIZE <comptime> = 64*1024 -- 64 KiB

global SoundChip <forwarddecl> = @record {}

global AudioState = @record {
	bpm: uint8,
	playing_flags: uint8
}

global TrackContext = @record {
	bk_track: BKTrack,
	bk_clock: BKClock,
	bk_divider: BKDivider,
	soundchip: *SoundChip,
	track_index: uint8
}

-- track state object, stored in smem
global TrackState = @record {
	song_id: uint8,
	song_pos: uint8,
	chain_id: uint8,
	chain_pos: uint8,
	phrase_id: uint8,
	phrase_pos: uint8,
	groove_id: uint8,
	groove_pos: uint8
}

SoundChip = @record {
	smem: [SOUNDCHIP_SMEM_SIZE]uint8, -- song, chain, phrase, instrument, and state data
	wmem: [SOUNDCHIP_WMEM_SIZE]BKFrame, -- sample wave data
	audio_buffer: [SOUNDCHIP_FRAMES_PER_UPDATE * 2]BKFrame, -- working audio buffer
	track_contexts: [SOUNDCHIP_TRACK_COUNT]TrackContext,
	bk_context: BKContext,
	audio_stream: rl.audioStream,

	-- smem pointers
	song_data: *[0]uint8,
	chain_data: *[0]uint8,
	phrase_data: *[0]uint8,
	instrument_data: *[0]uint8,
	groove_data: *[0]uint8,
	audio_state: *AudioState,
	track_state: *[0]uint8
}

function SoundChip:get_track_state(track_index: uinteger): *TrackState
    return (@*TrackState)(&self.smem[SOUNDCHIP_TRACK_STATE_START + (track_index * #TrackState)])
end

function SoundChip:get_chain(chain_id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.smem[SOUNDCHIP_CHAIN_DATA_START + (chain_id * SOUNDCHIP_CHAIN_SIZE)])
end

function SoundChip:get_phrase(phrase_id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.smem[SOUNDCHIP_PHRASE_DATA_START + (phrase_id * SOUNDCHIP_PHRASE_SIZE)])
end

function SoundChip:get_phrase_row(phrase_id: uinteger, row_index: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.smem[SOUNDCHIP_PHRASE_DATA_START + (phrase_id * SOUNDCHIP_PHRASE_SIZE) + (row_index * 8)])
end

function SoundChip:get_instrument(instrument_id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.smem[SOUNDCHIP_INSTRUMENT_DATA_START + (instrument_id * SOUNDCHIP_INSTRUMENT_SIZE)])
end

function SoundChip:set_bpm(): void
end

local function track_callback(info: *BKCallbackInfo, userdata: pointer): BKEnum
	local tc: *TrackContext = (@*TrackContext)(userdata)
	local sc: *SoundChip = tc.soundchip
	local track_index: uinteger = tc.track_index
	
	-- is track playing?
	if (sc.audio_state.playing_flags & (0x80 >> track_index)) ~= 0 then
		-- get track state pointer from smem
		local state: *TrackState = sc:get_track_state(track_index)

		if state.phrase_id == SOUNDCHIP_EMPTY_VALUE then
			sc.audio_state.playing_flags = sc.audio_state.playing_flags & ~(0x80 >> track_index)
			BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
		end
		
		state.phrase_pos = math.min(15, state.phrase_pos)

		-- get phrase row pointer
		local phrase_row: *[0]uint8 = sc:get_phrase_row(state.phrase_id, state.phrase_pos)

		local note: uint8 = phrase_row[0]

		if note ~= SOUNDCHIP_EMPTY_VALUE then
			local bknote: BKInt
			if note == SOUNDCHIP_NOTE_MUTE then
				bknote = BK_NOTE_MUTE
			elseif note == SOUNDCHIP_NOTE_RELEASE then
				bknote = BK_NOTE_RELEASE
			else
				bknote = (@BKInt)(note) * BK_FINT20_UNIT
			end

			BKSetAttr(&tc.bk_track, BK_NOTE, bknote)
		end

		state.phrase_pos = state.phrase_pos + 1
		if state.phrase_pos > 15 then
			state.phrase_pos = 0
		end
	else
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end

	return 0
end

function SoundChip:update_audio(): void
	if rl.isAudioStreamProcessed(self.audio_stream) then
		BKContextGenerate(&self.bk_context, &self.audio_buffer[0], SOUNDCHIP_FRAMES_PER_UPDATE)
		rl.updateAudioStream(self.audio_stream, &self.audio_buffer[0], SOUNDCHIP_FRAMES_PER_UPDATE)
	end
end

function SoundChip:reset(): void
	self.audio_state.bpm = 128
	self.audio_state.playing_flags = 0b11000000 -- TODO: set to 0

    -- reset song
	memory.set(self.song_data, SOUNDCHIP_EMPTY_VALUE, SOUNDCHIP_SONG_SIZE)
	
    -- reset chains, each chain row set to [EMPTY, 0]
    for i = 0, < SOUNDCHIP_CHAIN_COUNT do
        local chain: *[0]uint8 = self:get_chain(i)
        for j = 0, < 16 do
            chain[j * 2] = SOUNDCHIP_EMPTY_VALUE
            chain[j * 2 + 1] = 0
        end
    end

    -- reset phrases, each phrase row set to [EMPTY, 0, 0, 0, EMPTY, 0, EMPTY 0]
    for i = 0, < SOUNDCHIP_PHRASE_COUNT do
        local phrase: *[0]uint8 = self:get_phrase(i)
        for j = 0, < 16 do
            phrase[j * 8] = SOUNDCHIP_EMPTY_VALUE
            phrase[j * 8 + 1] = 0
            phrase[j * 8 + 2] = 0
            phrase[j * 8 + 3] = 0
            phrase[j * 8 + 4] = SOUNDCHIP_EMPTY_VALUE
            phrase[j * 8 + 5] = 0
            phrase[j * 8 + 6] = SOUNDCHIP_EMPTY_VALUE
            phrase[j * 8 + 7] = 0
        end
    end

	-- reset instruments

	self:get_phrase_row(0, 0)[0] = (@uint8)(BK_C_2)
	self:get_phrase_row(0, 8)[0] = (@uint8)(BK_E_2)

	self:get_phrase_row(1, 0)[0] = (@uint8)(BK_C_4)
	self:get_phrase_row(1, 1)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 2)[0] = (@uint8)(BK_D_4)
	self:get_phrase_row(1, 3)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 4)[0] = (@uint8)(BK_E_4)
	self:get_phrase_row(1, 5)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 6)[0] = (@uint8)(BK_G_4)
	self:get_phrase_row(1, 7)[0] = (@uint8)(BK_NOTE_MUTE)
    self:get_phrase_row(1, 8)[0] = (@uint8)(BK_C_5)
	self:get_phrase_row(1, 9)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 10)[0] = (@uint8)(BK_G_4)
	self:get_phrase_row(1, 11)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 12)[0] = (@uint8)(BK_E_4)
	self:get_phrase_row(1, 13)[0] = (@uint8)(BK_NOTE_MUTE)
	self:get_phrase_row(1, 14)[0] = (@uint8)(BK_D_4)
	self:get_phrase_row(1, 15)[0] = (@uint8)(BK_NOTE_MUTE)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]
		local state: *TrackState = (@*TrackState)(&self.smem[SOUNDCHIP_TRACK_STATE_START + (i * #TrackState)])
		state.song_id = 0
		state.song_pos = 0
		state.chain_id = 0
		state.chain_pos = 0
		state.phrase_id = i
		state.phrase_pos = 0
		state.groove_id = 0
		state.groove_pos = 0
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end
end

function SoundChip:init(): void
	rl.initAudioDevice()

	rl.setAudioStreamBufferSizeDefault(SOUNDCHIP_FRAMES_PER_UPDATE)

	-- create audio stream (22050hz, 16 bit stereo)
	self.audio_stream = rl.loadAudioStream(SOUNDCHIP_SAMPLE_RATE, 16, 2)

	-- init BlipKit stuff
	BKContextInit(&self.bk_context, 2, SOUNDCHIP_SAMPLE_RATE)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]

		local callback: BKCallback = {
			func = track_callback,
			userInfo = tc
		}

		--[[
			openmpt tempo calculations:
			https://wiki.openmpt.org/Manual:_Song_Properties#Modern_Tempo_Mode

			bpm
			rpb (rows per beat)
			tpr (ticks per row)

			ticks per second = (bpm * rpb * tpr) / 60 seconds

			(125 bpm * 4 rpb * 6 tpr) / 60 secs = 50 ticks per second!!! (same as LSDJ)

			set clock to ticks per second, set divider to ticks per row
		]]

		tc.soundchip = self
		tc.track_index = i

		BKClockInit(&tc.bk_clock, BKTimeFromSeconds(&self.bk_context, 1.0 / ((128.0 * 4.0 * 6.0) / 60.0)), nilptr)

		if i == 0 then
            BKTrackInit(&tc.bk_track, BK_SAWTOOTH)
        else
            BKTrackInit(&tc.bk_track, BK_SQUARE)
        end
		BKSetAttr(&tc.bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME // 8)
		BKSetAttr(&tc.bk_track, BK_VOLUME, BK_MAX_VOLUME /// 2)
		BKTrackAttach(&tc.bk_track, &self.bk_context)
		
		BKDividerInit(&tc.bk_divider, 6, &callback)
		
		BKDividerAttachToClock(&tc.bk_divider, &tc.bk_clock)

		BKClockAttach(&tc.bk_clock, &self.bk_context, nilptr)
	end

	self.song_data = (@*[0]uint8)(&self.smem[0])
	self.chain_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_CHAIN_DATA_START])
	self.phrase_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_PHRASE_DATA_START])
	self.instrument_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_INSTRUMENT_DATA_START])
	self.groove_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_GROOVE_DATA_START])
	self.audio_state = (@*AudioState)(&self.smem[SOUNDCHIP_AUDIO_STATE_START])
	self.track_state = (@*[0]uint8)(&self.smem[SOUNDCHIP_TRACK_STATE_START])

	self:reset()

	rl.playAudioStream(self.audio_stream)
end

function SoundChip:cleanup(): void
	rl.unloadAudioStream(self.audio_stream)
	rl.closeAudioDevice()

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]

		BKDispose(&tc.bk_track)
		BKDispose(&tc.bk_divider)
		BKDispose(&tc.bk_clock)
	end

	BKDispose(&self.bk_context)
end
