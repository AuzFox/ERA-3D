require("blipkit")
require("raylib")

-- TODO: implement playback from SBANK

global SoundchipBank = @enum {
	SYSTEM = 0,
	WBANK0 = 1,
	WBANK1,
	SBANK0 = 1,
	SBANK1,
	SBANK2,
	SBANK3,
	SBANK4,
	SBANK5,
	SBANK6,
	SBANK7
}

global SOUNDCHIP_TRACK_COUNT <comptime> = 8
global SOUNDCHIP_SAMPLE_RATE <comptime> = 22050 -- 22050hz sample rate
global SOUNDCHIP_FRAMES_PER_UPDATE <comptime> = 2048
global SOUNDCHIP_EMPTY_VALUE <comptime> = 0xFF
global SOUNDCHIP_NOTE_MUTE <comptime> = 0xFE
global SOUNDCHIP_NOTE_RELEASE <comptime> = 0xFD
global SOUNDCHIP_MIN_OCTAVE <comptime> = 0
global SOUNDCHIP_MAX_OCTAVE <comptime> = 7
global SOUNDCHIP_OCTAVE_SIZE <comptime> = 12

global SOUNDCHIP_SONG_SIZE <comptime> = 256 * 8
global SOUNDCHIP_PATTERN_SIZE <comptime> = 64 * 5
global SOUNDCHIP_PATTERN_COUNT <comptime> = 256
global SOUNDCHIP_INSTRUMENT_SIZE <comptime> = 11
global SOUNDCHIP_INSTRUMENT_COUNT <comptime> = 256
global SOUNDCHIP_GROOVE_SIZE <comptime> = 16
global SOUNDCHIP_GROOVE_COUNT <comptime> = 16

global SOUNDCHIP_PATTERN_DATA_START <comptime> = SOUNDCHIP_SONG_SIZE
global SOUNDCHIP_INSTRUMENT_DATA_START <comptime> = SOUNDCHIP_PATTERN_DATA_START + (SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)
global SOUNDCHIP_GROOVE_DATA_START <comptime> = SOUNDCHIP_INSTRUMENT_DATA_START + (SOUNDCHIP_INSTRUMENT_COUNT * SOUNDCHIP_INSTRUMENT_SIZE)
global SOUNDCHIP_WMEM_SIZE <comptime> = ((7*1024*1024)///2) -- 7 MiB of 16 bit audio samples
global SOUNDCHIP_SMEM_SIZE <comptime> = 256*1024 -- 256 KiB
global SOUNDCHIP_AMEM_SIZE <comptime> = SOUNDCHIP_FRAMES_PER_UPDATE*2 -- 8 KiB

global SoundChip <forwarddecl> = @record {}

global AudioState = @record {
	playing_flags: uint8
}

global TrackContext = @record {
	bk_track: BKTrack,
	bk_clock: BKClock,
	bk_divider: BKDivider,
	bk_instrument: BKInstrument,
	soundchip: *SoundChip,
	track_index: uint8
}

-- track state object, stored in rmem
global TrackState = @record {
	bpm: uint8,
	volume: uint8,
	pan: uint8,
	song_id: uint8,
	song_pos: uint8,
	pattern_id: uint8,
	pattern_pos: uint8,
	groove_id: uint8,
	groove_pos: uint8
}

SoundChip = @record {
	smem: [SOUNDCHIP_SMEM_SIZE]uint8, -- song, chain, phrase, instrument, and state data
	wmem: [SOUNDCHIP_WMEM_SIZE]BKFrame, -- sample wave data
	amem: [SOUNDCHIP_AMEM_SIZE]BKFrame, -- working audio buffer
	track_contexts: [SOUNDCHIP_TRACK_COUNT]TrackContext,
	preview_bk_track: BKTrack,
	bk_context: BKContext,
	bk_data: BKData,
	audio_stream: rl.audioStream,
	current_wbank: uint8, -- which region of memory to use for sample data
	current_sbank: uint8, -- which region of memory to use for sequencer data
	bk_data_flags: BKEnum, -- flags describing sample data format

	-- memory pointers
	rmem_ptr: *[0]uint8,
	wbank_ptr: *[0]BKFrame,
	sbank_ptr: *[0]uint8,
	song_data: *[0]uint8,
	pattern_data: *[0]uint8,
	instrument_data: *[0]uint8,
	groove_data: *[0]uint8,
	audio_state: *AudioState,
	track_state: *[0]uint8
}

function SoundChip:getTrackState(id: uinteger): *TrackState
    return (@*TrackState)(&self.track_state[id * #TrackState])
end

function SoundChip:getPattern(id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.pattern_data[id * SOUNDCHIP_PATTERN_SIZE])
end

function SoundChip:getPatternRow(id: uinteger, row: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.pattern_data[(id * SOUNDCHIP_PATTERN_SIZE) + (row * 8)])
end

function SoundChip:getInstrument(id: uinteger): *[0]uint8
    return (@*[0]uint8)(&self.instrument_data[id * SOUNDCHIP_INSTRUMENT_SIZE])
end

function SoundChip:setBPM(): void
end

function SoundChip:setInstrument(track: uint8, instrument: uint8): void
	local idata: *[0]uint8 = self:getInstrument(instrument)
	local flags: uint8 = idata[0]
	local sample_start: uint32 = ((@uint32)(idata[1]) << 16) | ((@uint32)(idata[2]) << 8) | (@uint32)(idata[3])
	local sample_end: uint32 = ((@uint32)(idata[4]) << 16) | ((@uint32)(idata[5]) << 8) | (@uint32)(idata[6])
	local attack: uint8 = idata[7]
	local decay: uint8 = idata[8]
	local sustain: uint8 = idata[9]
	local release: uint8 = idata[10]

	local tc: *TrackContext = &self.track_contexts[track]
	local range: [2]BKInt = {sample_start, sample_end}

	BKSetPtr(&tc.bk_track, BK_SAMPLE_RANGE, &range, #BKInt * 2)
	BKSetAttr(&tc.bk_track, BK_SAMPLE_REPEAT, (flags & 0b10000000) and 1 or 0)
	local percentage: float32 = (@float32)(sustain) / 255.0
	local value: BKInt = (@BKInt)(percentage * (@float32)(BK_MAX_VOLUME))
	BKInstrumentSetEnvelopeADSR(&tc.bk_instrument, attack, decay, value, release)
end

function SoundChip:playPreviewNote(note: uint8): void
	if note ~= SOUNDCHIP_EMPTY_VALUE then
		local bknote: BKInt
		if note == SOUNDCHIP_NOTE_MUTE then
			bknote = BK_NOTE_MUTE
		elseif note == SOUNDCHIP_NOTE_RELEASE then
			bknote = BK_NOTE_RELEASE
		else
			bknote = (@BKInt)(note) * BK_FINT20_UNIT
		end

		BKSetAttr(&self.preview_bk_track, BK_NOTE, bknote)
	end
end

function SoundChip:stopPreviewNote(note: uint8): void
	BKSetAttr(&self.preview_bk_track, BK_NOTE, BK_NOTE_MUTE)
end

function SoundChip:stopTrack(track: uint8): void
	local tc: *TrackContext = &self.track_contexts[track]
	self.audio_state.playing_flags = self.audio_state.playing_flags & ~(0x80 >> track)
	BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
end

local function trackCallback(info: *BKCallbackInfo, userdata: pointer): BKEnum
	local tc: *TrackContext = (@*TrackContext)(userdata)
	local sc: *SoundChip = tc.soundchip
	local track_index: uinteger = tc.track_index
	
	-- is track playing?
	if (sc.audio_state.playing_flags & (0x80 >> track_index)) ~= 0 then
		-- get track state pointer from smem
		local state: *TrackState = sc:getTrackState(track_index)

		if state.pattern_id == SOUNDCHIP_EMPTY_VALUE then
			sc:stopTrack(track_index)
			return 0
		end
		
		state.pattern_pos = math.min(63, state.pattern_pos)

		-- get pattern row pointer
		local pattern_row: *[0]uint8 = sc:getPatternRow(state.pattern_id, state.pattern_pos)

		local note: uint8 = pattern_row[0]
		local volume: uint8 = pattern_row[1]
		local instrument: uint8 = pattern_row[2]
		local pan: uint8 = pattern_row[3]

		if instrument ~= SOUNDCHIP_EMPTY_VALUE then
			BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
			sc:setInstrument(track_index, instrument)
		end

		if volume ~= SOUNDCHIP_EMPTY_VALUE then
			local percentage: float32 = (@float32)(volume) / 254.0
			local value: BKInt = (@BKInt)(percentage * (@float32)(BK_MAX_VOLUME))
			BKSetAttr(&tc.bk_track, BK_VOLUME, value) -- note volume
		end

		if note ~= SOUNDCHIP_EMPTY_VALUE then
			local bknote: BKInt
			if note == SOUNDCHIP_NOTE_MUTE then
				bknote = BK_NOTE_MUTE
			elseif note == SOUNDCHIP_NOTE_RELEASE then
				bknote = BK_NOTE_RELEASE
			else
				bknote = (@BKInt)(note) * BK_FINT20_UNIT
			end

			BKSetAttr(&tc.bk_track, BK_NOTE, bknote)
		end

		state.pattern_pos = state.pattern_pos + 1
		if state.pattern_pos > 63 then
			state.pattern_pos = 0

			state.song_pos = state.song_pos + 1

			state.pattern_id = sc.song_data[(@uint8)(state.song_pos * 8 + track_index)]
			if state.pattern_id == SOUNDCHIP_EMPTY_VALUE then
				sc:stopTrack(track_index)
				return 0
			end
		end
	else
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end

	return 0
end

function SoundChip:stopAllTracks(): void
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		self:stopTrack(i)
	end

	self:stopPreviewNote()
end

function SoundChip:playPattern(track: uint8, pattern: uint8): void
	if pattern == SOUNDCHIP_EMPTY_VALUE then
		self:stopTrack(track)
	else
		self.audio_state.playing_flags = self.audio_state.playing_flags | (0x80 >> track)
		local state: *TrackState = self:getTrackState(track)
		state.pattern_id = pattern
		state.pattern_pos = 0
	end
end

function SoundChip:playSongRow(song_row: uint8): void
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local state: *TrackState = self:getTrackState(i)
		local pattern_id: uint8 = self.song_data[((@uinteger)(song_row) * 8) + i]

		state.song_pos = song_row
		state.pattern_id = pattern_id
		state.pattern_pos = 0
		self:playPattern(i, pattern_id)
	end
end

function SoundChip:updateAudio(): void
	if rl.isAudioStreamProcessed(self.audio_stream) then
		BKContextGenerate(&self.bk_context, &self.amem[0], SOUNDCHIP_FRAMES_PER_UPDATE)
		rl.updateAudioStream(self.audio_stream, &self.amem[0], SOUNDCHIP_FRAMES_PER_UPDATE)
	end
end

local function isLittleEndian(): boolean
	local x: uint32 <volatile> = 0x01234567
	local p: *uint8 = (@*uint8)(&x)
	return $p == 0x67
end

-- custom version of BKDataSetData that doesn't allocate separate storage
local function setBKDataPointer(data: *BKData, frame_data: pointer, data_size: BKUInt, num_channels: BKUInt, params: BKEnum): void
	local num_bits: BKUInt = 16
	local num_frames: BKInt
	local packet_size: BKInt
	local data_size_bits: BKInt = data_size * 8

	if num_bits <= 8 then
		packet_size = (num_bits * num_channels)
	else
		packet_size = (num_bits + 3) /// 4 * 4 * num_channels;
	end

	num_frames = data_size_bits /// packet_size * num_channels;

	data.frames = (@*BKFrame)(frame_data)
	data.numFrames = num_frames /// num_channels
	data.numChannels = num_channels
	data.numBits = num_bits
end

function SoundChip:updateBankPointers(): void
	local wp: pointer
	if self.current_wbank == SoundchipBank.SYSTEM then
		wp = &self.wmem
	else
		local index: uinteger = self.current_wbank - SoundchipBank.WBANK0
		wp = &self.wbank_ptr[(7*1024*1024) * index]
	end

	setBKDataPointer(&self.bk_data, wp, 7*1024*1024, 2, self.bk_data_flags)
	BKSetAttr(&self.bk_data, BK_SAMPLE_PITCH, 0)

	if self.current_sbank == SoundchipBank.SYSTEM then
		self.song_data = (@*[0]uint8)(&self.smem[0])
		self.pattern_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_PATTERN_DATA_START])
		self.instrument_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_INSTRUMENT_DATA_START])
		self.groove_data = (@*[0]uint8)(&self.smem[SOUNDCHIP_GROOVE_DATA_START])
	else
		local index: uint64 = self.current_sbank - SoundchipBank.SBANK0
		index = index * SOUNDCHIP_SMEM_SIZE
		self.song_data = (@*[0]uint8)(&self.sbank_ptr[index])
		self.pattern_data = (@*[0]uint8)(&self.sbank_ptr[index + SOUNDCHIP_PATTERN_DATA_START])
		self.instrument_data = (@*[0]uint8)(&self.sbank_ptr[index + SOUNDCHIP_INSTRUMENT_DATA_START])
		self.groove_data = (@*[0]uint8)(&self.sbank_ptr[index + SOUNDCHIP_GROOVE_DATA_START])
	end
end

function SoundChip:resetSoundchip(): void
	self.audio_state.playing_flags = 0

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]
		local state: *TrackState = self:getTrackState(i)
		state.bpm = 154
		state.volume = 127
		state.pan = 0
		state.song_id = 0
		state.song_pos = 0
		state.pattern_id = 0
		state.pattern_pos = 0
		state.groove_id = 0
		state.groove_pos = 0
		BKSetAttr(&tc.bk_track, BK_NOTE, BK_NOTE_MUTE)
	end

	self:stopPreviewNote()
end

function SoundChip:init(rmem_ptr: *[0]uint8, wbank_ptr: *[0]BKFrame, sbank_ptr: *[0]uint8): void
	self.rmem_ptr = rmem_ptr
	self.wbank_ptr = wbank_ptr
	self.sbank_ptr = sbank_ptr

	rl.initAudioDevice()

	rl.setAudioStreamBufferSizeDefault(SOUNDCHIP_FRAMES_PER_UPDATE)

	-- create audio stream (22050hz, 16 bit stereo)
	self.audio_stream = rl.loadAudioStream(SOUNDCHIP_SAMPLE_RATE, 16, 2)

	-- init BlipKit stuff
	BKContextInit(&self.bk_context, 2, SOUNDCHIP_SAMPLE_RATE)

	BKDataInit(&self.bk_data)
	self.bk_data_flags = BK_16_BIT_SIGNED
	if isLittleEndian() then
		self.bk_data_flags = self.bk_data_flags | BK_LITTLE_ENDIAN
	else
		self.bk_data_flags = self.bk_data_flags | BK_BIG_ENDIAN
	end
	self.current_wbank = SoundchipBank.WBANK0
	self.current_sbank = SoundchipBank.WBANK1
	self:updateBankPointers()
	self.audio_state = (@*AudioState)(&self.rmem_ptr[0])
	self.track_state = (@*[0]uint8)(&self.rmem_ptr[1])

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]

		local callback: BKCallback = {
			func = trackCallback,
			userInfo = tc
		}

		--[[
			openmpt tempo calculations:
			https://wiki.openmpt.org/Manual:_Song_Properties#Modern_Tempo_Mode

			bpm
			rpb (rows per beat)
			tpr (ticks per row)

			ticks per second = (bpm * rpb * tpr) / 60 seconds

			(125 bpm * 4 rpb * 6 tpr) / 60 secs = 50 ticks per second!!! (same as LSDJ)

			set clock to ticks per second, set divider to ticks per row
		]]

		tc.soundchip = self
		tc.track_index = i

		BKClockInit(&tc.bk_clock, BKTimeFromSeconds(&self.bk_context, 1.0 / ((154.0 * 4.0 * 6.0) / 60.0)), nilptr)

		BKTrackInit(&tc.bk_track, BK_SQUARE)
		BKSetAttr(&tc.bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME // 8) -- mix volume
		BKSetAttr(&tc.bk_track, BK_VOLUME, BK_MAX_VOLUME /// 4) -- note volume
		BKTrackAttach(&tc.bk_track, &self.bk_context)

		local range: [2]BKInt = {0, 88200}
		BKSetPtr(&tc.bk_track, BK_SAMPLE, &self.bk_data, 0)
		BKSetPtr(&tc.bk_track, BK_SAMPLE_RANGE, &range, #BKInt * 2)
		BKSetAttr(&tc.bk_track, BK_SAMPLE_REPEAT, 1)

		BKInstrumentInit(&tc.bk_instrument)
		BKInstrumentSetEnvelopeADSR(&tc.bk_instrument, 0, 3, BK_MAX_VOLUME, 3)
		BKSetPtr(&tc.bk_track, BK_INSTRUMENT, &tc.bk_instrument, 0)
		
		BKDividerInit(&tc.bk_divider, 6, &callback)
		BKDividerAttachToClock(&tc.bk_divider, &tc.bk_clock)
		BKClockAttach(&tc.bk_clock, &self.bk_context, nilptr)
	end

	BKTrackInit(&self.preview_bk_track, BK_SQUARE)
	BKSetAttr(&self.preview_bk_track, BK_MASTER_VOLUME, BK_MAX_VOLUME // 8) -- mix volume
	BKSetAttr(&self.preview_bk_track, BK_VOLUME, BK_MAX_VOLUME /// 4) -- note volume
	BKTrackAttach(&self.preview_bk_track, &self.bk_context)

	self:resetSoundchip()

	-- reset song
	memory.set(self.song_data, SOUNDCHIP_EMPTY_VALUE, SOUNDCHIP_SONG_SIZE)

    -- reset patterns, each pattern row set to all EMPTY
    memory.set(self.pattern_data, SOUNDCHIP_EMPTY_VALUE, SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)

	-- reset instruments
	-- ...

	self.song_data[0] = 0x00
	self.song_data[8] = 0x01
	self.song_data[1] = 0x10
	self.song_data[9] = 0x11

	for i = 0, < 16 do
		self:getPatternRow(0x00, i)[1] = 0xA0
		self:getPatternRow(0x00, i)[2] = 0
	end

	local instr0: *[0]uint8 = self:getInstrument(0)
	local instr1: *[0]uint8 = self:getInstrument(1)

	instr0[0] = 0
	instr0[1] = 0
	instr0[2] = 0
	instr0[3] = 0
	instr0[4] = (88200 >> 16) & 0xFF
	instr0[5] = (88200 >> 8) & 0xFF
	instr0[6] = (88200) & 0xFF
	instr0[7] = 0
	instr0[8] = 0
	instr0[9] = 255
	instr0[10] = 4

	instr1[0] = 0b10000000
	instr1[1] = (44100 >> 16) & 0xFF
	instr1[2] = (44100 >> 8) & 0xFF
	instr1[3] = (44100) & 0xFF
	instr1[4] = 0
	instr1[5] = 0
	instr1[6] = 0
	instr1[7] = 0
	instr1[8] = 0
	instr1[9] = 255
	instr1[10] = 4

	local w: rl.wave = rl.loadWave("test_data/pluck.wav")
	local wframes: *[0]BKFrame = (@*[0]BKFrame)(w.data)
	for i: uint64 = 0, < w.frameCount do
		local frame: BKFrame = wframes[i]
		self.wbank_ptr[i * 2] = frame
		self.wbank_ptr[(i * 2) + 1] = frame
	end
	rl.unloadWave(w)

	rl.playAudioStream(self.audio_stream)
end

function SoundChip:cleanup(): void
	rl.unloadAudioStream(self.audio_stream)
	rl.closeAudioDevice()

	BKDispose(&self.bk_data)
	
	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		local tc: *TrackContext = &self.track_contexts[i]
		
		BKDispose(&tc.bk_track)
		BKDispose(&tc.bk_divider)
		BKDispose(&tc.bk_clock)
	end
	
	BKDispose(&self.preview_bk_track)
	BKDispose(&self.bk_context)
end
