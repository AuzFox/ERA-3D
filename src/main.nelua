require("os")

require("fs")

require("definitions")
require("compiler")
require("evm")
require("statemachine")
require("state_boot")
require("state_code")
require("state_texture")
require("state_model")
require("state_tracker")
require("state_run")
require("dialog")
require("input")

local MAX_PARTICLES <comptime> = 24

local TriParticle = @record {
	position: rl.vector3,
	rotation: rl.vector3,
	rotation_factor: rl.vector3,
	age: float32,
	age_factor: float32
}

local vm: *EVM
local sm: StateMachine
local particles: [MAX_PARTICLES]TriParticle

local function updateCursorColor(
    frequency1: float32,
    frequency2: float32,
    frequency3: float32,
    phase1: float32,
    phase2: float32,
    phase3: float32,
    center: float32,
    width: float32,
    len: float32): void
    -- default center = 128;
    -- default width = 127;
    -- default len = 50;

    local i: float32 = util.wrapF(rl.getTime() * 12, 0, len)

    local fred: float32 = math.sin(frequency1 * i + phase1) * width + center
    local fgreen: float32 = math.sin(frequency2 * i + phase2) * width + center
    local fblue: float32 = math.sin(frequency3 * i + phase3) * width + center

    local red: uint32 = ((@uint32)(fred) & 0xFF)
    local green: uint32 = ((@uint32)(fgreen) & 0xFF)
    local blue: uint32 = ((@uint32)(fblue) & 0xFF)

    core.cursor_color = (red << 24) | (green << 16) | (blue << 8) | 0xFF
end

local function randomizeParticle(p: *TriParticle): void
	p.position = {
		-- min + math.random() * (max - min)
		-1.5 + math.random() * (1.5 - -1.5),
		-1.5,
		-2.5 + math.random() * (-1.0 - -2.5)
	}
	p.rotation = {
		-- min + math.random() * (max - min)
		0.0 + math.random() * (360.0 - 0.0),
		0.0 + math.random() * (360.0 - 0.0),
		0.0 + math.random() * (360.0 - 0.0)
	}
	p.rotation_factor = {
		-- min + math.random() * (max - min)
		0.1 + math.random() * (1.0 - 0.1),
		0.1 + math.random() * (1.0 - 0.1),
		0.1 + math.random() * (1.0 - 0.1)
	}
	p.age_factor = 0.08 + math.random() * (0.16 - 0.08)
	p.age = 0.0
end

local function setupDirectories(): void
	## if ccinfo.is_windows then
		core.user_directory = os.getenv("HOMEDRIVE") .. os.getenv("HOMEPATH")
		core.data_directory = core.user_directory .. "\\AppData\\Roaming\\era-3d"
		core.carts_directory = core.data_directory .. "\\carts"
		core.memcards_directory = core.data_directory .. "\\memcards"
	## elseif ccinfo.is_linux then
		core.user_directory = os.getenv("HOME")
		core.data_directory = core.user_directory .. "/.era-3d"
		core.carts_directory = core.data_directory .. "/carts"
		core.memcards_directory = core.data_directory .. "/memcards"
	## end

	local succees: boolean
	local errmsg: string
	local errcode: integer

	if not fs.isdir(core.data_directory) then
		succees, errmsg, errcode = fs.mkdir(core.data_directory)
		print("mkdir", core.data_directory, succees, errmsg, errcode)
	end
	if not fs.isdir(core.carts_directory) then
		succees, errmsg, errcode = fs.mkdir(core.carts_directory)
		print("mkdir", core.carts_directory, succees, errmsg, errcode)
	end
	if not fs.isdir(core.memcards_directory) then
		succees, errmsg, errcode = fs.mkdir(core.memcards_directory)
		print("mkdir", core.memcards_directory, succees, errmsg, errcode)
	end
end

local function handleConfigFile(): void
	## if ccinfo.is_windows then
		core.config_file_path = core.data_directory .. "\\config.json"
	## elseif ccinfo.is_linux then
		core.config_file_path = core.data_directory .. "/config.json"
	## end

	if fs.isfile(core.config_file_path) then
		core:loadConfigFile()
	else
		core:setDefaultConfig()
		core:saveConfigFile()
	end
end

local function init(): void
	setupDirectories()
	handleConfigFile()

	vm = newVM()
	input.setDefaultButtonMap()

	sm.states = {
		{
			stateBootInit,
			stateBootEnter,
			stateBootExit,
			stateBootUpdate,
			stateBootDraw,
			stateBootCleanup
		},
		{
			stateCodeInit,
			stateCodeEnter,
			stateCodeExit,
			stateCodeUpdate,
			stateCodeDraw,
			stateCodeCleanup
		},
		{
			stateTrackerInit,
			stateTrackerEnter,
			stateTrackerExit,
			stateTrackerUpdate,
			stateTrackerDraw,
			stateTrackerCleanup
		},
		{
			stateModelInit,
			stateModelEnter,
			stateModelExit,
			stateModelUpdate,
			stateModelDraw,
			stateModelCleanup
		},
		{
			stateTextureInit,
			stateTextureEnter,
			stateTextureExit,
			stateTextureUpdate,
			stateTextureDraw,
			stateTextureCleanup
		},
		{
			stateRunInit,
			stateRunEnter,
			stateRunExit,
			stateRunUpdate,
			stateRunDraw,
			stateRunCleanup
		}
	}

	sm.dialogs = {
		{
			nilptr,
			nilptr
		},
		{
			dialogImportCodeUpdate,
			dialogImportCodeDraw,
		},
		{
			dialogImportTextureUpdate,
			dialogImportTextureDraw,
		},
		{
			dialogImportModelUpdate,
			dialogImportModelDraw,
		},
		{
			dialogImportSampleUpdate,
			dialogImportSampleDraw,
		},
		{
			dialogLoadCartUpdate,
			dialogLoadCartDraw,
		},
		{
			dialogSaveCartUpdate,
			dialogSaveCartDraw,
		}
	}

	core.log_state = LogState.HIDDEN
	core.animation_type = MenuAnimation.NONE
	core.anim_time = 0.0
	core.anim_beginning = 0.0
	core.anim_target = 0.0
    core.facing_angle = 0.0
    core.dialog_size = 0.0
	core.current_cart_name = "UNTITLED CART"

	for i = 0, < MAX_PARTICLES do
		local p: *TriParticle = &particles[i]
		randomizeParticle(p)
	end

	sm:init(vm)
end

local function updateMenuAnimation(): void
    switch core.animation_type do
        case MenuAnimation.STATE_SWITCH then
            if core.anim_time < 0.5 then
                core.anim_time = core.anim_time + rl.getFrameTime()
                core.facing_angle = rle.quadOut(core.anim_time, core.anim_beginning, core.anim_target - core.anim_beginning, 0.5)
            else
                switch sm.state_id do
                    case StateID.CODE then
                        core.facing_angle = 0.0
                    case StateID.TRACKER then
                        core.facing_angle = 90.0
                    case StateID.MODEL then
                        core.facing_angle = 180.0
                    case StateID.TEXTURE then
                        core.facing_angle = 270.0
                end
                core.animation_type = MenuAnimation.NONE
            end
        case MenuAnimation.DIALOG_OPENCLOSE then
            if core.anim_time < 0.25 then
                core.anim_time = core.anim_time + rl.getFrameTime()
                core.dialog_size = rle.quadOut(core.anim_time, core.anim_beginning, core.anim_target - core.anim_beginning, 0.25)
            else
                core.dialog_size = core.anim_target
                core.animation_type = MenuAnimation.NONE
            end
        case MenuAnimation.LOG_OPENCLOSE then
            if core.anim_time < 0.25 then
                core.anim_time = core.anim_time + rl.getFrameTime()
                core.log_offset = rle.quadOut(core.anim_time, core.anim_beginning, core.anim_target - core.anim_beginning, 0.25)
            else
                core.log_offset = core.anim_target
                core.animation_type = MenuAnimation.NONE
            end
    end
end

local function updateLog(): void
	if input.is_ctrl_down and rl.isKeyPressed(rl.keyboardKey.ENTER) then
		core.queued_log_state = LogState.HIDDEN
	elseif rl.isKeyPressed(rl.keyboardKey.C) then
		core:clearLog()
	end
end

local function updatePopup(): void
	switch core.popup_state do
		case PopupState.ANIMATING then
			if core.popup_timer < 0.25 then
				core.popup_timer = core.popup_timer + rl.getFrameTime()
				core.popup_current_factor = rle.quadOut(core.popup_timer, core.popup_beginning_factor, core.popup_target_factor - core.popup_beginning_factor, 0.25)
			else
				core.popup_state = (core.popup_target_factor == 1.0) and PopupState.SHOWN or PopupState.HIDDEN
				core.popup_timer = 0.0
				core.popup_current_factor = core.popup_target_factor
			end
			core.popup_offset = (@uint32)(core.popup_current_factor * 9.0)
		case PopupState.SHOWN then
			core.popup_timer = core.popup_timer + rl.getFrameTime()

			if core.popup_timer >= 4.0 then
				core.popup_state = PopupState.ANIMATING
				core.popup_timer = 0.0
				core.popup_beginning_factor = 1.0
				core.popup_target_factor = 0.0
			end
	end
end

local function run(): void
	while not rl.windowShouldClose() do
		vm.gpu:refreshScreenSize()
		input.refresh(
			(@int32)(vm.gpu.master_dest_rect.x),
			(@int32)(vm.gpu.master_dest_rect.y),
			vm.gpu.screen_w,
			vm.gpu.screen_h
		)

		if rl.isKeyPressed(rl.keyboardKey.F11) then
			vm.gpu:toggleFullscreen()
		end

		updatePopup()

		if core.animation_type ~= MenuAnimation.NONE then
			updateMenuAnimation()
		elseif core.log_state == LogState.SHOWN then
			updateLog()
		elseif sm.dialog_id ~= DialogID.NONE then
			if input.is_ctrl_down and rl.isKeyPressed(rl.keyboardKey.ENTER) then
				core.queued_log_state = LogState.SHOWN
			else
				sm:updateDialog()
			end
		else
			local update_state: boolean = true

			if sm.state_id ~= StateID.RUN then
				if input.clickedRect(0, false, GPU_VSCREEN_W - 48, 0, 48, 9) then
					sm.queued_state = StateID.CODE + ((input.mouse_x - (GPU_VSCREEN_W - 48)) /// 12)
					update_state = false
				elseif input.is_ctrl_down then
					if input.pressedRepeat(rl.keyboardKey.LEFT) then
						sm.queued_state = StateID.STATE_LEFT
						update_state = false
					elseif input.pressedRepeat(rl.keyboardKey.RIGHT) then
						sm.queued_state = StateID.STATE_RIGHT
						update_state = false
					elseif rl.isKeyPressed(rl.keyboardKey.R) then
						if vm:compile() then
							vm:resetVM(true)
							
							vm.cycle_count = 0
							if vm:callHook(Hook.INIT) then
								sm.queued_state = StateID.RUN
								--print("init()", vm.cycle_count)
							else
								core:log(LogEntryType.RUNTIME_ERROR, vm.error, false)
								core:popup(LogEntryType.RUNTIME_ERROR, "a runtime error occurred. press [CTRL+ENTER] to view log")
							end
						else
							core:log(LogEntryType.COMPILE_ERROR, vm.error, false)
							core:popup(LogEntryType.COMPILE_ERROR, "a compiler error occurred. press [CTRL+ENTER] to view log")
						end
						update_state = false
					elseif rl.isKeyPressed(rl.keyboardKey.S) then
						if input.is_shift_down then
							sm:resetFileBrowser(core.carts_directory, FileBrowserMode.SAVE)
							sm.queued_dialog = DialogID.SAVE_CART
						else
							if core.current_cart_path == "" then
								sm:resetFileBrowser(core.carts_directory, FileBrowserMode.SAVE)
								sm.queued_dialog = DialogID.SAVE_CART
							else
								if vm:saveCart(core.current_cart_path) then
									core:log(LogEntryType.INFO, "cart saved", true)
								else
									core:log(LogEntryType.HOST_ERROR, vm.error, true)
								end
							end
						end
						update_state = false
					elseif rl.isKeyPressed(rl.keyboardKey.O) then
						sm:resetFileBrowser(core.carts_directory, FileBrowserMode.LOAD)
						sm.queued_dialog = DialogID.LOAD_CART
						update_state = false
					end
				end
			end

			if update_state and input.is_ctrl_down and rl.isKeyPressed(rl.keyboardKey.ENTER) then
				core.queued_log_state = LogState.SHOWN
				update_state = false
			end
			
			if update_state then
				sm:updateState()
			end
		end

		vm.soundchip:updateAudio()

		if vm.gpu.update_tex then
			vm.gpu:updateTexture()
		end

		-- draw to state render texture
		if core.log_state ~= LogState.SHOWN then
			vm.gpu:beginCurrentRenderTexture()
				if sm.dialog_id ~= DialogID.NONE or core.animation_type == MenuAnimation.DIALOG_OPENCLOSE then
					sm:drawDialog()
				else
					sm:drawState()
				end
			vm.gpu:endRenderTexture()
			
			vm.gpu:resetMatrixStack()
		end

		-- draw to master render texture
		vm.gpu:beginMasterRenderTexture()
			vm.gpu:clear(GPU_BLACK)

			if sm.state_id == StateID.RUN then
				vm.gpu:camera2D(-1)
				vm.gpu:drawCurrentRenderTexture()
			else
				updateCursorColor(0.3, 0.3, 0.3, 0, 2, 4, 128.0, 127.0, 64.0)

				vm.gpu:camera3D(-1)
				
				local aspect: float32 = (@float32)(vm.gpu.screen_w) / (@float32)(vm.gpu.screen_h)
				local distance: float32 = 1.0
				local frustum_height: float32 = 2.0 * distance * math.tan(math.rad(vm.gpu.system_cam.fovy * 0.5))
				local frustum_width: float32 = frustum_height * aspect

				local width: float32 = (frustum_width / 2)
				local height: float32 = (frustum_height / 2)

				-- draw triangle particles
				rlgl.pushMatrix()
					rlgl.disableBackfaceCulling()
					rl.beginShaderMode(vm.gpu.gfx_shader)
						rlgl.begin(rlgl.QUADS)
							for i = 0, < MAX_PARTICLES do
								local p: *TriParticle = &particles[i]

								p.age = p.age + rl.getFrameTime() * p.age_factor
								if p.age > 3.0 then
									randomizeParticle(p)
								else
									p.position = p.position + (@rl.vector3){0.0, rl.getFrameTime() * p.age_factor, 0.0}
									p.rotation = p.rotation + ((@rl.vector3){
										90.0 * rl.getFrameTime() * p.age_factor,
										90.0 * rl.getFrameTime() * p.age_factor,
										90.0 * rl.getFrameTime() * p.age_factor
									} * p.rotation_factor)
								end

								rlgl.loadIdentity()
								rlgl.translatef(p.position.x, p.position.y, p.position.z)
								rlgl.rotatef(p.rotation.z, 0, 0, 1)
								rlgl.rotatef(p.rotation.y, 0, 1, 0)
								rlgl.rotatef(p.rotation.x, 1, 0, 0)

								local alpha: cuchar = 255 - (cuchar)((math.min(p.age, 1.5) / 1.5) * 255.0)

								rlgl.color4ub(0xFF, 0x00, 0x00, alpha)
								rlgl.vertex3f(0.0, 0.1, 0.0)
								rlgl.vertex3f(0.0, 0.1, 0.0)

								rlgl.color4ub(0x00, 0xFF, 0x00, alpha)
								rlgl.vertex3f(-0.1, -0.1, 0.0)

								rlgl.color4ub(0x00, 0x00, 0xFF, alpha)
								rlgl.vertex3f(0.1, -0.1, 0.0)
							end
						rlgl.ending()
					rl.endShaderMode()
					rlgl.enableBackfaceCulling()
				rlgl.popMatrix()

				if core.animation_type == MenuAnimation.STATE_SWITCH then
					-- draw state rendertexture quads
					rlgl.pushMatrix()
						rlgl.rotatef(core.facing_angle, 0.0, 1.0, 0.0)
						
						-- code/run
						vm.gpu:useRenderTexture(RenderTexture.CODE)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(-width, height, -distance)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(-width, -height, -distance)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(width, -height, -distance)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(width, height, -distance)
						rlgl.ending()

						-- tracker
						vm.gpu:useRenderTexture(RenderTexture.TRACKER)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(distance, height, -width)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(distance, -height, -width)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(distance, -height, width)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(distance, height, width)
						rlgl.ending()

						-- model
						vm.gpu:useRenderTexture(RenderTexture.MODEL)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(width, height, distance)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(width, -height, distance)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(-width, -height, distance)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(-width, height, distance)
						rlgl.ending()

						-- texture
						vm.gpu:useRenderTexture(RenderTexture.TEXTURE)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(-distance, height, width)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(-distance, -height, width)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(-distance, -height, -width)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(-distance, height, -width)
						rlgl.ending()
					rlgl.popMatrix()

					vm.gpu:camera2D(-1)
				else
					vm.gpu:camera2D(-1)
					vm.gpu:drawCurrentRenderTexture()
				end

				vm.gpu:drawRect2D(0, 0, GPU_VSCREEN_W, 9, GPU_GRAY & 0xFFFFFFC0)
				vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((#core.current_cart_name /// 2) * 6), 0, GPU_LGRAY, core.current_cart_name)

				if sm.dialog_id ~= DialogID.NONE then
					if core.log_state == LogState.HIDDEN then
						switch sm.dialog_id do
							case DialogID.IMPORT_CODE then
								vm.gpu:print2D(GPU_VSCREEN_W - 13 * 6, 0, GPU_WHITE, "IMPORT SCRIPT")
							case DialogID.IMPORT_TEXTURE then
								vm.gpu:print2D(GPU_VSCREEN_W - 14 * 6, 0, GPU_WHITE, "IMPORT TEXTURE")
							case DialogID.IMPORT_MODEL then
								vm.gpu:print2D(GPU_VSCREEN_W - 12 * 6, 0, GPU_WHITE, "IMPORT MODEL")
							case DialogID.IMPORT_SAMPLE then
								vm.gpu:print2D(GPU_VSCREEN_W - 13 * 6, 0, GPU_WHITE, "IMPORT SAMPLE")
							case DialogID.LOAD_CART then
								vm.gpu:print2D(GPU_VSCREEN_W - 9 * 6, 0, GPU_WHITE, "LOAD CART")
							case DialogID.SAVE_CART then
								vm.gpu:print2D(GPU_VSCREEN_W - 9 * 6, 0, GPU_WHITE, "SAVE CART")
						end
					end
				else
					vm.gpu:drawIcon2D(GPU_VSCREEN_W - 48, 0, (sm.state_id == StateID.CODE) and core.cursor_color or GPU_LGRAY, Icon.STATE_CODE)
					vm.gpu:drawIcon2D(GPU_VSCREEN_W - 36, 0, (sm.state_id == StateID.TRACKER) and core.cursor_color or GPU_LGRAY, Icon.STATE_TRACKER)
					vm.gpu:drawIcon2D(GPU_VSCREEN_W - 24, 0, (sm.state_id == StateID.MODEL) and core.cursor_color or GPU_LGRAY, Icon.STATE_MODEL)
					vm.gpu:drawIcon2D(GPU_VSCREEN_W - 12, 0, (sm.state_id == StateID.TEXTURE) and core.cursor_color or GPU_LGRAY, Icon.STATE_TEXTURE)
				end
			end

			if core.log_state == LogState.SHOWN or core.animation_type == MenuAnimation.LOG_OPENCLOSE then
				local log_y: int32 = -144 + (@int32)(core.log_offset * 144.0)
				vm.gpu:drawRect2D(0, log_y, GPU_VSCREEN_W, 145, GPU_BLACK & 0xFFFFFFC0)
				vm.gpu:drawRect2D(0, log_y + 145, GPU_VSCREEN_W, 1, GPU_GRAY)

				local line_y: int32 = log_y
				local line_index: int32 = util.wrapI(core.log_index - core.log_count, 0, 16)
				local lines_drawn: int32 = 0
				for i = 0, < core.log_count do
					local line_ptr: *[0]cchar = (@*[0]cchar)(&core.log_text[line_index * 81])

					local col: uint32
					switch core.log_types[line_index] do
						case LogEntryType.INFO then
							col = GPU_GREEN
						case LogEntryType.HOST_ERROR then
							col = GPU_YELLOW
						case LogEntryType.COMPILE_ERROR then
							col = GPU_ORANGE
						case LogEntryType.RUNTIME_ERROR then
							col = GPU_RED
					end

					vm.gpu:printCString2D(0, line_y, col, line_ptr)
					
					line_index = util.wrapI(line_index + 1, 0, 16)
					line_y = line_y + 9
					lines_drawn = lines_drawn + 1
				end
			end

			if core.popup_state ~= PopupState.HIDDEN then
				vm.gpu:drawRect2D(0, GPU_VSCREEN_H - core.popup_offset, GPU_VSCREEN_W, 9, GPU_BLACK & 0xFFFFFFC0)
				vm.gpu:print2D(6, GPU_VSCREEN_H - core.popup_offset, core.popup_color, core.popup_text)
			end

			if core.config.draw_fps then
				local color: uint32 = GPU_GREEN
				local fps: cint = rl.getFPS()

				if fps <= 10 then
					color = GPU_RED
				elseif fps < 20 then
					color = GPU_YELLOW
				end
				
				vm.gpu:drawRect2D(0, 0, 12, 9, GPU_BLACK)
				vm.gpu:printInt2D(0, 0, color, (@int32)(fps), nilptr)
			end
		vm.gpu:endRenderTexture()

		vm.gpu:resetMatrixStack()

		-- render master render texture to the screen
		rl.beginDrawing()
			vm.gpu:clear(GPU_BLACK)
			vm.gpu:drawMasterRenderTexture()
		rl.endDrawing()
		
		if core.queued_log_state ~= LogState.NONE then
			if (core.log_state == LogState.HIDDEN and core.queued_log_state == LogState.SHOWN) or (core.log_state == LogState.SHOWN and core.queued_log_state == LogState.HIDDEN) then
				core.animation_type = MenuAnimation.LOG_OPENCLOSE
				core.anim_time = 0.0
				core.anim_beginning = core.log_offset
				
				if core.queued_log_state == LogState.HIDDEN then
					core.anim_target = 0.0
				else
					core.anim_target = 1.0
				end
			end

			core.log_state = core.queued_log_state
			core.queued_log_state = LogState.NONE
		end

		sm:update()
	end

	if vm.memcard_id ~= "" then
		vm:saveMemCard()
	end

	sm:cleanup()
end

--io.printf('HEAP:    0x%08X - 0x%08X\n', MEMORY_HEAP_START_ADDR, MEMORY_HEAP_MAX_ADDR)
--io.printf('TEXMEM:  0x%08X - 0x%08X\n', MEMORY_TEXMEM_START_ADDR, MEMORY_TEXMEM_MAX_ADDR)
--io.printf('OBJMEM:  0x%08X - 0x%08X\n', MEMORY_OBJMEM_START_ADDR, MEMORY_OBJMEM_MAX_ADDR)
--io.printf('AOBMEM:  0x%08X - 0x%08X\n', MEMORY_AOBMEM_START_ADDR, MEMORY_AOBMEM_MAX_ADDR)
--io.printf('SYSMEM:  0x%08X - 0x%08X\n', MEMORY_SYSMEM_START_ADDR, MEMORY_SYSMEM_MAX_ADDR)
--io.printf('WAVMEM:  0x%08X - 0x%08X\n', MEMORY_WAVMEM_START_ADDR, MEMORY_WAVMEM_MAX_ADDR)
--io.printf('SEQMEM:  0x%08X - 0x%08X\n', MEMORY_SEQMEM_START_ADDR, MEMORY_SEQMEM_MAX_ADDR)
--io.printf('GLOBALS: 0x%08X - 0x%08X\n', MEMORY_GLOBALS_START_ADDR, MEMORY_GLOBALS_MAX_ADDR)
--io.printf('LOCALS:  0x%08X - 0x%08X\n', MEMORY_LOCALS_START_ADDR, MEMORY_LOCALS_MAX_ADDR)
--io.printf('ARGS:    0x%08X - 0x%08X\n', MEMORY_ARGS_START_ADDR, MEMORY_ARGS_MAX_ADDR)
--io.printf('TEXBANK: 0x%08X - 0x%08X\n', MEMORY_TEXBANK_START_ADDR, MEMORY_TEXBANK_MAX_ADDR)
--io.printf('OBJBANK: 0x%08X - 0x%08X\n', MEMORY_OBJBANK_START_ADDR, MEMORY_OBJBANK_MAX_ADDR)
--io.printf('OMPBANK: 0x%08X - 0x%08X\n', MEMORY_OMPBANK_START_ADDR, MEMORY_OMPBANK_MAX_ADDR)
--io.printf('WMPBANK: 0x%08X - 0x%08X\n', MEMORY_WMPBANK_START_ADDR, MEMORY_WMPBANK_MAX_ADDR)
--io.printf('WAVBANK: 0x%08X - 0x%08X\n', MEMORY_WAVBANK_START_ADDR, MEMORY_WAVBANK_MAX_ADDR)
--io.printf('SEQBANK: 0x%08X - 0x%08X\n', MEMORY_SEQBANK_START_ADDR, MEMORY_SEQBANK_MAX_ADDR)
--io.printf('ROM:     0x%08X - 0x%08X\n', MEMORY_ROM_START_ADDR, MEMORY_ROM_MAX_ADDR)
--io.printf('MEMCARD: 0x%08X - 0x%08X\n', MEMORY_MEMCARD_START_ADDR, MEMORY_MEMCARD_MAX_ADDR)

init()
run()
