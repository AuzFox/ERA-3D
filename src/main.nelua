require("os")

require("fs")

require("definitions")
require("compiler")
require("evm")
require("statemachine")
require("state_boot")
require("state_main")
require("state_code")
require("state_texture")
require("state_model")
require("state_tracker")
require("state_run")
require("dialog")
require("input")

local MAX_PARTICLES <comptime> = 32

local TriParticle = @record {
	position: rl.vector3,
	rotation: rl.vector3,
	rotation_factor: rl.vector3,
	age: float32,
	age_factor: float32
}

local vm: *EVM
local sm: StateMachine
local particles: [MAX_PARTICLES]TriParticle

local function updateCursorColor(
    frequency1: float32,
    frequency2: float32,
    frequency3: float32,
    phase1: float32,
    phase2: float32,
    phase3: float32,
    center: float32,
    width: float32,
    len: float32): void
    -- default center = 128;
    -- default width = 127;
    -- default len = 50;

    local i: float32 = util.wrapF(rl.getTime() * 12, 0, len)

    local fred: float32 = math.sin(frequency1 * i + phase1) * width + center
    local fgreen: float32 = math.sin(frequency2 * i + phase2) * width + center
    local fblue: float32 = math.sin(frequency3 * i + phase3) * width + center

    local red: uint32 = ((@uint32)(fred) & 0xFF)
    local green: uint32 = ((@uint32)(fgreen) & 0xFF)
    local blue: uint32 = ((@uint32)(fblue) & 0xFF)

    core.cursor_color = (red << 24) | (green << 16) | (blue << 8) | 0xFF
end

local function randomizeParticle(p: *TriParticle): void
	p.position = {
		-- min + math.random() * (max - min)
		-1.5 + math.random() * (1.5 - -1.5),
		-1.5,
		-2.5 + math.random() * (-1.0 - -2.5)
	}
	p.rotation = {
		-- min + math.random() * (max - min)
		0.0 + math.random() * (360.0 - 0.0),
		0.0 + math.random() * (360.0 - 0.0),
		0.0 + math.random() * (360.0 - 0.0)
	}
	p.rotation_factor = {
		-- min + math.random() * (max - min)
		0.1 + math.random() * (1.0 - 0.1),
		0.1 + math.random() * (1.0 - 0.1),
		0.1 + math.random() * (1.0 - 0.1)
	}
	p.age_factor = 0.5 + math.random() * (1.0 - 0.5)
	p.age = 0.0
end

local function setupDirectories(): void
	## if ccinfo.is_windows then
		core.user_directory = os.getenv("HOMEDRIVE") .. os.getenv("HOMEPATH")
		core.data_directory = core.user_directory .. "\\AppData\\Roaming\\era-3d"
		core.carts_directory = core.data_directory .. "\\carts"
	## elseif ccinfo.is_linux then
		core.user_directory = os.getenv("HOME")
		core.data_directory = core.user_directory .. "/.era-3d"
		core.carts_directory = core.data_directory .. "/carts"
	## end

	print("user dir:", core.user_directory)
	print("data dir:", core.data_directory)
	print("carts dir:", core.carts_directory)

	local succees: boolean
	local errmsg: string
	local errcode: integer

	if not fs.isdir(core.data_directory) then
		succees, errmsg, errcode = fs.mkdir(core.data_directory)
		print("mkdir", core.data_directory, succees, errmsg, errcode)
	end
	if not fs.isdir(core.carts_directory) then
		succees, errmsg, errcode = fs.mkdir(core.carts_directory)
		print("mkdir", core.carts_directory, succees, errmsg, errcode)
	end
end

local function init(): void
	setupDirectories()

	vm = newVM()
	input.setDefaultButtonMap()

	sm.states = {
		{
			stateBootInit,
			stateBootEnter,
			stateBootExit,
			stateBootUpdate,
			stateBootDraw,
			stateBootCleanup
		},
		{
			stateMainInit,
			stateMainEnter,
			stateMainExit,
			stateMainUpdate,
			stateMainDraw,
			stateMainCleanup
		},
		{
			stateCodeInit,
			stateCodeEnter,
			stateCodeExit,
			stateCodeUpdate,
			stateCodeDraw,
			stateCodeCleanup
		},
		{
			stateTextureInit,
			stateTextureEnter,
			stateTextureExit,
			stateTextureUpdate,
			stateTextureDraw,
			stateTextureCleanup
		},
		{
			stateModelInit,
			stateModelEnter,
			stateModelExit,
			stateModelUpdate,
			stateModelDraw,
			stateModelCleanup
		},
		{
			stateTrackerInit,
			stateTrackerEnter,
			stateTrackerExit,
			stateTrackerUpdate,
			stateTrackerDraw,
			stateTrackerCleanup
		},
		{
			stateRunInit,
			stateRunEnter,
			stateRunExit,
			stateRunUpdate,
			stateRunDraw,
			stateRunCleanup
		}
	}

	sm.dialogs = {
		{
			nilptr,
			nilptr
		},
		{
			dialogImportCodeUpdate,
			dialogImportCodeDraw,
		},
		{
			dialogImportTextureUpdate,
			dialogImportTextureDraw,
		},
		{
			dialogImportModelUpdate,
			dialogImportModelDraw,
		},
		{
			dialogImportSampleUpdate,
			dialogImportSampleDraw,
		},
		{
			dialogLoadCartUpdate,
			dialogLoadCartDraw,
		},
		{
			dialogSaveCartUpdate,
			dialogSaveCartDraw,
		}
	}

	for i = 0, < MAX_PARTICLES do
		local p: *TriParticle = &particles[i]
		randomizeParticle(p)
	end

	sm:init(vm)
end

local function run(): void
	while not rl.windowShouldClose() do
		if sm.animation_type ~= StateAnimation.NONE then
			sm:updateAnimation()
		elseif sm.dialog_id ~= DialogID.NONE then
			sm:updateDialog()
		else
			sm:updateState()
		end

		vm.soundchip:updateAudio()

		if sm.state_id == StateID.RUN and vm.gpu.update_tex then
			rl.updateTexture(vm.gpu.gfx_texture, &vm.gpu.texmem)
			vm.gpu.update_tex = false
		end

		-- draw to state render texture
		vm.gpu:beginCurrentRenderTexture()
			if sm.dialog_id ~= DialogID.NONE or sm.animation_type == StateAnimation.DIALOG_OPENCLOSE then
				sm:drawDialog()
			else
				sm:drawState()
			end
		vm.gpu:endRenderTexture()
		
		vm.gpu:resetMatrixStack()

		-- draw to master render texture
		vm.gpu:beginMasterRenderTexture()
			vm.gpu:clear(GPU_BLACK)

			if sm.state_id == StateID.RUN then
				vm.gpu:camera2D(-1)
				vm.gpu:drawCurrentRenderTexture()
			else
				updateCursorColor(0.3, 0.3, 0.3, 0, 2, 4, 128.0, 127.0, 64.0)

				vm.gpu:camera3D(-1)
				
				local aspect: float32 = (@float32)(GPU_SCREEN_W) / (@float32)(GPU_SCREEN_H)
				local distance: float32 = 1.0
				local frustum_height: float32 = 2.0 * distance * math.tan(math.rad(vm.gpu.system_cam.fovy * 0.5))
				local frustum_width: float32 = frustum_height * aspect

				local width: float32 = (frustum_width / 2)
				local height: float32 = (frustum_height / 2)

				-- draw triangle particles
				rlgl.pushMatrix()
					rlgl.disableBackfaceCulling()
					rl.beginShaderMode(vm.gpu.gfx_shader)
						rlgl.begin(rlgl.QUADS)
							for i = 0, < MAX_PARTICLES do
								local p: *TriParticle = &particles[i]

								p.age = p.age + rl.getFrameTime() * p.age_factor
								if p.age > 4.0 then
									randomizeParticle(p)
								else
									p.position = p.position + (@rl.vector3){0.0, rl.getFrameTime() * p.age_factor, 0.0}
									p.rotation = p.rotation + ((@rl.vector3){
										90.0 * rl.getFrameTime() * p.age_factor,
										90.0 * rl.getFrameTime() * p.age_factor,
										90.0 * rl.getFrameTime() * p.age_factor
									} * p.rotation_factor)
								end

								rlgl.loadIdentity()
								rlgl.translatef(p.position.x, p.position.y, p.position.z)
								rlgl.rotatef(p.rotation.z, 0, 0, 1)
								rlgl.rotatef(p.rotation.y, 0, 1, 0)
								rlgl.rotatef(p.rotation.x, 1, 0, 0)

								local alpha: cuchar = 255 - (cuchar)((math.min(p.age, 1.75) / 1.75) * 255.0)

								rlgl.color4ub(0xFF, 0x00, 0x00, alpha)
								rlgl.vertex3f(0.0, 0.1, 0.0)
								rlgl.vertex3f(0.0, 0.1, 0.0)

								rlgl.color4ub(0x00, 0xFF, 0x00, alpha)
								rlgl.vertex3f(-0.1, -0.1, 0.0)

								rlgl.color4ub(0x00, 0x00, 0xFF, alpha)
								rlgl.vertex3f(0.1, -0.1, 0.0)
							end
						rlgl.ending()
					rl.endShaderMode()
					rlgl.enableBackfaceCulling()
				rlgl.popMatrix()

				if sm.animation_type == StateAnimation.STATE_SWITCH then
					-- draw state rendertexture quads
					rlgl.pushMatrix()
						rlgl.rotatef(sm.facing_angle, 0.0, 1.0, 0.0)
						
						-- main/run
						vm.gpu:useRenderTexture(RenderTexture.MAIN)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(-width, height, -distance)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(-width, -height, -distance)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(width, -height, -distance)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(width, height, -distance)
						rlgl.ending()

						-- tracker
						vm.gpu:useRenderTexture(RenderTexture.TRACKER)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(distance, height, -width)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(distance, -height, -width)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(distance, -height, width)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(distance, height, width)
						rlgl.ending()

						-- code
						vm.gpu:useRenderTexture(RenderTexture.MAIN)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(width, height, distance)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(width, -height, distance)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(-width, -height, distance)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(-width, height, distance)
						rlgl.ending()

						-- texture
						vm.gpu:useRenderTexture(RenderTexture.TEXTURE)
						rlgl.begin(rlgl.QUADS)
							rlgl.color4ub(0xFF, 0xFF, 0xFF, 0xFF)
							rlgl.texCoord2f(0.0, 1.0)
							rlgl.vertex3f(-distance, height, width)
							rlgl.texCoord2f(0.0, 0.0)
							rlgl.vertex3f(-distance, -height, width)
							rlgl.texCoord2f(1.0, 0.0)
							rlgl.vertex3f(-distance, -height, -width)
							rlgl.texCoord2f(1.0, 1.0)
							rlgl.vertex3f(-distance, height, -width)
						rlgl.ending()
					rlgl.popMatrix()

					vm.gpu:camera2D(-1)
				else
					vm.gpu:camera2D(-1)
					vm.gpu:drawCurrentRenderTexture()
				end

				if sm.dialog_id ~= DialogID.NONE then
					switch sm.dialog_id do
						case DialogID.IMPORT_CODE then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((13 * 6) /// 2), 0, GPU_WHITE, "IMPORT SCRIPT")
						case DialogID.IMPORT_TEXTURE then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((14 * 6) /// 2), 0, GPU_WHITE, "IMPORT TEXTURE")
						case DialogID.IMPORT_MODEL then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((12 * 6) /// 2), 0, GPU_WHITE, "IMPORT MODEL")
						case DialogID.IMPORT_SAMPLE then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((13 * 6) /// 2), 0, GPU_WHITE, "IMPORT SAMPLE")
						case DialogID.LOAD_CART then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((9 * 6) /// 2), 0, GPU_WHITE, "LOAD CART")
						case DialogID.SAVE_CART then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((9 * 6) /// 2), 0, GPU_WHITE, "SAVE CART")
					end
				else
					switch sm.state_id do
						case StateID.MAIN then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((9 * 6) /// 2), 0, GPU_WHITE, "MAIN MENU")
						case StateID.TRACKER then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((7 * 6) /// 2), 0, GPU_WHITE, "TRACKER")
						case StateID.TEXTURE then
							vm.gpu:print2D((GPU_VSCREEN_W /// 2) - ((14 * 6) /// 2), 0, GPU_WHITE, "TEXTURE EDITOR")
					end
				end
			end
		vm.gpu:endRenderTexture()

		vm.gpu:resetMatrixStack()

		-- render master render texture to the screen
		rl.beginDrawing()
			rl.clearBackground(rl.GRAY)
			vm.gpu:drawMasterRenderTexture()
		rl.endDrawing()

		sm:update()
	end

	sm:cleanup()
end

init()
run()
