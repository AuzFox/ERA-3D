require("string")

require("raylib")
require("rlgl")

local GL_DEPTH_BUFFER_BIT <comptime> = 0x00000100
local function glClear(mask: cint): void <cimport> end

global GPU_ALPHA_BLACK <comptime> = 0x00000000
global GPU_ALPHA_WHITE <comptime> = 0xFFFFFF00
global GPU_BLACK       <comptime> = 0x000000FF
global GPU_GRAY        <comptime> = 0x808080FF
global GPU_WHITE       <comptime> = 0xFFFFFFFF
global GPU_RED         <comptime> = 0xFF0000FF
global GPU_GREEN       <comptime> = 0x00FF00FF
global GPU_BLUE        <comptime> = 0x0000FFFF

-- screen dimentions (vscreen is console's virtual resolution)
global GPU_VSCREEN_W <comptime> = 320
global GPU_VSCREEN_H <comptime> = 240
global GPU_SCREEN_W <comptime> = (GPU_VSCREEN_W * 3)
global GPU_SCREEN_H <comptime> = (GPU_VSCREEN_H * 3)
global GPU_CAMERAS_COUNT <comptime> = 4

global GPU_LINES <comptime> = 0
global GPU_TRIANGLES <comptime> = 1
global GPU_QUADS <comptime> = 2

global GPU_PROJECTION <comptime> = 0
global GPU_MODELVIEW <comptime> = 1

global GPU_TMEM_WIDTH <comptime> = 1024
global GPU_TMEM_HEIGHT <comptime> = 1024
global GPU_TMEM_SIZE <comptime> = (GPU_TMEM_WIDTH * GPU_TMEM_HEIGHT) -- 4MiB (1024*1024 pixels (32BPP))
global GPU_OMEM_SIZE <comptime> = (32768 * (36 * 3)) -- 32768 triangles

-- holds graphics information for the vm
global GPU = @record {
	tmem: [GPU_TMEM_SIZE]rl.color,
	omem: [GPU_OMEM_SIZE]uint8,
	cameras2D: [GPU_CAMERAS_COUNT]rl.camera2D,
	cameras: [GPU_CAMERAS_COUNT]rl.camera,
	gfx_texture: rl.texture,
	gfx_shader: rl.shader,
	gfx_rendertex: rl.renderTexture,
	gfx_font_texture: rl.texture,
	
	-- shader uniform locations
	tex_mode_loc: cint,
	tex_x_loc: cint,
	tex_y_loc: cint,
	tex_w_loc: cint,
	tex_h_loc: cint,
	fog_mode_loc: cint,
	fog_start_loc: cint,
	fog_end_loc: cint,
	fog_color_loc: cint,

	update_tex: boolean, -- set when TMEM is updated. when set, TMEM is uploaded to the real GPU

	-- "triangle mode" data
	--
	-- RLGL currently doesn't allow primitives created using RL_TRIANGLES to use UV coordinates for textures.
	-- to mimic textured triangles, we use use RL_QUADS and send a copy of the first vertex as the last quad vertex
	triangle_mode: boolean,
	triangle_vert_index: integer,

	proj_matrix_count: uinteger, -- used to track matrix stack
	view_matrix_count: uinteger, -- used to track matrix stack
	matrix_mode: uinteger,
	
	-- graphics state
	cull_mode: uinteger,
	wire_mode: boolean,
	tex_mode: cint,
	tex_x: cint,
	tex_y: cint,
	tex_w: cint,
	tex_h: cint,
	fog_mode: cint,
	fog_start: float32,
	fog_end: float32,
	fog_color: rl.vector4,
	viewport_w: cint,
	viewport_h: cint
}

global Vertex = @record {
	pos: rl.vector3,
	normal: rl.vector3,
	uv: rl.vector2,
	col: uint32,
}

local IntFloat = @union {
	u: uint32,
	f: float32
}

function GPU:clear(col: uint32): void
	local alpha: cuchar = (@cuchar)(col & 0xFF)

	if alpha ~= 0 then
		local clear_color: rl.color = {
			(@cuchar)(col >> 24),
			(@cuchar)((col & 0xFF0000) >> 16),
			(@cuchar)((col & 0x00FF00) >> 8),
			0xFF
		}

		rl.clearBackground(clear_color)
	else
		glClear(GL_DEPTH_BUFFER_BIT) -- clear the depth buffer, but not the color buffer
	end
end

function GPU:camera2D(id: uinteger): void
	local cam: rl.camera2D = self.cameras2D[id]

	rlgl.disableDepthTest()
	
	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
	rlgl.loadIdentity()
	rlgl.ortho(0.0, self.viewport_w, self.viewport_h, 0.0, 0.0, 1.0)

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	rl.beginMode2D(cam)
	
	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:camera3D(id: uinteger): void
	local cam: rl.camera = self.cameras[id]

	-- copy Raylib's BeginMode3D(),
	-- but we don't need to push a new projection matrix

	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
    rlgl.loadIdentity()

	local aspect: float32 = (@float32)(self.viewport_w) / (@float32)(self.viewport_h)

	-- 0.01 is the near clipping value
	-- 1000.0 is the far clipping value
	-- TODO: allow setting near/far?
	if cam.projection == rl.cameraProjection.PERSPECTIVE then
		local top: float64 = 0.01 * math.tan(cam.fovy * 0.5 * (math.pi / 180.0))
		local right: float64 = top * aspect

		rlgl.frustum(-right, right, -top, top, 0.01, 1000.0)
	elseif cam.projection == rl.cameraProjection.ORTHOGRAPHIC then
		local top: float64 = cam.fovy / 2.0
		local right: float64 = top * aspect

		rlgl.ortho(-right, right, -top, top, 0.01, 1000.0)
	end

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	local mat_view: rl.matrix = rl.matrix.lookAt(cam.position, cam.target, cam.up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	rlgl.enableDepthTest()

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:beginMesh(mode: uint32): void
	switch mode do
		case GPU_LINES then
			self.triangle_mode = false
			mode = rlgl.LINES
		case GPU_TRIANGLES then
			self.triangle_mode = true
			self.triangle_vert_index = 0
			mode = rlgl.QUADS
		case GPU_QUADS then
			self.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(self.gfx_shader)

	rlgl.setTexture(self.gfx_texture.id)
	
	rlgl.begin(mode)
end

function GPU:endMesh(): void
	rlgl.ending()

	rl.endShaderMode()
end

function GPU:matrixMode(mode: uint32): void
	switch mode do
		case GPU_PROJECTION then
			rlgl.matrixMode(rlgl.PROJECTION)
			self.matrix_mode = rlgl.PROJECTION
		case GPU_MODELVIEW then
			rlgl.matrixMode(rlgl.MODELVIEW)
			self.matrix_mode = rlgl.MODELVIEW
	end
end

function GPU:vertex(v: rl.vector3): void
	rlgl.vertex3f(v.x, v.y, v.z)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex3f(v.x, v.y, v.z)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertex2D(v: rl.vector2): void
	rlgl.vertex2f(v.x, v.y)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex2f(v.x, v.y)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertUV(v: rl.vector2): void
	rlgl.texCoord2f(v.x, v.y)
end

function GPU:vertColor(col: uint32): void
	local r: cuchar = (@cuchar)(col >> 24)
	local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
	local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
	local a: cuchar = (@cuchar)(col & 0xFF)
	
	rlgl.color4ub(r, g, b, a)
end

function GPU:drawChar2D(c: uint8, x: *int32, y: int32, color: rl.color): void
	local fx: float32 = (@float32)($x)
	local fy: float32 = (@float32)(y)

	if fx <= -6.0 or y <= -9.0 or color.a == 0 then
		return
	end

	if c < ' '_u8 then
		c = '?'_u8
	elseif c == ' '_u8 then
		$x = $x + 6
		return
	elseif c == '\t'_u8 then
		$x = $x + 12 -- tabs = 2 spaces
	end

	local srcx: float32 = (@float32)((c %%% 32) * 6)
	local srcy: float32 = (@float32)((c /// 32) * 9)

	local src_rect: rl.rectangle = { srcx, srcy, 6.0, 9.0 };
	local dest_rect: rl.rectangle = { fx, fy, 6.0, 9.0 };

	rl.drawTexturePro(self.gfx_font_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, color)

	$x = $x + 6
end

-- print2D function for host program, doesn't do formatting
function GPU:print2D(x: int32, y: int32, col: uint32, text: string): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local i: uinteger = 1
	while i <= #text do
		local c: uint8

		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end

		c = text[i]
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end
end

-- printHexNibble2D function for host program, doesn't do formatting
function GPU:printHexNibble2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local nibble: uint8 = val & 0xF
	if nibble < 0xA then
		nibble = '0'_u8 + nibble
	else
		nibble = 'A'_u8 + (nibble - 0xA)
	end

	self:drawChar2D(nibble, &cur_x, y, ray_col)
end

-- printHexByte2D function for host program, doesn't do formatting
function GPU:printHexByte2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local msn: uint8 = val >> 4
	if msn < 0xA then
		msn = '0'_u8 + msn
	else
		msn = 'A'_u8 + (msn - 0xA)
	end

	self:drawChar2D(msn, &cur_x, y, ray_col)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local lsn: uint8 = val & 0xF
	if lsn < 0xA then
		lsn = '0'_u8 + lsn
	else
		lsn = 'A'_u8 + (lsn - 0xA)
	end

	self:drawChar2D(lsn, &cur_x, y, ray_col)
end

function GPU:drawRect2D(x: int32, y: int32, w: int32, h: int32, col: uint32): void
	local fx0: float32 = (@float32)(x)
	local fy0: float32 = (@float32)(y)
	local fx1: float32 = (@float32)(x + w)
	local fy1: float32 = (@float32)(y + h)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	rl.drawRectangle(x, y, w, h, ray_col)
end

function GPU:getOMEMVertex(index: uint32): Vertex
	local v: Vertex
	local byte_index: uinteger = index * 36
	local ptr: *[0]uint8 = &self.omem[byte_index]

	-- get position
	local temp: IntFloat
	temp.u = ((@uint32)(ptr[0]) << 24) | ((@uint32)(ptr[1]) << 16) | ((@uint32)(ptr[2]) << 8) | (@uint32)(ptr[3])
	v.pos.x = temp.f
	temp.u = ((@uint32)(ptr[4]) << 24) | ((@uint32)(ptr[5]) << 16) | ((@uint32)(ptr[6]) << 8) | (@uint32)(ptr[7])
	v.pos.y = temp.f
	temp.u = ((@uint32)(ptr[8]) << 24) | ((@uint32)(ptr[9]) << 16) | ((@uint32)(ptr[10]) << 8) | (@uint32)(ptr[11])
	v.pos.z = temp.f

	-- get normal
	temp.u = ((@uint32)(ptr[12]) << 24) | ((@uint32)(ptr[13]) << 16) | ((@uint32)(ptr[14]) << 8) | (@uint32)(ptr[15])
	v.normal.x = temp.f
	temp.u = ((@uint32)(ptr[16]) << 24) | ((@uint32)(ptr[17]) << 16) | ((@uint32)(ptr[18]) << 8) | (@uint32)(ptr[19])
	v.normal.y = temp.f
	temp.u = ((@uint32)(ptr[20]) << 24) | ((@uint32)(ptr[21]) << 16) | ((@uint32)(ptr[22]) << 8) | (@uint32)(ptr[23])
	v.normal.z = temp.f

	-- get uv
	temp.u = ((@uint32)(ptr[24]) << 24) | ((@uint32)(ptr[25]) << 16) | ((@uint32)(ptr[26]) << 8) | (@uint32)(ptr[27])
	v.uv.x = temp.f
	temp.u = ((@uint32)(ptr[28]) << 24) | ((@uint32)(ptr[29]) << 16) | ((@uint32)(ptr[30]) << 8) | (@uint32)(ptr[31])
	v.uv.y = temp.f

	-- get color
	v.col = ((@uint32)(ptr[32]) << 24) | ((@uint32)(ptr[33]) << 16) | ((@uint32)(ptr[34]) << 8) | (@uint32)(ptr[35])

	return v
end

function GPU:drawModel(mode: uint32, start: uint32, n: uint32): void
	if n == 0 then
		return
	end

	self:beginMesh(mode)
		switch mode do
			case GPU_LINES then
				for i = 0, < n do
					-- get vertices
					local tri_start: uint32 = start + (i * 2)
					local v0: Vertex = self:getOMEMVertex(tri_start)
					local v1: Vertex = self:getOMEMVertex(tri_start + 1)
		
					-- upload vertices
					self:vertUV(v0.uv)
					self:vertColor(v0.col)
					self:vertex(v0.pos)
		
					self:vertUV(v1.uv)
					self:vertColor(v1.col)
					self:vertex(v1.pos)
				end
			case GPU_TRIANGLES then
				for i = 0, < n do
					-- get vertices
					local tri_start: uint32 = start + (i * 3)
					local v0: Vertex = self:getOMEMVertex(tri_start)
					local v1: Vertex = self:getOMEMVertex(tri_start + 1)
					local v2: Vertex = self:getOMEMVertex(tri_start + 2)
		
					-- upload vertices
					self:vertUV(v0.uv)
					self:vertColor(v0.col)
					self:vertex(v0.pos)
		
					self:vertUV(v1.uv)
					self:vertColor(v1.col)
					self:vertex(v1.pos)
		
					self:vertUV(v2.uv)
					self:vertColor(v2.col)
					self:vertex(v2.pos)
				end
			case GPU_QUADS then
				for i = 0, < n do
					-- get vertices
					local quad_start: uint32 = start + (i * 4)
					local v0: Vertex = self:getOMEMVertex(quad_start)
					local v1: Vertex = self:getOMEMVertex(quad_start + 1)
					local v2: Vertex = self:getOMEMVertex(quad_start + 2)
					local v3: Vertex = self:getOMEMVertex(quad_start + 3)
		
					-- upload vertices
					self:vertUV(v0.uv)
					self:vertColor(v0.col)
					self:vertex(v0.pos)
		
					self:vertUV(v1.uv)
					self:vertColor(v1.col)
					self:vertex(v1.pos)
		
					self:vertUV(v2.uv)
					self:vertColor(v2.col)
					self:vertex(v2.pos)

					self:vertUV(v3.uv)
					self:vertColor(v3.col)
					self:vertex(v3.pos)
				end
		end
	self:endMesh()
end

function GPU:texture(x: int32, y: int32, w: int32, h: int32): void
	self.tex_x = (@cint)(x)
	self.tex_y = (@cint)(y)
	self.tex_w = (@cint)(w)
	self.tex_h = (@cint)(h)
	
	rl.setShaderValue(self.gfx_shader, self.tex_x_loc, &self.tex_x, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_y_loc, &self.tex_y, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_w_loc, &self.tex_w, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_h_loc, &self.tex_h, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:resetMatrixStack(): void
	rlgl.matrixMode(rlgl.PROJECTION)

	while self.proj_matrix_count > 0 do
		rlgl.popMatrix()
		self.proj_matrix_count = self.proj_matrix_count - 1
	end

	rlgl.matrixMode(rlgl.MODELVIEW)

	while self.view_matrix_count > 0 do
		rlgl.popMatrix()
		self.view_matrix_count = self.view_matrix_count - 1
	end
end

function GPU:enableRenderState(): void
	switch self.cull_mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
	end

	if self.wire_mode then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	rlgl.enableScissorTest()
	rlgl.scissor(0, 0, GPU_VSCREEN_W, GPU_VSCREEN_H)

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:disableRenderState(): void
	rlgl.enableBackfaceCulling()
	rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
	rlgl.disableWireMode()
	rlgl.disableScissorTest()
	rlgl.viewport(0, 0, GPU_SCREEN_W, GPU_SCREEN_H)
end

function GPU:resetGPU(): void
	for i = 0, < GPU_CAMERAS_COUNT do
		self.cameras2D[i] = {
			offset={0.0,0.0},
			target={0.0,0.0},
			rotation=0.0,
			zoom=1.0
		}

		self.cameras[i] = {
			position={0,0,4},
			target={0,0,0},
			up={0,1,0},
			fovy=45,
			projection=rl.cameraProjection.PERSPECTIVE
		}
	end

	self.cull_mode = 0
	self.wire_mode = false
	
	self.tex_mode = 0
	rl.setShaderValue(self.gfx_shader, self.tex_mode_loc, &self.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)
	
	self.fog_mode = 0
	self.fog_start = 700.0
	self.fog_end = 1000.0
	self.fog_color = {1.0, 1.0, 1.0, 1.0}
	rl.setShaderValue(self.gfx_shader, self.fog_mode_loc, &self.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.fog_start_loc, &self.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_end_loc, &self.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_color_loc, &self.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)
	
	self:texture(0, 0, 64, 64)

	self.viewport_w = GPU_VSCREEN_W
	self.viewport_h = GPU_VSCREEN_H
	self.proj_matrix_count = 0
	self.view_matrix_count = 0
end

function GPU:init(): void
	-- TODO: check window dpi scale and recreate window with correct flag
	rl.setConfigFlags(rl.configFlags.VSYNC_HINT | rl.configFlags.WINDOW_HIGHDPI) -- enable vsync and HighDPI
	rl.setTraceLogLevel(rl.traceLogLevel.ERROR) -- only log errors

	rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
	rl.setTargetFPS(30)

	rl.setExitKey(rl.keyboardKey.NULL)

	self.gfx_rendertex = rl.loadRenderTexture(GPU_VSCREEN_W, GPU_VSCREEN_H)

	local img: rl.image = rl.loadImage("assets/test.png")
	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	memory.copy(&self.tmem, img.data, GPU_TMEM_SIZE * #rl.color)
	self.gfx_texture = rl.loadTextureFromImage(img)
	rl.unloadImage(img)

	self.gfx_font_texture = rl.loadTexture("assets/font.png")
	
	self.gfx_shader = rl.loadShader(nilptr, "assets/shader.fs")
	
	self.tex_mode_loc = rl.getShaderLocation(self.gfx_shader, "texMode")
	self.tex_x_loc = rl.getShaderLocation(self.gfx_shader, "texX")
	self.tex_y_loc = rl.getShaderLocation(self.gfx_shader, "texY")
	self.tex_w_loc = rl.getShaderLocation(self.gfx_shader, "texW")
	self.tex_h_loc = rl.getShaderLocation(self.gfx_shader, "texH")
	self.fog_mode_loc = rl.getShaderLocation(self.gfx_shader, "fogMode")
	self.fog_start_loc = rl.getShaderLocation(self.gfx_shader, "fogStart")
	self.fog_end_loc = rl.getShaderLocation(self.gfx_shader, "fogEnd")
	self.fog_color_loc = rl.getShaderLocation(self.gfx_shader, "fogColor")

	self:resetGPU()
end

function GPU:cleanup(): void
	rl.unloadShader(self.gfx_shader)
	rl.unloadTexture(self.gfx_font_texture)
	rl.unloadTexture(self.gfx_texture)
	rl.unloadRenderTexture(self.gfx_rendertex)

	rl.closeWindow()
end
