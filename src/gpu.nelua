require("string")

require("definitions")
require("util")
require("textures")

-- GLFW function used to load OpenGL function pointers
local function glfwGetProcAddress(procname: cstring): function(): void <cimport> end

-- OpenGL constants
local GL_TEXTURE_2D <comptime> = 0x0DE1
local GL_DEPTH24_STENCIL8 <comptime> = 0x88F0
local GL_DEPTH_STENCIL <comptime> = 0x84F9
local GL_UNSIGNED_INT_24_8 <comptime> = 0x84FA
local GL_FRAMEBUFFER <comptime> = 0x8D40
local GL_DEPTH_STENCIL_ATTACHMENT <comptime> = 0x821A

local GL_STENCIL_TEST <comptime> = 0xB90

local GL_COLOR_BUFFER_BIT <comptime> = 0x00004000
local GL_DEPTH_BUFFER_BIT <comptime> = 0x00000100
local GL_STENCIL_BUFFER_BIT <comptime> = 0x00000400

local GL_FRONT <comptime> = 0x404
local GL_BACK <comptime> = 0x405
local GL_FRONT_AND_BACK <comptime> = 0x408

local GL_POINT <comptime> = 0x1B00
local GL_LINE <comptime> = 0x1B01
local GL_FILL <comptime> = 0x1B02

local GL_NEVER <comptime> = 0x200
local GL_LESS <comptime> = 0x201
local GL_EQUAL <comptime> = 0x202
local GL_LEQUAL <comptime> = 0x203
local GL_GREATER <comptime> = 0x204
local GL_NOTEQUAL <comptime> = 0x205
local GL_GEQUAL <comptime> = 0x206
local GL_ALWAYS <comptime> = 0x207

local GL_ZERO <comptime> = 0
local GL_KEEP <comptime> = 0x1E00
local GL_REPLACE <comptime> = 0x1E01
local GL_INCR <comptime> = 0x1E02
local GL_INCR_WRAP <comptime> = 0x8507
local GL_DECR <comptime> = 0x1E03
local GL_DECR_WRAP <comptime> = 0x8508
local GL_INVERT <comptime> = 0x150A

-- OpenGL function pointers
local glClear: function(cuint): void
local glClearColor: function(float32, float32, float32, float32): void
local glClearDepth: function(float64): void
local glClearStencil: function(cint): void
local glDepthFunc: function(cuint): void
local glEnable: function(cint): void
local glDisable: function(cint): void
local glColorMask: function(cint, cint, cint, cint): void
local glStencilMaskSeparate: function(cuint, cuint): void
local glStencilFuncSeparate: function(cuint, cuint, cint, cuint): void
local glStencilOpSeparate: function(cuint, cuint, cuint, cuint): void
local glPolygonMode: function(cuint, cuint): void
local glGenTextures: function(cint, *cuint): void
local glBindTexture: function(cuint, cuint): void
local glTexImage2D: function(cuint, cint, cint, cint, cint, cint, cuint, cuint, pointer): void
local glBindFramebuffer: function(cuint, cuint): void
local glFramebufferTexture2D: function(cuint, cuint, cuint, cuint, cint): void
local glDeleteTextures: function(cint, *cuint): void
local glDeleteFramebuffers: function(cint, *cuint): void

local GPU_VERT_SRC <const> = [[
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
//in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec2 fragTexCoord;
out vec4 fragColor;

#define MAX_LIGHTS 8
#define LIGHT_POINT 0
#define LIGHT_DIRECTIONAL 1

struct Light {
	int enabled;
	int type;
	float radius;
	vec3 color;
	vec3 position;
	vec3 direction;
};

// custom uniforms
uniform int lightingMode;
uniform float ambientFactor;
uniform vec3 ambientColor;
uniform Light lights[MAX_LIGHTS];

vec4 calculateLighting() {
	// when lighting is enabled, use the vertex color xyz values as the normal
	vec3 rawNormal = vertexColor.xyz;

	// get vertex in world space
	vec3 vertex = vec3(matModel * vec4(vertexPosition, 1.0f));

	// get normal in world space?
	vec3 normal = normalize(vec3(matNormal * vec4(rawNormal, 1.0f)));

	vec3 lightDirection;
	float diffuseFactor;
	float attenuation;
	vec3 diffuseColor = vec3(0.0f);
	vec3 lightPos;

	for (int i = 0; i < MAX_LIGHTS; i++) {
		if (lights[i].enabled == 1) {
			lightPos = lights[i].position;

			if (lights[i].type == LIGHT_POINT) {
				// get direction to light
				lightDirection = normalize(lightPos - vertex);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				// get attenuation based on light radius 
				attenuation = smoothstep(lights[i].radius, 0.0f, length(lightPos - vertex));
	
				diffuseColor += lights[i].color * (diffuseFactor * attenuation);
			}
			else {
				// get direction of light
				lightDirection = normalize(-lights[i].direction);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				diffuseColor += lights[i].color * diffuseFactor;
			}
		}
	}

	// get ambient color
	vec3 ambientColorFinal = ambientFactor * ambientColor;

	//return min(vec4(diffuseColor + ambientColorFinal, 1.0f), vec4(1.0));
	return vec4(diffuseColor + ambientColorFinal, 1.0f);
}

void main()
{
	fragTexCoord = vertexTexCoord;
	
	if (lightingMode == 0) {
		fragColor = vertexColor;
	}
	else {
		fragColor = calculateLighting();
	}

	// calculate final vertex position
	gl_Position = mvp * vec4(vertexPosition, 1.0f);
}
]]

local GPU_FRAG_SRC <const> = [[
#version 330

// built-in values:
in vec2 fragTexCoord; // uv
in vec4 fragColor;    // vertex color

out vec4 finalColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// custom uniforms:
uniform int texMode;
uniform int texX;
uniform int texY;
uniform int texW;
uniform int texH;

uniform int fogMode;
uniform float fogStart;
uniform float fogEnd;
uniform vec4 fogColor;

vec4 getTexColor(vec2 coord) {
	// create vectors
	vec2 tMin = vec2(float(texX), float(texY));
	vec2 tMax = vec2(float(texX + texW), float((texY) + texH));
	vec2 tSize = vec2(1024.0f, 1024.0f);

	// get mapped uv coords
	vec2 mappedCoord = mix(tMin, tMax, coord) / tSize;
	
	// sample color from texture
	vec4 rawColor = texture(texture0, mappedCoord) * fragColor;

	return rawColor;
}

void main()
{
	vec4 rawColor;

	if (texMode == 0) {
		rawColor = getTexColor(mod(fragTexCoord, vec2(1.0f, 1.0f)));
	}
	else if (texMode == 1) {
		rawColor = getTexColor(clamp(fragTexCoord, vec2(0.0f, 0.0f), vec2(0.99f, 0.99f)));
	}
	else {
		rawColor = vec4(1.0f, 1.0f, 1.0f, 1.0f) * fragColor;
	}

	if (rawColor.a == 0) {
		discard;
	}

	if (fogMode == 1) {
		// calculate fog
		float dist = (gl_FragCoord.z / gl_FragCoord.w);
		float fogFactor;
		if (fogStart == fogEnd) {
			fogFactor = 1.0;
		}
		else {
			fogFactor = fogEnd - fogStart;
		}
		fogFactor = clamp((fogEnd - dist) / fogFactor, 0.0f, 1.0f);

		finalColor = mix(fogColor, rawColor, fogFactor);
	}
	else {
		finalColor = rawColor;
	}
}
]]

local GPU_CRT_FRAG_SRC <const> = [[
#version 330

// built-in values:
in vec2 fragTexCoord; // uv
in vec4 fragColor;    // vertex color

out vec4 finalColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// custom uniforms:
uniform float time;
uniform float brightness;
uniform float blur;
uniform float noise;
uniform int scanlines;

float makeScanlines(float x, float repeat, float modValue)
{
	x = floor(x * repeat);
	return mod(x, modValue);
}

// black magic pseudorandom function
float random(vec2 uv) {
	return fract(sin(dot(uv, vec2(12.9898f, 78.233f))) * 43758.5453f);
}

void main()
{
	// get pixel and apply brightness
	vec2 screenUV = fragTexCoord;
	vec3 color = texture(texture0, screenUV).rgb * (1.0f - brightness * 0.5);

	// apply blur (ghosting)
	vec2 pixelSize = vec2(1.0f / 640.0f, 1.0f / 360.0f);
	color += texture(texture0, screenUV - vec2(pixelSize.x * blur, 0.0f)).rgb; // left pixel
	color += texture(texture0, screenUV + vec2(pixelSize.x * blur, 0.0f)).rgb; // right pixel
	color *= brightness * 0.5f; // prevent over-exposure

	// apply white noise
	vec2 noisePixel = vec2(floor((screenUV.x / pixelSize.x) / 3.0f) * 3.0f, screenUV.y) - sin(fragTexCoord.yx * 3.14159f);
	float whiteNoise = random(
		noisePixel + vec2(
			sin(time * 3.14159f / 4.0f),
			cos(time * 3.14159f / 8.0f)
		)
	);
	color = mix(color, vec3(whiteNoise), noise);

	// apply scanlines
	if (scanlines == 1) {
		float lines = makeScanlines(fragTexCoord.y, 360.0f, 2.0f);
		color *= 0.8f + (lines * 0.2f); // if on a scanline, set the color to 80%
	}

	// return final color
	finalColor = vec4(color, 1.0f);
}
]]

local face_types: []cuint = {
	GL_FRONT,
	GL_BACK,
	GL_FRONT_AND_BACK
}
local comparison_functions: []cuint = {
	GL_LESS,
	GL_LEQUAL,
	GL_GREATER,
	GL_GEQUAL,
	GL_EQUAL,
	GL_NOTEQUAL,
	GL_ALWAYS,
	GL_NEVER
}
local blend_factors: []cint = {
	rlgl.ZERO,
	rlgl.ONE,
	rlgl.SRC_COLOR,
	rlgl.ONE_MINUS_SRC_COLOR,
	rlgl.DST_COLOR,
	rlgl.ONE_MINUS_DST_COLOR,
	rlgl.SRC_ALPHA,
	rlgl.ONE_MINUS_SRC_ALPHA,
	rlgl.DST_ALPHA,
	rlgl.ONE_MINUS_DST_ALPHA,
	rlgl.CONSTANT_COLOR,
	rlgl.ONE_MINUS_CONSTANT_COLOR,
	rlgl.CONSTANT_ALPHA,
	rlgl.ONE_MINUS_CONSTANT_ALPHA,
	rlgl.SRC_ALPHA_SATURATE
}
local blend_equations: []cint = {
	rlgl.FUNC_ADD,
	rlgl.FUNC_SUBTRACT,
	rlgl.FUNC_REVERSE_SUBTRACT,
	rlgl.MIN,
	rlgl.MAX
}
local stencil_actions: []cuint = {
	GL_KEEP,
	GL_REPLACE,
	GL_INCR,
	GL_INCR_WRAP,
	GL_DECR,
	GL_DECR_WRAP,
	GL_ZERO,
	GL_INVERT
}
local polygon_modes: []cuint = {
	GL_POINT,
	GL_LINE,
	GL_FILL
}
local src_rect: rl.rectangle = {0.0, 0.0, (@float32)(GPU_VSCREEN_W), -(@float32)(GPU_VSCREEN_H)}
local sub_dest_rect: rl.rectangle = {0.0, 0.0, (@float32)(GPU_VSCREEN_W), (@float32)(GPU_VSCREEN_H)}
local light_attrib_locs: [GPU_LIGHTS_COUNT][LightAttribute.COUNT]cint
local icon_table: [Icon.COUNT]rl.rectangle = {
	{198, 0, 12, 9}, -- STATE_CODE
	{210, 0, 12, 9}, -- STATE_TRACKER
	{222, 0, 12, 9}, -- STATE_MODEL
	{234, 0, 12, 9}, -- STATE_TEXTURE
	{198, 9, 12, 9}, -- TOOL_PENCIL
	{210, 9, 12, 9}, -- TOOL_LINE
	{222, 9, 12, 9}, -- TOOL_RECT
	{234, 9, 12, 9}, -- TOOL_ELIPSE
	{210, 18, 12, 9}, -- TOOL_BUCKET
	{198, 18, 12, 9}, -- TOOL_SELECT
}

local function loadOpenGLFunctions(): void
	glClear = (@function(cuint): void)(glfwGetProcAddress("glClear"))
	glClearColor = (@function(float32, float32, float32, float32): void)(glfwGetProcAddress("glClearColor"))
	glClearDepth = (@function(float64): void)(glfwGetProcAddress("glClearDepth"))
	glClearStencil = (@function(cint): void)(glfwGetProcAddress("glClearStencil"))
	glDepthFunc = (@function(cuint): void)(glfwGetProcAddress("glDepthFunc"))
	glEnable = (@function(cint): void)(glfwGetProcAddress("glEnable"))
	glDisable = (@function(cint): void)(glfwGetProcAddress("glDisable"))
	glColorMask = (@function(cint, cint, cint, cint): void)(glfwGetProcAddress("glColorMask"))
	glStencilMaskSeparate = (@function(cuint, cuint): void)(glfwGetProcAddress("glStencilMaskSeparate"))
	glStencilFuncSeparate = (@function(cuint, cuint, cint, cuint): void)(glfwGetProcAddress("glStencilFuncSeparate"))
	glStencilOpSeparate = (@function(cuint, cuint, cuint, cuint): void)(glfwGetProcAddress("glStencilOpSeparate"))
	glPolygonMode = (@function(cuint, cuint): void)(glfwGetProcAddress("glPolygonMode"))
	glGenTextures = (@function(cint, *cuint): void)(glfwGetProcAddress("glGenTextures"))
	glBindTexture = (@function(cuint, cuint): void)(glfwGetProcAddress("glBindTexture"))
	glTexImage2D = (@function(cuint, cint, cint, cint, cint, cint, cuint, cuint, pointer): void)(glfwGetProcAddress("glTexImage2D"))
	glBindFramebuffer = (@function(cuint, cuint): void)(glfwGetProcAddress("glBindFramebuffer"))
	glFramebufferTexture2D = (@function(cuint, cuint, cuint, cuint, cint): void)(glfwGetProcAddress("glFramebufferTexture2D"))
	glDeleteTextures = (@function(cint, *cuint): void)(glfwGetProcAddress("glDeleteTextures"))
	glDeleteFramebuffers = (@function(cint, *cuint): void)(glfwGetProcAddress("glDeleteFramebuffers"))
end

function GPU:flush(): void
	if self.enable_flush then
		-- get required matrices
		local matModel: rl.matrix = rlgl.getMatrixTransform()
		local matNormal: rl.matrix = rl.matrix.transpose(rl.matrix.invert(matModel))

		-- upload to vertex shader
		rl.setShaderValueMatrix(self.gfx_shader, self.mat_model_loc, matModel)
		rl.setShaderValueMatrix(self.gfx_shader, self.mat_normal_loc, matNormal)

		rlgl.drawRenderBatchActive()
	end
end

function GPU:clearColor(col: uint32): void
	local fr: float32 = (@float32)(col >> 24) / 255.0
	local fg: float32 = (@float32)((col & 0xFF0000) >> 16) / 255.0
	local fb: float32 = (@float32)((col & 0x00FF00) >> 8) / 255.0
	local fa: float32 = (@float32)(col & 0xFF) / 255.0

	glClearColor(fr, fg, fb, fa)
end

function GPU:clearDepth(depth: float64): void
	glClearDepth(depth)
end

function GPU:clearStencil(stencil: int32): void
	glClearStencil(stencil)
end

function GPU:clear(flags: uint32): void
	local glflags: cint = 0

	if flags & GPU_CLEAR_COLOR ~= 0 then
		glflags = glflags | GL_COLOR_BUFFER_BIT
	end
	if flags & GPU_CLEAR_DEPTH ~= 0 then
		glflags = glflags | GL_DEPTH_BUFFER_BIT
	end
	if flags & GPU_CLEAR_STENCIL ~= 0 then
		glflags = glflags | GL_STENCIL_BUFFER_BIT
	end
	
	glClear(glflags)
end

function GPU:depthTest(enable: boolean): void
	self:flush()

	if enable then
		rlgl.enableDepthTest()
	else
		rlgl.disableDepthTest()
	end
end

function GPU:depthMask(enable: boolean): void
	self:flush()

	if enable then
		rlgl.enableDepthMask()
	else
		rlgl.disableDepthMask()
	end
end

function GPU:cullMode(mode: uint32): void
	self:flush()

	switch mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		case 2 then
			rlgl.disableBackfaceCulling()
	end
end

function GPU:polygonMode(mode: uint32): void
	self:flush()

	glPolygonMode(
		GL_FRONT_AND_BACK,
		polygon_modes[mode]
	)
end

function GPU:scissorMode(enable: boolean): void
	self:flush()

	if enable then
		rlgl.enableScissorTest()
	else
		rlgl.disableScissorTest()
	end
end

function GPU:camera2D(id: integer): void
	-- values to get from system camera/SYSMEM
	local raycam: rl.camera2D
	local viewport_w: int32
	local viewport_h: int32

	if id >= 0 then
		local cam2d: *EVMCam2D = &self.cameras2D[id]

		raycam.offset = {
			util.peekF(&cam2d.offset_x0),
			util.peekF(&cam2d.offset_y0)
		}
		raycam.target = {
			util.peekF(&cam2d.target_x0),
			util.peekF(&cam2d.target_y0)
		}
		raycam.rotation = util.peekF(&cam2d.rotation0)
		raycam.zoom = util.peekF(&cam2d.zoom0)

		viewport_w = math.clamp(util.peekI(&self.render_state.viewport_width0), 1, GPU_VSCREEN_W)
		viewport_h = math.clamp(util.peekI(&self.render_state.viewport_height0), 1, GPU_VSCREEN_H)
	else
		raycam = self.system_cam2d

		viewport_w = self.system_viewport_w
		viewport_h = self.system_viewport_h
	end

	-- this takes parts of raylib's beginTextureMode() and beginMode2D().
	-- we want a 2D orthographic projection, with a modelview configured to the 2D camera

	rlgl.drawRenderBatchActive()
	
	rlgl.matrixMode(rlgl.PROJECTION)
	rlgl.loadIdentity()
	rlgl.ortho(0.0, (float64)(viewport_w), (float64)(viewport_h), 0.0, 0.0, 1.0)
	
	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	rl.beginMode2D(raycam)

	self:depthTest(false)
	
	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:camera3D(id: int32): void
	-- values to get from system camera/SYSMEM
	local position: rl.vector3
	local target: rl.vector3
	local up: rl.vector3
	local fov: float32
	local projection: int32
	local viewport_w: int32
	local viewport_h: int32

	if id >= 0 then
		local cam3d: *EVMCam3D = &self.cameras3D[id]

		position = {
			util.peekF(&cam3d.position_x0),
			util.peekF(&cam3d.position_y0),
			util.peekF(&cam3d.position_z0)
		}
		target = {
			util.peekF(&cam3d.target_x0),
			util.peekF(&cam3d.target_y0),
			util.peekF(&cam3d.target_z0)
		}
		up = {
			util.peekF(&cam3d.up_x0),
			util.peekF(&cam3d.up_y0),
			util.peekF(&cam3d.up_z0)
		}
		fov = util.peekF(&cam3d.fov0)
		projection = util.peekI(&cam3d.projection0)

		viewport_w = math.clamp(util.peekI(&self.render_state.viewport_width0), 1, GPU_VSCREEN_W)
		viewport_h = math.clamp(util.peekI(&self.render_state.viewport_height0), 1, GPU_VSCREEN_H)
	else
		position = self.system_cam3d.position
		target = self.system_cam3d.target
		up = self.system_cam3d.up
		fov = self.system_cam3d.fovy
		projection = self.system_cam3d.projection

		viewport_w = self.system_viewport_w
		viewport_h = self.system_viewport_h
	end

	-- copy Raylib's BeginMode3D(),
	-- but we don't need to push a new projection matrix

	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
    rlgl.loadIdentity()

	local aspect: float32 = (@float32)(viewport_w) / (@float32)(viewport_h)

	-- 0.01 is the near clipping value
	-- 1000.0 is the far clipping value
	-- TODO: allow setting near/far?
	if projection == rl.cameraProjection.PERSPECTIVE then
		local top: float64 = 0.01 * math.tan(fov * 0.5 * (math.pi / 180.0))
		local right: float64 = top * aspect

		rlgl.frustum(-right, right, -top, top, 0.01, 1000.0)
	else
		local top: float64 = fov / 2.0
		local right: float64 = top * aspect

		rlgl.ortho(-right, right, -top, top, 0.01, 1000.0)
	end

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	local mat_view: rl.matrix = rl.matrix.lookAt(position, target, up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	self:depthTest(true) -- enable depth testing for 3D

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:beginMesh(mode: uint32): void
	switch mode do
		case GPU_LINES then
			self.triangle_mode = false
			mode = rlgl.LINES
		case GPU_TRIANGLES then
			self.triangle_mode = true
			self.triangle_vert_index = 0
			mode = rlgl.QUADS
		case GPU_QUADS then
			self.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(self.gfx_shader)

	rlgl.setTexture(self.gfx_texture.id)
	
	rlgl.begin(mode)
end

function GPU:beginMeshWithTexture(mode: uint32, tex_id: cint): void
	switch mode do
		case GPU_LINES then
			self.triangle_mode = false
			mode = rlgl.LINES
		case GPU_TRIANGLES then
			self.triangle_mode = true
			self.triangle_vert_index = 0
			mode = rlgl.QUADS
		case GPU_QUADS then
			self.triangle_mode = false
			mode = rlgl.QUADS
	end

	rlgl.setTexture(tex_id)
	
	rlgl.begin(mode)
end

function GPU:endMesh(): void
	rlgl.ending()

	rl.endShaderMode()
end

function GPU:endMeshWithTexture(): void
	rlgl.ending()

	rlgl.setTexture(0)
end

function GPU:matrixMode(mode: uint32): void
	switch mode do
		case GPU_PROJECTION then
			rlgl.matrixMode(rlgl.PROJECTION)
			self.matrix_mode = rlgl.PROJECTION
		case GPU_MODELVIEW then
			rlgl.matrixMode(rlgl.MODELVIEW)
			self.matrix_mode = rlgl.MODELVIEW
	end
end

function GPU:vertex(v: rl.vector3): void
	rlgl.vertex3f(v.x, v.y, v.z)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex3f(v.x, v.y, v.z)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertex2D(v: rl.vector2): void
	rlgl.vertex2f(v.x, v.y)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex2f(v.x, v.y)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertNormal(v: rl.vector3): void
	-- only set vertex "normal" if lighting is enabled
	if self.render_state.flags_tmccs0fl & GPU_LIGHTING_BIT == 0 then
		return
	end

	rlgl.color3f(v.x, v.y, v.z)
end

function GPU:vertUV(v: rl.vector2): void
	rlgl.texCoord2f(v.x, v.y)
end

function GPU:vertColor(col: uint32): void
	-- only set vertex color if lighting is disabled
	if self.render_state.flags_tmccs0fl & GPU_LIGHTING_BIT ~= 0 then
		return
	end

	local r: cuchar = (@cuchar)(col >> 24)
	local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
	local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
	local a: cuchar = (@cuchar)(col & 0xFF)
	
	rlgl.color4ub(r, g, b, a)
end

function GPU:drawChar2D(c: uint8, x: *int32, y: int32, color: rl.color): void
	local fx: float32 = (@float32)($x)
	local fy: float32 = (@float32)(y)

	if c < ' '_u8 then
		c = '?'_u8
		$x = $x + 6
	elseif c == ' '_u8 then
		$x = $x + 6
		return
	elseif c == '\t'_u8 then
		$x = $x + 12 -- tabs = 2 spaces
		return
	else
		$x = $x + 6
	end

	if fx <= -6.0 or y <= -9.0 or color.a == 0 then
		return
	end

	local srcx: float32 = (@float32)((c %%% 32) * 6)
	local srcy: float32 = (@float32)((c /// 32) * 9)

	local src_rect: rl.rectangle = {srcx, srcy, 6.0, 9.0}
	local dest_rect: rl.rectangle = {fx, fy, 6.0, 9.0}

	rl.drawTexturePro(self.gfx_ui_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, color)
end

-- print2D function for host program, doesn't do formatting
function GPU:print2D(x: int32, y: int32, col: uint32, text: string): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local i: uinteger = 1
	while i <= #text do
		local c: uint8

		if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
			-- we're off screen, no need to render
			return
		end

		c = text[i]
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end
end

function GPU:measureInt(value: int32): int32
	if value == 0 then
		return 1
	end
	
	local count: int32 = 0
	local bvalue: int64
	local negative: boolean = value < 0
	if negative then
		bvalue = -(@int64)(value)
	else
		bvalue = (@int64)(value)
	end

	while bvalue ~= 0 do
		bvalue = bvalue /// 10
		count = count + 1
	end
	
	if negative then
		count = count + 1
	end

	return count
end

function GPU:printInt2D(x: int32, y: int32, col: uint32, value: int32, out_char_count: *int32): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local buffer: [11]uint8 -- -2147483648 to 2147483647, 11 chars
	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	-- create string
	local buffer_index: uint8 = 10
	if value == 0 then
		buffer[10] = '0'_u8
		goto DRAW_STRING
	end

	local bvalue: int64
	local negative: boolean = value < 0
	if negative then
		bvalue = -(@int64)(value)
	else
		bvalue = (@int64)(value)
	end

	while bvalue ~= 0 do
		buffer[buffer_index] = '0'_u8 + (@uint8)(bvalue %%% 10)
		buffer_index = buffer_index - 1
		bvalue = bvalue /// 10
	end

	if negative then
		buffer[buffer_index] = '-'_u8
	else
		buffer_index = buffer_index + 1
	end

	::DRAW_STRING::

	if out_char_count ~= nilptr then
		$out_char_count = (10 - buffer_index) + 1
	end

	while buffer_index < 11 do
		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end

		self:drawChar2D(buffer[buffer_index], &cur_x, y, ray_col)

		buffer_index = buffer_index + 1
	end
end

-- print2D function for host program, doesn't do formatting
function GPU:printCString2D(x: int32, y: int32, col: uint32, ctext: cstring): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local text: *[0]cchar = (@*[0]cchar)(ctext)
	local i: uinteger = 0
	local c: cchar = text[i]
	while c ~= '\0'_u8 do
		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
		c = text[i]
	end
end

-- printHexNibble2D function for host program, doesn't do formatting
function GPU:printHexNibble2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local nibble: uint8 = val & 0xF
	if nibble < 0xA then
		nibble = '0'_u8 + nibble
	else
		nibble = 'A'_u8 + (nibble - 0xA)
	end

	self:drawChar2D(nibble, &cur_x, y, ray_col)
end

-- printHexByte2D function for host program, doesn't do formatting
function GPU:printHexByte2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local msn: uint8 = val >> 4
	if msn < 0xA then
		msn = '0'_u8 + msn
	else
		msn = 'A'_u8 + (msn - 0xA)
	end

	self:drawChar2D(msn, &cur_x, y, ray_col)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local lsn: uint8 = val & 0xF
	if lsn < 0xA then
		lsn = '0'_u8 + lsn
	else
		lsn = 'A'_u8 + (lsn - 0xA)
	end

	self:drawChar2D(lsn, &cur_x, y, ray_col)
end

function GPU:drawIcon2D(x: int32, y: int32, col: uint32, icon_index: uint32): void
	local icon_src_rect: rl.rectangle = icon_table[icon_index]
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF)
	}

	local dest_rect: rl.rectangle = {(@float32)(x), (@float32)(y), icon_src_rect.width, icon_src_rect.height}

	rl.drawTexturePro(self.gfx_ui_texture, icon_src_rect, dest_rect, {0.0, 0.0}, 0.0, ray_col)
end

function GPU:drawRect2D(x: int32, y: int32, w: int32, h: int32, col: uint32): void
	local fx0: float32 = (@float32)(x)
	local fy0: float32 = (@float32)(y)
	local fx1: float32 = (@float32)(x + w)
	local fy1: float32 = (@float32)(y + h)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF)
	}

	rl.drawRectangle(x, y, w, h, ray_col)
end

function GPU:drawRectLines2D(x: int32, y: int32, w: int32, h: int32, col: uint32): void
	local fx0: float32 = (@float32)(x)
	local fy0: float32 = (@float32)(y)
	local fx1: float32 = (@float32)(x + w)
	local fy1: float32 = (@float32)(y + h)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF)
	}

	rl.drawRectangleLines(x, y, w, h, ray_col)
end

function GPU:uploadMemVertex(index: uint32): void
	local word_index: uinteger = index * 9

	self:vertColor(self.model_data[word_index + 8].u)
	self:vertUV({self.model_data[word_index + 6].f, self.model_data[word_index + 7].f})
	self:vertNormal({self.model_data[word_index + 3].f, self.model_data[word_index + 4].f, self.model_data[word_index + 5].f})
	self:vertex({self.model_data[word_index].f, self.model_data[word_index + 1].f, self.model_data[word_index + 2].f})
end

function GPU:drawObjEx(mode: uint32, start: uint32, n: uint32): void
	if n == 0 then
		return
	end

	self:beginMesh(mode)
		switch mode do
			case GPU_LINES then
				for i = 0, < n do
					local line_start: uint32 = start + (i * 2)
					self:uploadMemVertex(line_start)
					self:uploadMemVertex(line_start + 1)
				end
			case GPU_TRIANGLES then
				for i = 0, < n do
					local tri_start: uint32 = start + (i * 3)
					self:uploadMemVertex(tri_start)
					self:uploadMemVertex(tri_start + 1)
					self:uploadMemVertex(tri_start + 2)
				end
			case GPU_QUADS then
				for i = 0, < n do
					-- get vertices
					local quad_start: uint32 = start + (i * 4)
					self:uploadMemVertex(quad_start)
					self:uploadMemVertex(quad_start + 1)
					self:uploadMemVertex(quad_start + 2)
					self:uploadMemVertex(quad_start + 3)
				end
		end
	self:endMesh()
end

function GPU:drawObj(id: uint32): void
	-- get objmap entry pointer
	--local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84 + (id * 12)])
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.objmap_data[id * 12])

	-- get mode
	local mode: uint32 = ((@uint32)(entry_ptr[0]) << 24) | ((@uint32)(entry_ptr[1]) << 16) | ((@uint32)(entry_ptr[2]) << 8) | (@uint32)(entry_ptr[3])

	if mode > GPU_QUADS then -- don't try to render collision data
		return
	end

	-- get start
	local start: uint32 = ((@uint32)(entry_ptr[4]) << 24) | ((@uint32)(entry_ptr[5]) << 16) | ((@uint32)(entry_ptr[6]) << 8) | (@uint32)(entry_ptr[7])

	-- get n
	local n: uint32 = ((@uint32)(entry_ptr[8]) << 24) | ((@uint32)(entry_ptr[9]) << 16) | ((@uint32)(entry_ptr[10]) << 8) | (@uint32)(entry_ptr[11])

	self:drawObjEx(mode, start, n)
end

function GPU:drawGFXTexture(srcx: int32, srcy: int32, srcw: int32, srch: int32, destx: int32, desty: int32, destw: int32, desth: int32): void
	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(self.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)
end

function GPU:textureMode(mode: uint32): void
	--self:flush()

	local cmode: cint = (@cint)(mode)
	rl.setShaderValue(self.gfx_shader, self.tex_mode_loc, &cmode, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:texture(x: int32, y: int32, w: int32, h: int32): void
	--self:flush()

	--self.tex_x = (@cint)(x)
	--self.tex_y = (@cint)(y)
	--self.tex_w = (@cint)(w)
	--self.tex_h = (@cint)(h)
	local cx: cint = (@cint)(x)
	local cy: cint = (@cint)(y)
	local cw: cint = (@cint)(w)
	local ch: cint = (@cint)(h)
	rl.setShaderValue(self.gfx_shader, self.tex_x_loc, &cx, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_y_loc, &cy, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_w_loc, &cw, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_h_loc, &ch, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:viewport(x: cint, y: cint, w: cint, h: cint, set_system: boolean): void
	--self:flush()?

	w = math.clamp(w, 1, GPU_VSCREEN_W)
	h = math.clamp(h, 1, GPU_VSCREEN_H)
	x = math.clamp(x, 0, GPU_VSCREEN_W - w)
	y = math.clamp(y, 0, GPU_VSCREEN_H - h)

	y = GPU_VSCREEN_H - (y + h) -- flip y
	rlgl.viewport(x, y, w, h)

	if set_system then
		self.system_viewport_w = w
		self.system_viewport_h = h
	end
end

function GPU:scissor(x: cint, y: cint, w: cint, h: cint): void
	--self:flush()?

	w = math.clamp(w, 1, GPU_VSCREEN_W)
	h = math.clamp(h, 1, GPU_VSCREEN_H)
	x = math.clamp(x, 0, GPU_VSCREEN_W - w)
	y = math.clamp(y, 0, GPU_VSCREEN_H - h)
	
	y = GPU_VSCREEN_H - (y + h) -- flip y
	rlgl.scissor(x, y, w, h)
end

function GPU:colorMask(mask: uint8): void
	self:flush()

	--self.color_mask = mask
	local r: cint = mask & 0b1000 ~= 0 and 1 or 0
	local g: cint = mask & 0b0100 ~= 0 and 1 or 0
	local b: cint = mask & 0b0010 ~= 0 and 1 or 0
	local a: cint = mask & 0b0001 ~= 0 and 1 or 0
	glColorMask(r, g, b, a)
end

function GPU:depthFunc(fn: uint32): void
	self:flush()

	--self.depth_function = fn
	glDepthFunc(comparison_functions[fn])
end

function GPU:blendMode(mode: uint32): void
	self:flush()

	--self.blend_mode = mode
	rlgl.setBlendMode(mode)
end

function GPU:blendFactors(src_factor: uint32, dest_factor: uint32, equation: uint32): void
	self:flush()

	--self.blend_src_rgb = src_factor
	--self.blend_dest_rgb = dest_factor
	--self.blend_src_alpha = src_factor
	--self.blend_dest_alpha = dest_factor
	--self.blend_eq_rgb = equation
	--self.blend_eq_alpha = equation
	rlgl.setBlendFactors(
		blend_factors[src_factor],
		blend_factors[dest_factor],
		blend_equations[equation]
	)
end

function GPU:blendFactorsEx(
	src_rgb_factor: uint32,
	dest_rgb_factor: uint32,
	src_alpha_factor: uint32,
	dest_alpha_factor: uint32,
	equation_rgb: uint32,
	equation_alpha: uint32): void
	self:flush()
	--self.blend_src_rgb = src_rgb_factor
	--self.blend_dest_rgb = dest_rgb_factor
	--self.blend_src_alpha = src_alpha_factor
	--self.blend_dest_alpha = dest_alpha_factor
	--self.blend_eq_rgb = equation_rgb
	--self.blend_eq_alpha = equation_alpha
	rlgl.setBlendFactorsSeparate(
		blend_factors[src_rgb_factor],
		blend_factors[dest_rgb_factor],
		blend_factors[src_alpha_factor],
		blend_factors[dest_alpha_factor],
		blend_equations[equation_rgb],
		blend_equations[equation_alpha]
	)
end

function GPU:stencilMode(mode: boolean): void
	self:flush()

	if mode then
		glEnable(GL_STENCIL_TEST)
	else
		glDisable(GL_STENCIL_TEST)
	end
	--self.stencil_mode = mode
end

function GPU:stencilMask(face: uint32, mask: uint32): void
	self:flush()

	glStencilMaskSeparate(
		face_types[face],
		mask
	)
end

function GPU:stencilFunc(face: uint32, func: uint32, ref: int32, mask: uint32): void
	self:flush()

	glStencilFuncSeparate(
		face_types[face],
		comparison_functions[func],
		ref,
		mask
	)
end

function GPU:stencilOp(face: uint32, sfail: uint32, dpfail: uint32, dppass: uint32): void
	self:flush()

	glStencilOpSeparate(
		face_types[face],
		stencil_actions[sfail],
		stencil_actions[dpfail],
		stencil_actions[dppass]
	)
end

function GPU:fogMode(enabled: boolean): void
	--self:flush()

	local cmode: cint = enabled and 1 or 0
	rl.setShaderValue(self.gfx_shader, self.fog_mode_loc, &cmode, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:fogStart(start: float32): void
	--self:flush()

	rl.setShaderValue(self.gfx_shader, self.fog_start_loc, &start, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:fogEnd(fend: float32): void
	--self:flush()

	rl.setShaderValue(self.gfx_shader, self.fog_end_loc, &fend, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:fogColor(col: uint32): void
	--self:flush()

	local ccolor: rl.vector4 = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0,
		(@float32)(col & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, self.fog_color_loc, &ccolor, rl.shaderUniformDataType.UNIFORM_VEC4)
end

function GPU:lightingMode(enabled: boolean): void
	--self:flush()

	local cmode: cint = enabled and 1 or 0
	rl.setShaderValue(self.gfx_shader, self.lighting_mode_loc, &cmode, rl.shaderUniformDataType.UNIFORM_INT)

	if enabled then
		self.render_state.flags_tmccs0fl = self.render_state.flags_tmccs0fl | GPU_LIGHTING_BIT
	else
		self.render_state.flags_tmccs0fl = self.render_state.flags_tmccs0fl & ~GPU_LIGHTING_BIT
	end
end

function GPU:ambientFactor(factor: float32): void
	--self:flush()

	--self.ambient_factor = factor / 100.0
	local cfactor: float32 = factor / 100.0
	rl.setShaderValue(self.gfx_shader, self.ambient_factor_loc, &cfactor, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:ambientColor(col: uint32): void
	--self:flush()

	local ccolor: rl.vector3 = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, self.ambient_color_loc, &ccolor, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:lightEnabled(id: uint32, enabled: boolean): void
	--self.lights[id].enabled = (enabled ~= 0) and 1 or 0
	local cenabled: cint = enabled and 1 or 0
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.ENABLED], &cenabled, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:lightType(id: uint32, light_type: uint32): void
	--self.lights[id].light_type = (@cint)(light_type)
	local ctype: cint = (@cint)(light_type)
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.TYPE], &ctype, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:lightRadius(id: uint32, radius: float32): void
	--self.lights[id].radius = radius
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.RADIUS], &radius, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:lightColor(id: uint32, col: uint32): void
	local ccolor: rl.vector3 = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.COLOR], &ccolor, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:lightPosition(id: uint32, pos: rl.vector3): void
	--self.lights[id].position = pos
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.POSITION], &pos, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:lightDirection(id: uint32, dir: rl.vector3): void
	--self.lights[id].direction = dir
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.DIRECTION], &dir, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:updateLights(): void
	for i = 0, < GPU_LIGHTS_COUNT do
		local l: *EVMLight = &self.lights[i]

		local cenabled: cint = util.peekI(&l.enabled0) ~= 0 and 1 or 0
		local ctype: cint = (@cint)(util.peekI(&l.type0))
		local radius: float32 = util.peekF(&l.radius0)
		local col: uint32 = util.peekU(&l.color_r)
		local ccolor: rl.vector3 = {
			(@float32)(col >> 24) / 255.0,
			(@float32)((col >> 16) & 0xFF) / 255.0,
			(@float32)((col >> 8) & 0xFF) / 255.0
		}
		local pos: rl.vector3 = {
			util.peekF(&l.position_x0),
			util.peekF(&l.position_y0),
			util.peekF(&l.position_z0)
		}
		local dir: rl.vector3 = {
			util.peekF(&l.direction_x0),
			util.peekF(&l.direction_y0),
			util.peekF(&l.direction_z0)
		}
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.ENABLED], &cenabled, rl.shaderUniformDataType.UNIFORM_INT)
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.TYPE], &ctype, rl.shaderUniformDataType.UNIFORM_INT)
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.RADIUS], &radius, rl.shaderUniformDataType.UNIFORM_FLOAT)
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.COLOR], &ccolor, rl.shaderUniformDataType.UNIFORM_VEC3)
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.POSITION], &pos, rl.shaderUniformDataType.UNIFORM_VEC3)
		rl.setShaderValue(self.gfx_shader, light_attrib_locs[i][LightAttribute.DIRECTION], &dir, rl.shaderUniformDataType.UNIFORM_VEC3)
	end
end

function GPU:setPixel(x: int32, y: int32, col: uint32): void
	if x < 0 or x > 1023 or y < 0 or y > 1023 then
		return
	end

	self.texture_data[y * 1024 + x] = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF)
	}
	self.update_tex = true
end

function GPU:getPixel(x: int32, y: int32): uint32
	if x < 0 or x > 1023 or y < 0 or y > 1023 then
		return 0
	end

	local ray_col: rl.color = self.texture_data[y * 1024 + x]
	local r: uint32 = (@uint32)(ray_col.r)
	local g: uint32 = (@uint32)(ray_col.g)
	local b: uint32 = (@uint32)(ray_col.b)
	local a: uint32 = (@uint32)(ray_col.a)
	
	return (r << 24) | (g << 16) | (b << 8) | a
end

function GPU:pixelLine(x: int32, y: int32, x2: int32, y2: int32, color: uint32): void
	local w: int32 = x2 - x
	local h: int32 = y2 - y
	local dx1: int32 = 0
	local dy1: int32 = 0
	local dx2: int32 = 0
	local dy2: int32 = 0

	if w < 0 then
		dx1 = -1
	elseif w > 0 then
		dx1 = 1
	end
	if h < 0 then
		dy1 = -1
	elseif h > 0 then
		dy1 = 1
	end
	if w < 0 then
		dx2 = -1
	elseif w > 0 then
		dx2 = 1
	end
	
	local longest: int32 = math.abs(w)
	local shortest: int32 = math.abs(h)
	if not (longest > shortest) then
		longest = math.abs(h)
		shortest = math.abs(w)

		if h < 0 then
			dy2 = -1
		elseif h > 0 then
			dy2 = 1
		end

		dx2 = 0
	end

	local numerator: int32 = longest >> 1
	for i = 0, <= longest do
		self:setPixel(x, y, color)

		numerator = numerator + shortest

		if not (numerator < longest) then
			numerator = numerator - longest
			x = x + dx1
			y = y + dy1
		else
			x = x + dx2
			y = y + dy2
		end
	end
end

function GPU:getObjMapEntryValues(id: uint32): (uint32, uint32, uint32)
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.objmap_data[id * 12])
	local mode: uint32 = util.peekU(&entry_ptr[0])
	local start: uint32 = util.peekU(&entry_ptr[4])
	local n: uint32 = util.peekU(&entry_ptr[8])

	return mode, start, n
end

function GPU:setObjMapEntryValues(id: uint32, mode: uint32, start: uint32, n: uint32): void
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.objmap_data[id * 12])
	util.pokeU(&entry_ptr[0], mode)
	util.pokeU(&entry_ptr[4], start)
	util.pokeU(&entry_ptr[8], n)
end

function GPU:loadTexBank(bank: uint8): void
	local src: *[0]rl.color = &self.texbank_ptr[MEMORY_TEXMEM_SIZE_ELEMENTS * bank]
	memory.copy(&self.texmem, src, MEMORY_TEXMEM_SIZE_BYTES)
	self.update_tex = true
end

function GPU:loadObjBank(bank: uint8): void
	-- load objbank
	local src: *[0]IntFloat = &self.objbank_ptr[(MEMORY_OBJMEM_SIZE_ELEMENTS) * bank]
	memory.copy(&self.objmem, src, MEMORY_OBJMEM_SIZE_BYTES)

	-- load ompbank
	local objmap_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84])
	local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.ompbank_ptr[(MEMORY_OBJMAP_SIZE * bank)])
	memory.copy(objmap_ptr, bank_ptr, MEMORY_OBJMAP_SIZE)

	self.update_tex = true
end

function GPU:loadTextureData(
	bank_index: integer,
	src_x: int32,
	src_y: int32,
	src_w: int32,
	src_h: int32,
	dest_x: int32,
	dest_y: int32): void
	local bank_ptr: *[0]rl.color = (@*[0]rl.color)(&self.texbank_ptr[MEMORY_TEXMEM_SIZE_ELEMENTS * bank_index])
	local data: *[0]rl.color = (@*[0]rl.color)(core.image_to_import.data)

	for y = 0, < src_h do
		local read_y: int32 = src_y + y
		local write_y: int32 = dest_y + y
		for x = 0, < src_w do
			local read_x: int32 = src_x + x
			local write_x: int32 = dest_x + x
			bank_ptr[1024 * write_y + write_x] = data[core.image_to_import.width * read_y + read_x]
		end
	end
end

function GPU:loadModelData(bank_index: uint32, start_index: uint32): void
	local vertex_count: uint32
	local bank_ptr: *[0]IntFloat = &self.objbank_ptr[MEMORY_OBJMEM_SIZE_ELEMENTS * bank_index]

	for i = 0, < core.model_to_import.meshCount do
		local mesh: rl.mesh = (@*[0]rl.mesh)(core.model_to_import.meshes)[i]
		local posptr: *[0]float32 = (@*[0]float32)(mesh.vertices)
		local uvptr: *[0]float32 = (@*[0]float32)(mesh.texcoords)
		local colptr: *[0]cuchar = (@*[0]cuchar)(mesh.colors)
		local normptr: *[0]float32 = (@*[0]float32)(mesh.normals)
		local idxptr: *[0]cushort = (@*[0]cushort)(mesh.indices)
		
		if idxptr ~= nilptr then
			for j = 0, < mesh.triangleCount do
				for k = 0, < 3 do
					local idx: cushort = idxptr[j * 3 + k]
					local posindex: uinteger = idx * 3
					local uvindex: uinteger = idx * 2
					local colindex: uinteger = idx * 4
					
					local pos: rl.vector3 = {
						posptr[posindex],
						posptr[posindex + 1],
						posptr[posindex + 2]
					}
					
					local uv: rl.vector2 = {
						uvptr[uvindex],
						uvptr[uvindex + 1]
					}
					
					local col: uint32
					if colptr ~= nilptr then
						col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
					else
						col = 0xFFFFFFFF
					end
					
					local objmemindex: uinteger = (start_index + vertex_count) * 9
					bank_ptr[objmemindex].f = pos.x
					bank_ptr[objmemindex + 1].f = pos.y
					bank_ptr[objmemindex + 2].f = pos.z
					bank_ptr[objmemindex + 6].f = uv.x
					bank_ptr[objmemindex + 7].f = uv.y
					bank_ptr[objmemindex + 8].u = col

					vertex_count = vertex_count + 1
				end
			end
		else
			for j = 0, < mesh.vertexCount do
				local posindex: uinteger = j * 3
				local uvindex: uinteger = j * 2
				local colindex: uinteger = j * 4
				local normindex: uinteger = j * 3
				
				local pos: rl.vector3 = {
					posptr[posindex],
					posptr[posindex + 1],
					posptr[posindex + 2]
				}

				local norm: rl.vector3 = {
					normptr[normindex],
					normptr[normindex + 1],
					normptr[normindex + 2]
				}
				
				local uv: rl.vector2 = {
					uvptr[uvindex],
					uvptr[uvindex + 1]
				}
				
				local col: uint32
				if colptr ~= nilptr then
					col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
				else
					col = 0xFFFFFFFF
				end
				
				local objmemindex: uinteger = (start_index + vertex_count) * 9
				bank_ptr[objmemindex].f = pos.x
				bank_ptr[objmemindex + 1].f = pos.y
				bank_ptr[objmemindex + 2].f = pos.z

				bank_ptr[objmemindex + 3].f = norm.x
				bank_ptr[objmemindex + 4].f = norm.y
				bank_ptr[objmemindex + 5].f = norm.z

				bank_ptr[objmemindex + 6].f = uv.x
				bank_ptr[objmemindex + 7].f = uv.y
				bank_ptr[objmemindex + 8].u = col

				vertex_count = vertex_count + 1
			end
		end
	end
end

function GPU:resetMatrixStack(): void
	rlgl.matrixMode(rlgl.PROJECTION)

	while self.proj_matrix_count > 0 do
		rlgl.popMatrix()
		self.proj_matrix_count = self.proj_matrix_count - 1
	end

	rlgl.matrixMode(rlgl.MODELVIEW)

	while self.view_matrix_count > 0 do
		rlgl.popMatrix()
		self.view_matrix_count = self.view_matrix_count - 1
	end
end

function GPU:refreshScreenSize(): void
	local render_w: int32 = (@int32)(rl.getRenderWidth())
	local render_h: int32 = (@int32)(rl.getRenderHeight())
	local scale_x: int32 = render_w /// GPU_VSCREEN_W
	local scale_y: int32 = render_h /// GPU_VSCREEN_H
	local final_scale: int32
	
	if scale_x == scale_y then
		final_scale = scale_x
	else
		if scale_x < scale_y then
			final_scale = scale_x
		else
			final_scale = scale_y
		end
	end
	
	self.master_dest_rect.x = (@float32)((render_w /// 2) - ((final_scale * GPU_VSCREEN_W) /// 2))
	self.master_dest_rect.y = (@float32)((render_h /// 2) - ((final_scale * GPU_VSCREEN_H) /// 2))
	self.master_dest_rect.width = final_scale * (@float32)(GPU_VSCREEN_W)
	self.master_dest_rect.height = final_scale * (@float32)(GPU_VSCREEN_H)
	self.screen_w = (@int32)(self.master_dest_rect.width)
	self.screen_h = (@int32)(self.master_dest_rect.height)
end

function GPU:beginCurrentRenderTexture(): void
	rl.beginTextureMode(self.gfx_rendertextures[self.gfx_rendertexture_index])
end

function GPU:beginMasterRenderTexture(): void
	rl.beginTextureMode(self.gfx_master_rendertexture)
end

function GPU:endRenderTexture(): void
	rl.endTextureMode()
end

function GPU:drawCurrentRenderTexture(): void
	rl.drawTexturePro(self.gfx_rendertextures[self.gfx_rendertexture_index].texture, src_rect, sub_dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)
end

function GPU:drawMasterRenderTexture(): void
	rl.drawTexturePro(self.gfx_master_rendertexture.texture, src_rect, self.master_dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)
end

function GPU:useRenderTexture(index: uinteger): void
	rlgl.setTexture(self.gfx_rendertextures[index].texture.id)
end

function GPU:setRenderTexture(index: uinteger): void
	self.gfx_rendertexture_index = index
end

function GPU:setBankPointers(texbank_index: uint8, objbank_index: uint8): void
	self.current_texbank = texbank_index
	self.current_objbank = objbank_index

	if self.current_texbank == GPUBank.SYSTEM then
		self.texture_data = (@*[0]rl.color)(&self.texmem)
	else
		local index: uinteger = self.current_texbank - GPUBank.TEXBANK0
		self.texture_data = (@*[0]rl.color)(&self.texbank_ptr[MEMORY_TEXMEM_SIZE_ELEMENTS * index])
	end

	if self.current_objbank == GPUBank.SYSTEM then
		self.model_data = (@*[0]IntFloat)(&self.objmem)
		self.objmap_data = (@*[0]uint8)(&self.sysmem_ptr[84])
	else
		local index: uint64 = self.current_objbank - GPUBank.OBJBANK0
		self.model_data = (@*[0]IntFloat)(&self.objbank_ptr[MEMORY_OBJMEM_SIZE_ELEMENTS * index])
		self.objmap_data = (@*[0]uint8)(&self.ompbank_ptr[MEMORY_OBJMAP_SIZE * index])
	end
end

function GPU:updateTexture(): void
	rl.updateTexture(self.gfx_texture, self.texture_data)
	self.update_tex = false
end

function GPU:updateConfigFlags(): void
	local flags: cint = 0
	if core.config.vsync then
		flags = flags | rl.configFlags.VSYNC_HINT
	end
	if core.config.highdpi then
		flags = flags | rl.configFlags.WINDOW_HIGHDPI
	end

	rl.setWindowState(flags)--| rl.configFlags.WINDOW_RESIZABLE)
end

function GPU:updateCRTShader(): void
	local crt_brightness: float32 = 1.0
	local crt_blur: float32 = core.config.crt_blur and 0.265 or 0.0
	local crt_noise: float32 = core.config.crt_noise and 0.1 or 0.0
	local crt_scanlines: cint = core.config.crt_scanlines and 1 or 0

	rl.setShaderValue(self.crt_shader, self.crt_brightness_loc, &crt_brightness, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.crt_shader, self.crt_blur_loc, &crt_blur, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.crt_shader, self.crt_noise_loc, &crt_noise, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.crt_shader, self.crt_scanlines_loc, &crt_scanlines, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:enableRenderState(): void
	self.enable_flush = true
	self:flush()
	self.enable_flush = false

	self:clearColor(util.peekU(&self.render_state.clear_color_r))
	self:colorMask(self.render_state.flags_00ppcccc & GPU_COLOR_MASK_MASK)

	self:clearDepth(util.peekF(&self.render_state.clear_depth0))
	self:depthTest(self.render_state.flags_tmccs0fl & GPU_DEPTH_TEST_BIT ~= 0)
	self:depthMask(self.render_state.flags_tmccs0fl & GPU_DEPTH_MASK_BIT ~= 0)
	self:depthFunc(self.render_state.depth_function)
	
	self:clearStencil(self.render_state.clear_stencil)
	self:stencilMode(self.render_state.flags_tmccs0fl & GPU_STENCIL_BIT ~= 0)
	self:stencilMask(GPU_FRONT, self.render_state.stencil_mask_front)
	self:stencilMask(GPU_BACK, self.render_state.stencil_mask_back)
	self:stencilFunc(
		GPU_FRONT,
		self.render_state.stencil_functions >> 4,
		self.render_state.stencil_ref_front,
		self.render_state.stencil_func_mask_front
	)
	self:stencilFunc(
		GPU_BACK,
		self.render_state.stencil_functions & 0b1111,
		self.render_state.stencil_ref_back,
		self.render_state.stencil_func_mask_back
	)
	self:stencilOp(
		GPU_FRONT,
		self.render_state.stencil_sfails >> 4,
		self.render_state.stencil_dpfails >> 4,
		self.render_state.stencil_dppasses >> 4
	)
	self:stencilOp(
		GPU_BACK,
		self.render_state.stencil_sfails & 0b1111,
		self.render_state.stencil_dpfails & 0b1111,
		self.render_state.stencil_dppasses & 0b1111
	)
	
	self:cullMode((self.render_state.flags_tmccs0fl & GPU_CULL_MODE_MASK) >> 4)
	self:polygonMode(
		(self.render_state.flags_00ppcccc & GPU_POLYGON_MODE_MASK) >> 4
	)

	self:fogMode(self.render_state.flags_tmccs0fl & GPU_FOG_BIT ~= 0)
	self:fogStart(util.peekF(&self.render_state.fog_start0))
	self:fogEnd(util.peekF(&self.render_state.fog_end0))
	self:fogColor(util.peekU(&self.render_state.fog_color_r))

	self:lightingMode(self.render_state.flags_tmccs0fl & GPU_LIGHTING_BIT ~= 0)
	-- lights...

	self:ambientFactor(util.peekF(&self.render_state.ambient_factor0))
	self:ambientColor(util.peekU(&self.render_state.ambient_color_r))

	self:blendFactorsEx(
		self.render_state.rgb_factors >> 4,
		self.render_state.rgb_factors & 0xF,
		self.render_state.alpha_factors >> 4,
		self.render_state.alpha_factors & 0xF,
		self.render_state.blend_equations >> 4,
		self.render_state.blend_equations & 0xF
	)
	self:blendMode(self.render_state.flags_00sttbbb & GPU_BLEND_MODE_MASK)

	self:textureMode((self.render_state.flags_00sttbbb & GPU_TEXTURE_MODE_MASK) >> 3)
	self:texture(
		util.peekI(&self.render_state.texture_x0),
		util.peekI(&self.render_state.texture_y0),
		(@int32)(self.render_state.texture_width) + 1,
		(@int32)(self.render_state.texture_height) + 1
	)
	self:viewport(
		util.peekI(&self.render_state.viewport_x0),
		util.peekI(&self.render_state.viewport_y0),
		util.peekI(&self.render_state.viewport_width0),
		util.peekI(&self.render_state.viewport_height0),
		false
	)
	self:scissorMode(self.render_state.flags_00sttbbb & GPU_SCISSOR_BIT ~= 0)
	self:scissor(
		util.peekI(&self.render_state.scissor_x0),
		util.peekI(&self.render_state.scissor_y0),
		util.peekI(&self.render_state.scissor_width0),
		util.peekI(&self.render_state.scissor_height0)
	)

	self.enable_flush = true
end

function GPU:disableRenderState(): void
	self.enable_flush = true
	self:flush()
	self.enable_flush = false

	self:clearColor(GPU_BLACK)
	self:colorMask(GPU_COLOR_MASK_ALL)

	self:clearDepth(1.0)
	self:depthTest(true)
	self:depthMask(true)
	self:depthFunc(GPU_LEQUAL)
	
	self:clearStencil(0)
	self:stencilMode(false)
	self:stencilMask(GPU_FRONT_AND_BACK, 0xFF)
	self:stencilFunc(GPU_FRONT_AND_BACK, GPU_ALWAYS, 0, 0xFF)
	self:stencilOp(GPU_FRONT_AND_BACK, GPU_KEEP, GPU_KEEP, GPU_KEEP)
	
	self:cullMode(0)
	self:polygonMode(GPU_FILL)

	self:fogMode(false)
	self:fogStart(700.0)
	self:fogEnd(1000.0)
	self:fogColor(GPU_RED)

	self:lightingMode(false)
	-- lights...

	self:ambientFactor(0.0)
	self:ambientColor(GPU_RED)

	self:blendMode(0)

	self:textureMode(2)
	self:texture(0, 0, 64, 64)
	self:viewport(0, 0, GPU_VSCREEN_W, GPU_VSCREEN_H, true)
	self:scissorMode(false)

	self.enable_flush = true
end

function GPU:resetGPU(): void
	-- reset camera state
	memory.set(self.cameras3D, 0, MEMORY_CAMERAS3D_SIZE)
	memory.set(self.cameras2D, 0, MEMORY_CAMERAS2D_SIZE)
	for i = 0, < GPU_CAMERAS_COUNT do
		local cam3d: *EVMCam3D = &self.cameras3D[i]
		local cam2d: *EVMCam2D = &self.cameras2D[i]
		
		-- cam3d.position.z = 4.0
		util.pokeF(&cam3d.position_z0, 4.0)

		-- cam3d.up.y = 1.0
		util.pokeF(&cam3d.up_y0, 1.0)

		-- cam3d.fov = 45.0
		util.pokeF(&cam3d.fov0, 45.0)

		-- cam2d.zoom = 1.0
		util.pokeF(&cam2d.zoom0, 1.0)
	end

	-- reset light state
	memory.set(self.lights, 0, MEMORY_LIGHTS_SIZE)
	for i = 0, < GPU_LIGHTS_COUNT do
		local light: *EVMLight = &self.lights[i]

		-- light.direction.y = -1.0
		util.pokeF(&light.direction_y0, -1.0)
	end

	-- reset render state
	memory.set(self.render_state, 0, #RenderState) -- clear everything

	-- render state int values
	self.render_state.clear_color_a = 0xFF
	self.render_state.fog_color_a = 0xFF
	self.render_state.ambient_color_a = 0xFF
	util.pokeI(&self.render_state.viewport_width0, GPU_VSCREEN_W)
	util.pokeI(&self.render_state.viewport_height0, GPU_VSCREEN_H)
	util.pokeI(&self.render_state.scissor_width0, GPU_VSCREEN_W)
	util.pokeI(&self.render_state.scissor_height0, GPU_VSCREEN_H)

	-- render state float values
	util.pokeF(&self.render_state.clear_depth0, 1.0)
	util.pokeF(&self.render_state.fog_start0, 700.0)
	util.pokeF(&self.render_state.fog_end0, 1000.0)

	-- render state byte values
	self.render_state.flags_tmccs0fl = GPU_DEPTH_TEST_BIT | GPU_DEPTH_MASK_BIT
	self.render_state.flags_00ppcccc = 0b00100000 | GPU_COLOR_MASK_ALL -- fill polygon mode, full color mask
	self.render_state.rgb_factors = 0x67 -- SRC_ALPHA, ONE_MINUS_SRC_ALPHA
	self.render_state.alpha_factors = 0x67 -- SRC_ALPHA, ONE_MINUS_SRC_ALPHA
	self.render_state.stencil_functions = 0x66 -- ALWAYS, ALWAYS
	self.render_state.stencil_mask_front = 0xFF
	self.render_state.stencil_func_mask_front = 0xFF
	self.render_state.stencil_mask_back = 0xFF
	self.render_state.stencil_func_mask_back = 0xFF
	self.render_state.texture_width = 63
	self.render_state.texture_height = 63

	self.proj_matrix_count = 0
	self.view_matrix_count = 0
end

-- copy rayblib's loadRenderTexture(), but also attach a stencil texture
local function loadRenderTextureCustom(width: cint, height: cint): rl.renderTexture
	local target: rl.renderTexture

	target.id = rlgl.loadFramebuffer()

	if target.id > 0 then
		rlgl.enableFramebuffer(target.id)

		-- create color texture
		target.texture.id = rlgl.loadTexture(nilptr, width, height, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8, 1)
		target.texture.width = width
		target.texture.height = height
		target.texture.format = rl.pixelFormat.UNCOMPRESSED_R8G8B8A8
		target.texture.mipmaps = 1

		-- create depth+stencil texture manually
		glGenTextures(1, &target.depth.id)
		glBindTexture(GL_TEXTURE_2D, target.depth.id)
		glTexImage2D(
			GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, width, height, 0,
			GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, nilptr
		)
		glBindTexture(GL_TEXTURE_2D, 0)

		target.depth.width = width
		target.depth.height = height
		target.depth.format = 19 -- TODO: set to correct value (if any)
		target.depth.mipmaps = 1

		-- attach color texture to FBO
		rlgl.framebufferAttach(
			target.id,
			target.texture.id,
			rlgl.framebufferAttachType.COLOR_CHANNEL0,
			rlgl.framebufferAttachTextureType.TEXTURE2D,
			0
		)
		
		-- attach depth+stencil texture to FBO manually
		glBindFramebuffer(GL_FRAMEBUFFER, target.id)
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, target.depth.id, 0)
		glBindFramebuffer(GL_FRAMEBUFFER, 0)

		-- check if FBO is complete
		if rlgl.framebufferComplete(target.id) then
			rl.traceLog(rl.traceLogLevel.INFO, "FBO: [ID %i] Framebuffer object created successfully", target.id)
		end

		rlgl.disableFramebuffer()
	else
		rl.traceLog(rl.traceLogLevel.WARNING, "FBO: Framebuffer object can not be created")
	end

	return target
end

local function unloadRenderTextureCustom(target: rl.renderTexture): void
	if target.id > 0 then
		if target.texture.id > 0 then
			rlgl.unloadTexture(target.texture.id)
		end

		-- unload depth+stencil texture and framebuffer
		glBindFramebuffer(GL_FRAMEBUFFER, target.id)
		glDeleteTextures(1, &target.depth.id)
		glBindFramebuffer(GL_FRAMEBUFFER, 0)
		glDeleteFramebuffers(1, &target.id)

		rl.traceLog(rl.traceLogLevel.INFO, "FBO: [ID %i] Unloaded framebuffer from VRAM (GPU)", target.id)
	end
end

function GPU:init(sysmem_ptr: *[0]uint8, texbank_ptr: *[0]rl.color, objbank_ptr: *[0]IntFloat, ompbank_ptr: *[0]uint8): void
	self.sysmem_ptr = sysmem_ptr
	self.texbank_ptr = texbank_ptr
	self.objbank_ptr = objbank_ptr
	self.ompbank_ptr = ompbank_ptr
	self.cameras3D = (@*[0]EVMCam3D)(&self.sysmem_ptr[MEMORY_CAMERAS3D_INDEX])
	self.cameras2D = (@*[0]EVMCam2D)(&self.sysmem_ptr[MEMORY_CAMERAS2D_INDEX])
	self.lights = (@*[0]EVMLight)(&self.sysmem_ptr[MEMORY_LIGHTS_INDEX])
	self.render_state = (@*RenderState)(&self.sysmem_ptr[MEMORY_RENDER_STATE_INDEX])

	local flags: cint = 0
	if core.config.vsync then
		flags = flags | rl.configFlags.VSYNC_HINT
	end
	if core.config.highdpi then
		flags = flags | rl.configFlags.WINDOW_HIGHDPI
	end

	rl.setConfigFlags(flags | rl.configFlags.WINDOW_RESIZABLE)
	rl.setTraceLogLevel(core.config.log_level)

	rl.initWindow(GPU_VSCREEN_W * 2, GPU_VSCREEN_H * 2, "ERA-3D")
	rl.setWindowMinSize(GPU_VSCREEN_W, GPU_VSCREEN_H)
	--[[
	if rl.isWindowReady() then
		-- kinda gross "hack" to check if we need the HighDPI flag
		local dpi_scale: rl.vector2 = rl.getWindowScaleDPI()
		if dpi_scale.x > 1.0 or dpi_scale.y > 1.0 then
			rl.closeWindow()
			
			rl.setConfigFlags(rl.configFlags.VSYNC_HINT | rl.configFlags.WINDOW_HIGHDPI) -- enable vsync and HighDPI
			rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
		end
	end
	]]

	rl.setTargetFPS(60)
	rl.setExitKey(rl.keyboardKey.NULL)

	loadOpenGLFunctions()

	self.gfx_master_rendertexture = loadRenderTextureCustom(GPU_VSCREEN_W, GPU_VSCREEN_H)

	self.gfx_rendertexture_index = RenderTexture.CODE
	for i = 0, < RenderTexture.COUNT do
		self.gfx_rendertextures[i] = loadRenderTextureCustom(GPU_VSCREEN_W, GPU_VSCREEN_H)
	end

	local img: rl.image = rl.genImageColor(GPU_TEXMEM_WIDTH, GPU_TEXMEM_HEIGHT, {0,0,0,0})
	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	--memory.copy(&self.texmem, img.data, GPU_TEXMEM_SIZE * #rl.color)
	self.gfx_texture = rl.loadTextureFromImage(img)
	rl.unloadImage(img)

	local checker_img: rl.image = {
		data = &CHECKER_DATA[0],
		width = CHECKER_WIDTH,
		height = CHECKER_HEIGHT,
		mipmaps = 1,
		format = CHECKER_FORMAT
	}
	local ui_img: rl.image = {
		data = &UI_DATA[0],
		width = UI_WIDTH,
		height = UI_HEIGHT,
		mipmaps = 1,
		format = UI_FORMAT
	}

	self.gfx_ui_texture = rl.loadTextureFromImage(ui_img)
	self.gfx_checker_texture = rl.loadTextureFromImage(checker_img)
	rlgl.textureParameters(self.gfx_checker_texture.id, rlgl.TEXTURE_WRAP_S, rlgl.TEXTURE_WRAP_REPEAT)
    rlgl.textureParameters(self.gfx_checker_texture.id, rlgl.TEXTURE_WRAP_T, rlgl.TEXTURE_WRAP_REPEAT)
	
	self.gfx_shader = rl.loadShaderFromMemory(GPU_VERT_SRC, GPU_FRAG_SRC)
	self.crt_shader = rl.loadShaderFromMemory(nilptr, GPU_CRT_FRAG_SRC)
	
	self.mat_model_loc = rl.getShaderLocation(self.gfx_shader, "matModel")
	self.mat_normal_loc = rl.getShaderLocation(self.gfx_shader, "matNormal")
	self.tex_mode_loc = rl.getShaderLocation(self.gfx_shader, "texMode")
	self.tex_x_loc = rl.getShaderLocation(self.gfx_shader, "texX")
	self.tex_y_loc = rl.getShaderLocation(self.gfx_shader, "texY")
	self.tex_w_loc = rl.getShaderLocation(self.gfx_shader, "texW")
	self.tex_h_loc = rl.getShaderLocation(self.gfx_shader, "texH")
	self.fog_mode_loc = rl.getShaderLocation(self.gfx_shader, "fogMode")
	self.fog_start_loc = rl.getShaderLocation(self.gfx_shader, "fogStart")
	self.fog_end_loc = rl.getShaderLocation(self.gfx_shader, "fogEnd")
	self.fog_color_loc = rl.getShaderLocation(self.gfx_shader, "fogColor")
	self.lighting_mode_loc = rl.getShaderLocation(self.gfx_shader, "lightingMode")
	self.ambient_factor_loc = rl.getShaderLocation(self.gfx_shader, "ambientFactor")
	self.ambient_color_loc = rl.getShaderLocation(self.gfx_shader, "ambientColor")
	self.crt_time_loc = rl.getShaderLocation(self.crt_shader, "time")
	self.crt_brightness_loc = rl.getShaderLocation(self.crt_shader, "brightness")
	self.crt_blur_loc = rl.getShaderLocation(self.crt_shader, "blur")
	self.crt_noise_loc = rl.getShaderLocation(self.crt_shader, "noise")
	self.crt_scanlines_loc = rl.getShaderLocation(self.crt_shader, "scanlines")

	self:updateCRTShader()

	-- get light attribute locs
	for i = 0, < GPU_LIGHTS_COUNT do
		light_attrib_locs[i][LightAttribute.ENABLED]   = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].enabled", i))
		light_attrib_locs[i][LightAttribute.TYPE]      = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].type", i))
		light_attrib_locs[i][LightAttribute.RADIUS]    = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].radius", i))
		light_attrib_locs[i][LightAttribute.COLOR]     = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].color", i))
		light_attrib_locs[i][LightAttribute.POSITION]  = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].position", i))
		light_attrib_locs[i][LightAttribute.DIRECTION] = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].direction", i))
	end

	self.system_cam2d = {
		offset={0.0,0.0},
		target={0.0,0.0},
		rotation=0.0,
		zoom=1.0
	}

	self.system_cam3d = {
		position={0,0,0},
		target={0,0,-1},
		up={0,1,0},
		fovy=45,
		projection=rl.cameraProjection.PERSPECTIVE
	}

	self.system_viewport_w = GPU_VSCREEN_W
	self.system_viewport_h = GPU_VSCREEN_H

	self:setBankPointers(
		GPUBank.TEXBANK0,
		GPUBank.OBJBANK0
	)

	self:resetGPU()

	self:texture(0, 0, 64, 64)
	self:textureMode(0)
	self:fogMode(false)
	self:lightingMode(false)
	self:ambientFactor(0.0)

	self.enable_flush = true
end

function GPU:cleanup(): void
	rl.unloadShader(self.gfx_shader)
	rl.unloadShader(self.crt_shader)
	rl.unloadTexture(self.gfx_ui_texture)
	rl.unloadTexture(self.gfx_checker_texture)
	rl.unloadTexture(self.gfx_texture)

	for i = 0, < RenderTexture.COUNT do
		unloadRenderTextureCustom(self.gfx_rendertextures[i])
	end

	unloadRenderTextureCustom(self.gfx_master_rendertexture)

	rl.closeWindow()
end
