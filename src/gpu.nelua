require("string")

require("definitions")

local GL_DEPTH_BUFFER_BIT <comptime> = 0x00000100
local function glClear(mask: cint): void <cimport> end

local GPU_VERT_SRC <const> = [[
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
//in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec2 fragTexCoord;
out vec4 fragColor;

#define MAX_LIGHTS 8
#define LIGHT_POINT 0
#define LIGHT_DIRECTIONAL 1

struct Light {
	int enabled;
	int type;
	float radius;
	vec3 position;
	vec3 direction;
	vec3 color;
};

// custom uniforms
uniform int lightingMode;
uniform float ambientFactor;
uniform vec3 ambientColor;
uniform Light lights[MAX_LIGHTS];

vec4 calculateLighting() {
	// when lighting is enabled, use the vertex color xyz values as the normal
	vec3 rawNormal = vertexColor.xyz;

	// get vertex in world space
	vec3 vertex = vec3(matModel * vec4(vertexPosition, 1.0f));

	// get normal in world space?
	vec3 normal = normalize(vec3(matNormal * vec4(rawNormal, 1.0f)));

	vec3 lightDirection;
	float diffuseFactor;
	float attenuation;
	vec3 diffuseColor = vec3(0.0f);
	vec3 lightPos;

	for (int i = 0; i < MAX_LIGHTS; i++) {
		if (lights[i].enabled == 1) {
			lightPos = lights[i].position;

			if (lights[i].type == LIGHT_POINT) {
				// get direction to light
				lightDirection = normalize(lightPos - vertex);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				// get attenuation based on light radius 
				attenuation = smoothstep(lights[i].radius, 0.0f, length(lightPos - vertex));
	
				diffuseColor += lights[i].color * (diffuseFactor * attenuation);
			}
			else {
				// get direction of light
				lightDirection = normalize(-lights[i].direction);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				diffuseColor += lights[i].color * diffuseFactor;
			}
		}
	}

	// get ambient color
	vec3 ambientColorFinal = ambientFactor * ambientColor;

	//return min(vec4(diffuseColor + ambientColorFinal, 1.0f), vec4(1.0));
	return vec4(diffuseColor + ambientColorFinal, 1.0f);
}

void main()
{
	fragTexCoord = vertexTexCoord;
	
	if (lightingMode == 0) {
		fragColor = vertexColor;
	}
	else {
		fragColor = calculateLighting();
	}

	// calculate final vertex position
	gl_Position = mvp * vec4(vertexPosition, 1.0f);
}
]]

local GPU_FRAG_SRC <const> = [[
#version 330

// built-in values:
in vec2 fragTexCoord; // uv
in vec4 fragColor;    // vertex color

out vec4 finalColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// custom uniforms:
uniform int texMode;
uniform int texX;
uniform int texY;
uniform int texW;
uniform int texH;

uniform int fogMode;
uniform float fogStart;
uniform float fogEnd;
uniform vec4 fogColor;

vec4 getTexColor(vec2 coord) {
	// create vectors
	vec2 tMin = vec2(float(texX), float(texY));
	vec2 tMax = vec2(float(texX + texW), float((texY) + texH));
	vec2 tSize = vec2(1024.0f, 1024.0f);

	// get mapped uv coords
	vec2 mappedCoord = mix(tMin, tMax, coord) / tSize;
	
	// sample color from texture
	vec4 rawColor = texture(texture0, mappedCoord) * fragColor;

	return rawColor;
}

void main()
{
	vec4 rawColor;

	if (texMode == 0) {
		rawColor = getTexColor(mod(fragTexCoord, vec2(1.0f, 1.0f)));
	}
	else if (texMode == 1) {
		rawColor = getTexColor(clamp(fragTexCoord, vec2(0.0f, 0.0f), vec2(0.99f, 0.99f)));
	}
	else {
		rawColor = vec4(1.0f, 1.0f, 1.0f, 1.0f) * fragColor;
	}

	if (rawColor.a == 0) {
		discard;
	}

	if (fogMode == 1) {
		// calculate fog
		float dist = (gl_FragCoord.z / gl_FragCoord.w);
		float fogFactor;
		if (fogStart == fogEnd) {
			fogFactor = 1.0;
		}
		else {
			fogFactor = fogEnd - fogStart;
		}
		fogFactor = clamp((fogEnd - dist) / fogFactor, 0.0f, 1.0f);

		finalColor = mix(fogColor, rawColor, fogFactor);
	}
	else {
		finalColor = rawColor;
	}
}
]]

local src_rect: rl.rectangle = {0.0, 0.0, (@float32)(GPU_VSCREEN_W), -(@float32)(GPU_VSCREEN_H)}
local master_dest_rect: rl.rectangle = {0.0, 0.0, (@float32)(GPU_SCREEN_W), (@float32)(GPU_SCREEN_H)}
local sub_dest_rect: rl.rectangle = {0.0, 0.0, (@float32)(GPU_VSCREEN_W), (@float32)(GPU_VSCREEN_H)}
local light_attrib_locs: [GPU_LIGHTS_COUNT][LightAttribute.COUNT]cint

function GPU:clear(col: uint32): void
	local alpha: cuchar = (@cuchar)(col & 0xFF)

	if alpha ~= 0 then
		local clear_color: rl.color = {
			(@cuchar)(col >> 24),
			(@cuchar)((col & 0xFF0000) >> 16),
			(@cuchar)((col & 0x00FF00) >> 8),
			0xFF
		}

		rl.clearBackground(clear_color)
	else
		glClear(GL_DEPTH_BUFFER_BIT) -- clear the depth buffer, but not the color buffer
	end
end

function GPU:camera2D(id: integer): void
	local cam: rl.camera2D

	if id >= 0 then
		cam = self.cameras2D[id]
	else
		cam = self.system_cam2d
	end

	rlgl.disableDepthTest()
	
	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
	rlgl.loadIdentity()
	rlgl.ortho(0.0, self.viewport_w, self.viewport_h, 0.0, 0.0, 1.0)

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	rl.beginMode2D(cam)
	
	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:camera3D(id: integer): void
	local cam: rl.camera
	
	if id >= 0 then
		cam = self.cameras[id]
	else
		cam = self.system_cam
	end

	-- copy Raylib's BeginMode3D(),
	-- but we don't need to push a new projection matrix

	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
    rlgl.loadIdentity()

	local aspect: float32 = (@float32)(self.viewport_w) / (@float32)(self.viewport_h)

	-- 0.01 is the near clipping value
	-- 1000.0 is the far clipping value
	-- TODO: allow setting near/far?
	if cam.projection == rl.cameraProjection.PERSPECTIVE then
		local top: float64 = 0.01 * math.tan(cam.fovy * 0.5 * (math.pi / 180.0))
		local right: float64 = top * aspect

		rlgl.frustum(-right, right, -top, top, 0.01, 1000.0)
	elseif cam.projection == rl.cameraProjection.ORTHOGRAPHIC then
		local top: float64 = cam.fovy / 2.0
		local right: float64 = top * aspect

		rlgl.ortho(-right, right, -top, top, 0.01, 1000.0)
	end

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	local mat_view: rl.matrix = rl.matrix.lookAt(cam.position, cam.target, cam.up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	rlgl.enableDepthTest()

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:beginMesh(mode: uint32): void
	switch mode do
		case GPU_LINES then
			self.triangle_mode = false
			mode = rlgl.LINES
		case GPU_TRIANGLES then
			self.triangle_mode = true
			self.triangle_vert_index = 0
			mode = rlgl.QUADS
		case GPU_QUADS then
			self.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(self.gfx_shader)

	rlgl.setTexture(self.gfx_texture.id)
	
	rlgl.begin(mode)
end

function GPU:endMesh(): void
	rlgl.ending()

	rl.endShaderMode()
end

function GPU:matrixMode(mode: uint32): void
	switch mode do
		case GPU_PROJECTION then
			rlgl.matrixMode(rlgl.PROJECTION)
			self.matrix_mode = rlgl.PROJECTION
		case GPU_MODELVIEW then
			rlgl.matrixMode(rlgl.MODELVIEW)
			self.matrix_mode = rlgl.MODELVIEW
	end
end

function GPU:vertex(v: rl.vector3): void
	rlgl.vertex3f(v.x, v.y, v.z)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex3f(v.x, v.y, v.z)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertex2D(v: rl.vector2): void
	rlgl.vertex2f(v.x, v.y)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex2f(v.x, v.y)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertNormal(v: rl.vector3): void
	if self.lighting_mode ~= 0 then
		rlgl.color3f(v.x, v.y, v.z)
	end
end

function GPU:vertUV(v: rl.vector2): void
	rlgl.texCoord2f(v.x, v.y)
end

function GPU:vertColor(col: uint32): void
	if self.lighting_mode == 0 then
		local r: cuchar = (@cuchar)(col >> 24)
		local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
		local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
		local a: cuchar = (@cuchar)(col & 0xFF)
		
		rlgl.color4ub(r, g, b, a)
	end
end

function GPU:drawChar2D(c: uint8, x: *int32, y: int32, color: rl.color): void
	local fx: float32 = (@float32)($x)
	local fy: float32 = (@float32)(y)

	if c < ' '_u8 then
		c = '?'_u8
		$x = $x + 6
	elseif c == ' '_u8 then
		$x = $x + 6
		return
	elseif c == '\t'_u8 then
		$x = $x + 12 -- tabs = 2 spaces
		return
	else
		$x = $x + 6
	end

	if fx <= -6.0 or y <= -9.0 or color.a == 0 then
		return
	end

	local srcx: float32 = (@float32)((c %%% 32) * 6)
	local srcy: float32 = (@float32)((c /// 32) * 9)

	local src_rect: rl.rectangle = {srcx, srcy, 6.0, 9.0}
	local dest_rect: rl.rectangle = {fx, fy, 6.0, 9.0}

	rl.drawTexturePro(self.gfx_font_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, color)
end

-- print2D function for host program, doesn't do formatting
function GPU:print2D(x: int32, y: int32, col: uint32, text: string): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local i: uinteger = 1
	while i <= #text do
		local c: uint8

		if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
			-- we're off screen, no need to render
			return
		end

		c = text[i]
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end
end

function GPU:printInt2D(x: int32, y: int32, col: uint32, value: int32, out_char_count: *int32): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local buffer: [11]uint8 -- -2147483648 to 2147483647, 11 chars
	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	-- create string
	local buffer_index: uint8 = 10
	if value == 0 then
		buffer[10] = '0'_u8
		goto DRAW_STRING
	end

	local bvalue: int64
	local negative: boolean = value < 0
	if negative then
		bvalue = -(@int64)(value)
	else
		bvalue = (@int64)(value)
	end

	while bvalue ~= 0 do
		buffer[buffer_index] = '0'_u8 + (@uint8)(bvalue %%% 10)
		buffer_index = buffer_index - 1
		bvalue = bvalue /// 10
	end

	if negative then
		buffer[buffer_index] = '-'_u8
	else
		buffer_index = buffer_index + 1
	end

	::DRAW_STRING::

	if out_char_count ~= nilptr then
		$out_char_count = (10 - buffer_index) + 1
	end

	while buffer_index < 11 do
		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end

		self:drawChar2D(buffer[buffer_index], &cur_x, y, ray_col)

		buffer_index = buffer_index + 1
	end
end

-- print2D function for host program, doesn't do formatting
function GPU:printCString2D(x: int32, y: int32, col: uint32, ctext: cstring): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local text: *[0]cchar = (@*[0]cchar)(ctext)
	local i: uinteger = 0
	local c: cchar = text[i]
	while c ~= '\0'_u8 do
		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
		c = text[i]
	end
end

-- printHexNibble2D function for host program, doesn't do formatting
function GPU:printHexNibble2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local nibble: uint8 = val & 0xF
	if nibble < 0xA then
		nibble = '0'_u8 + nibble
	else
		nibble = 'A'_u8 + (nibble - 0xA)
	end

	self:drawChar2D(nibble, &cur_x, y, ray_col)
end

-- printHexByte2D function for host program, doesn't do formatting
function GPU:printHexByte2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local msn: uint8 = val >> 4
	if msn < 0xA then
		msn = '0'_u8 + msn
	else
		msn = 'A'_u8 + (msn - 0xA)
	end

	self:drawChar2D(msn, &cur_x, y, ray_col)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local lsn: uint8 = val & 0xF
	if lsn < 0xA then
		lsn = '0'_u8 + lsn
	else
		lsn = 'A'_u8 + (lsn - 0xA)
	end

	self:drawChar2D(lsn, &cur_x, y, ray_col)
end

function GPU:drawRect2D(x: int32, y: int32, w: int32, h: int32, col: uint32): void
	local fx0: float32 = (@float32)(x)
	local fy0: float32 = (@float32)(y)
	local fx1: float32 = (@float32)(x + w)
	local fy1: float32 = (@float32)(y + h)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	rl.drawRectangle(x, y, w, h, ray_col)
end

function GPU:uploadOBJMEMVertex(index: uint32): void
	local word_index: uinteger = index * 9

	self:vertColor(self.objmem[word_index + 8].u)
	self:vertUV({self.objmem[word_index + 6].f, self.objmem[word_index + 7].f})
	self:vertNormal({self.objmem[word_index + 3].f, self.objmem[word_index + 4].f, self.objmem[word_index + 5].f})
	self:vertex({self.objmem[word_index].f, self.objmem[word_index + 1].f, self.objmem[word_index + 2].f})
end

function GPU:drawObjEx(mode: uint32, start: uint32, n: uint32): void
	if n == 0 then
		return
	end

	self:beginMesh(mode)
		switch mode do
			case GPU_LINES then
				for i = 0, < n do
					local line_start: uint32 = start + (i * 2)
					self:uploadOBJMEMVertex(line_start)
					self:uploadOBJMEMVertex(line_start + 1)
				end
			case GPU_TRIANGLES then
				for i = 0, < n do
					local tri_start: uint32 = start + (i * 3)
					self:uploadOBJMEMVertex(tri_start)
					self:uploadOBJMEMVertex(tri_start + 1)
					self:uploadOBJMEMVertex(tri_start + 2)
				end
			case GPU_QUADS then
				for i = 0, < n do
					-- get vertices
					local quad_start: uint32 = start + (i * 4)
					self:uploadOBJMEMVertex(quad_start)
					self:uploadOBJMEMVertex(quad_start + 1)
					self:uploadOBJMEMVertex(quad_start + 2)
					self:uploadOBJMEMVertex(quad_start + 3)
				end
		end
	self:endMesh()
end

function GPU:drawObj(id: uint32): void
	-- get objmap entry pointer
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84 + (id * 12)])

	-- get mode
	local mode: uint32 = ((@uint32)(entry_ptr[0]) << 24) | ((@uint32)(entry_ptr[1]) << 16) | ((@uint32)(entry_ptr[2]) << 8) | (@uint32)(entry_ptr[3])

	-- get start
	local start: uint32 = ((@uint32)(entry_ptr[4]) << 24) | ((@uint32)(entry_ptr[5]) << 16) | ((@uint32)(entry_ptr[6]) << 8) | (@uint32)(entry_ptr[7])

	-- get n
	local n: uint32 = ((@uint32)(entry_ptr[8]) << 24) | ((@uint32)(entry_ptr[9]) << 16) | ((@uint32)(entry_ptr[10]) << 8) | (@uint32)(entry_ptr[11])

	self:drawObjEx(mode, start, n)
end

function GPU:texture(x: int32, y: int32, w: int32, h: int32): void
	self.tex_x = (@cint)(x)
	self.tex_y = (@cint)(y)
	self.tex_w = (@cint)(w)
	self.tex_h = (@cint)(h)
	
	rl.setShaderValue(self.gfx_shader, self.tex_x_loc, &self.tex_x, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_y_loc, &self.tex_y, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_w_loc, &self.tex_w, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_h_loc, &self.tex_h, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:updateVertexShaderMatrices(): void
	-- get required matrices
	local matModel: rl.matrix = rlgl.getMatrixTransform()
	local matNormal: rl.matrix = rl.matrix.transpose(rl.matrix.invert(matModel))

	-- upload to vertex shader
	rl.setShaderValueMatrix(self.gfx_shader, self.mat_model_loc, matModel)
	rl.setShaderValueMatrix(self.gfx_shader, self.mat_normal_loc, matNormal)
end

function GPU:setBlendMode(mode: uint32): void
	self.blend_mode = mode
	rlgl.setBlendMode(self.blend_mode)
end

function GPU:setLightingMode(mode: uint32): void
	self.lighting_mode = mode
	rl.setShaderValue(self.gfx_shader, self.lighting_mode_loc, &self.lighting_mode, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setAmbientFactor(factor: float32): void
	self.ambient_factor = factor / 100.0
	rl.setShaderValue(self.gfx_shader, self.ambient_factor_loc, &self.ambient_factor, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:setAmbientColor(col: uint32): void
	self.ambient_color = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, self.ambient_color_loc, &self.ambient_color, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightEnabled(id: uint32, enabled: uint32): void
	self.lights[id].enabled = (enabled ~= 0) and 1 or 0
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.ENABLED], &self.lights[id].enabled, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setLightType(id: uint32, light_type: uint32): void
	self.lights[id].light_type = (@cint)(light_type)
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.TYPE], &self.lights[id].light_type, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setLightRadius(id: uint32, radius: float32): void
	self.lights[id].radius = radius
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.RADIUS], &self.lights[id].radius, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:setLightPosition(id: uint32, pos: rl.vector3): void
	self.lights[id].position = pos
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.POSITION], &self.lights[id].position, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightDirection(id: uint32, dir: rl.vector3): void
	self.lights[id].direction = dir
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.DIRECTION], &self.lights[id].direction, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightColor(id: uint32, col: uint32): void
	self.lights[id].color = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][LightAttribute.COLOR], &self.lights[id].color, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:loadTexBank(bank: uint8): void
	local src: *[0]rl.color = &self.texbank_ptr[MEMORY_TEXMEM_SIZE_ELEMENTS * bank]
	memory.copy(&self.texmem, src, MEMORY_TEXMEM_SIZE_BYTES)
	self.update_tex = true
end

function GPU:loadObjBank(bank: uint8): void
	-- load objbank
	local src: *[0]IntFloat = &self.objbank_ptr[(MEMORY_OBJMEM_SIZE_ELEMENTS) * bank]
	memory.copy(&self.objmem, src, MEMORY_OBJMEM_SIZE_BYTES)

	-- load ompbank
	local objmap_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84])
	local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.ompbank_ptr[(MEMORY_OBJMAP_SIZE * bank)])
	memory.copy(objmap_ptr, bank_ptr, MEMORY_OBJMAP_SIZE)

	self.update_tex = true
end

function GPU:loadTextureData(bank_index: integer, src_x: int32, src_y: int32, dest_x: int32, dest_y: int32, w: int32, h: int32): void
	local bank_ptr: *[0]rl.color = (@*[0]rl.color)(&self.texbank_ptr[MEMORY_TEXMEM_SIZE_ELEMENTS * bank_index])
	local data: *[0]rl.color = (@*[0]rl.color)(core.image_to_import.data)

	for y = 0, < h do
		local read_y: int32 = src_y + y
		local write_y: int32 = dest_y + y
		for x = 0, < w do
			local read_x: int32 = src_x + x
			local write_x: int32 = dest_x + x
			bank_ptr[w * write_y + write_x] = data[w * read_y + read_x]
		end
	end
end

function GPU:loadModelData(bank_index: uint32, start_index: uint32): void
	local vertex_count: uint32
	local bank_ptr: *[0]IntFloat = &self.objbank_ptr[MEMORY_OBJMEM_SIZE_ELEMENTS * bank_index]

	for i = 0, < core.model_to_import.meshCount do
		local mesh: rl.mesh = (@*[0]rl.mesh)(core.model_to_import.meshes)[i]
		local posptr: *[0]float32 = (@*[0]float32)(mesh.vertices)
		local uvptr: *[0]float32 = (@*[0]float32)(mesh.texcoords)
		local colptr: *[0]cuchar = (@*[0]cuchar)(mesh.colors)
		local normptr: *[0]float32 = (@*[0]float32)(mesh.normals)
		local idxptr: *[0]cushort = (@*[0]cushort)(mesh.indices)
		
		if idxptr ~= nilptr then
			for j = 0, < mesh.triangleCount do
				for k = 0, < 3 do
					local idx: cushort = idxptr[j * 3 + k]
					local posindex: uinteger = idx * 3
					local uvindex: uinteger = idx * 2
					local colindex: uinteger = idx * 4
					
					local pos: rl.vector3 = {
						posptr[posindex],
						posptr[posindex + 1],
						posptr[posindex + 2]
					}
					
					local uv: rl.vector2 = {
						uvptr[uvindex],
						uvptr[uvindex + 1]
					}
					
					local col: uint32
					if colptr ~= nilptr then
						col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
					else
						col = 0xFFFFFFFF
					end
					
					local objmemindex: uinteger = (start_index + vertex_count) * 9
					bank_ptr[objmemindex].f = pos.x
					bank_ptr[objmemindex + 1].f = pos.y
					bank_ptr[objmemindex + 2].f = pos.z
					bank_ptr[objmemindex + 6].f = uv.x
					bank_ptr[objmemindex + 7].f = uv.y
					bank_ptr[objmemindex + 8].u = col

					vertex_count = vertex_count + 1
				end
			end
		else
			for j = 0, < mesh.vertexCount do
				local posindex: uinteger = j * 3
				local uvindex: uinteger = j * 2
				local colindex: uinteger = j * 4
				local normindex: uinteger = j * 3
				
				local pos: rl.vector3 = {
					posptr[posindex],
					posptr[posindex + 1],
					posptr[posindex + 2]
				}

				local norm: rl.vector3 = {
					normptr[normindex],
					normptr[normindex + 1],
					normptr[normindex + 2]
				}
				
				local uv: rl.vector2 = {
					uvptr[uvindex],
					uvptr[uvindex + 1]
				}
				
				local col: uint32
				if colptr ~= nilptr then
					col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
				else
					col = 0xFFFFFFFF
				end
				
				local objmemindex: uinteger = (start_index + vertex_count) * 9
				bank_ptr[objmemindex].f = pos.x
				bank_ptr[objmemindex + 1].f = pos.y
				bank_ptr[objmemindex + 2].f = pos.z

				bank_ptr[objmemindex + 3].f = norm.x
				bank_ptr[objmemindex + 4].f = norm.y
				bank_ptr[objmemindex + 5].f = norm.z

				bank_ptr[objmemindex + 6].f = uv.x
				bank_ptr[objmemindex + 7].f = uv.y
				bank_ptr[objmemindex + 8].u = col

				vertex_count = vertex_count + 1
			end
		end
	end
end

function GPU:resetMatrixStack(): void
	rlgl.matrixMode(rlgl.PROJECTION)

	while self.proj_matrix_count > 0 do
		rlgl.popMatrix()
		self.proj_matrix_count = self.proj_matrix_count - 1
	end

	rlgl.matrixMode(rlgl.MODELVIEW)

	while self.view_matrix_count > 0 do
		rlgl.popMatrix()
		self.view_matrix_count = self.view_matrix_count - 1
	end
end

function GPU:beginCurrentRenderTexture(): void
	rl.beginTextureMode(self.gfx_rendertextures[self.gfx_rendertexture_index])
end

function GPU:beginMasterRenderTexture(): void
	rl.beginTextureMode(self.gfx_master_rendertexture)
end

function GPU:endRenderTexture(): void
	rl.endTextureMode()
end

function GPU:drawCurrentRenderTexture(): void
	rl.drawTexturePro(self.gfx_rendertextures[self.gfx_rendertexture_index].texture, src_rect, sub_dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)
end

function GPU:drawMasterRenderTexture(): void
	rl.drawTexturePro(self.gfx_master_rendertexture.texture, src_rect, master_dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)
end

function GPU:useRenderTexture(index: uinteger): void
	rlgl.setTexture(self.gfx_rendertextures[index].texture.id)
end

function GPU:setRenderTexture(index: uinteger): void
	self.gfx_rendertexture_index = index
end

function GPU:enableRenderState(): void
	switch self.cull_mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
	end

	if self.wire_mode then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	rlgl.enableScissorTest()

	self:setBlendMode(self.blend_mode)

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:disableRenderState(): void
	rlgl.enableBackfaceCulling()
	rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
	rlgl.disableWireMode()
	rlgl.disableScissorTest()

	-- TODO: properly disable all render state

	self:setBlendMode(rl.blendMode.ALPHA)
end

function GPU:resetGPU(): void
	for i = 0, < GPU_CAMERAS_COUNT do
		self.cameras2D[i] = {
			offset={0.0,0.0},
			target={0.0,0.0},
			rotation=0.0,
			zoom=1.0
		}

		self.cameras[i] = {
			position={0,0,4},
			target={0,0,0},
			up={0,1,0},
			fovy=45,
			projection=rl.cameraProjection.PERSPECTIVE
		}
	end

	for i = 0, < GPU_LIGHTS_COUNT do
		self.lights[i] = {
			0,
			0,
			0.0,
			{0,0,0},
			{0,-1,0},
			{0,0,0}
		}
	end

	self.cull_mode = 0
	self.wire_mode = false
	
	self.tex_mode = 0
	rl.setShaderValue(self.gfx_shader, self.tex_mode_loc, &self.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)
	
	self.fog_mode = 0
	self.fog_start = 700.0
	self.fog_end = 1000.0
	self.fog_color = {1.0, 1.0, 1.0, 1.0}
	self.lighting_mode = 0
	self.ambient_factor = 0.0
	self.ambient_color = {0.0, 0.0, 0.0}
	rl.setShaderValue(self.gfx_shader, self.fog_mode_loc, &self.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.fog_start_loc, &self.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_end_loc, &self.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_color_loc, &self.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)
	rl.setShaderValue(self.gfx_shader, self.lighting_mode_loc, &self.lighting_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.ambient_factor_loc, &self.ambient_factor, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.ambient_color_loc, &self.ambient_color, rl.shaderUniformDataType.UNIFORM_VEC3)
	
	self:texture(0, 0, 64, 64)

	self.viewport_w = GPU_VSCREEN_W
	self.viewport_h = GPU_VSCREEN_H
	self.proj_matrix_count = 0
	self.view_matrix_count = 0
end

function GPU:init(sysmem_ptr: *[0]uint8, texbank_ptr: *[0]rl.color, objbank_ptr: *[0]IntFloat, ompbank_ptr: *[0]uint8): void
	self.sysmem_ptr = sysmem_ptr
	self.texbank_ptr = texbank_ptr
	self.objbank_ptr = objbank_ptr
	self.ompbank_ptr = ompbank_ptr

	rl.setConfigFlags(rl.configFlags.VSYNC_HINT) -- enable vsync
	rl.setTraceLogLevel(rl.traceLogLevel.ERROR) -- only log errors

	rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
	--[[
	if rl.isWindowReady() then
		-- kinda gross "hack" to check if we need the HighDPI flag
		local dpi_scale: rl.vector2 = rl.getWindowScaleDPI()
		if dpi_scale.x > 1.0 or dpi_scale.y > 1.0 then
			rl.closeWindow()
			
			rl.setConfigFlags(rl.configFlags.VSYNC_HINT | rl.configFlags.WINDOW_HIGHDPI) -- enable vsync and HighDPI
			rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
		end
	end
	]]

	rl.setTargetFPS(30)
	rl.setExitKey(rl.keyboardKey.NULL)

	self.gfx_master_rendertexture = rl.loadRenderTexture(GPU_VSCREEN_W, GPU_VSCREEN_H)

	self.gfx_rendertexture_index = RenderTexture.CODE
	for i = 0, < RenderTexture.COUNT do
		self.gfx_rendertextures[i] = rl.loadRenderTexture(GPU_VSCREEN_W, GPU_VSCREEN_H)
	end

	local img: rl.image = rl.genImageColor(GPU_TEXMEM_WIDTH, GPU_TEXMEM_HEIGHT, {0,0,0,0})
	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	--memory.copy(&self.texmem, img.data, GPU_TEXMEM_SIZE * #rl.color)
	self.gfx_texture = rl.loadTextureFromImage(img)
	rl.unloadImage(img)

	self.gfx_font_texture = rl.loadTexture("assets/font.png")
	
	self.gfx_shader = rl.loadShaderFromMemory(GPU_VERT_SRC, GPU_FRAG_SRC)
	
	self.mat_model_loc = rl.getShaderLocation(self.gfx_shader, "matModel")
	self.mat_normal_loc = rl.getShaderLocation(self.gfx_shader, "matNormal")
	self.tex_mode_loc = rl.getShaderLocation(self.gfx_shader, "texMode")
	self.tex_x_loc = rl.getShaderLocation(self.gfx_shader, "texX")
	self.tex_y_loc = rl.getShaderLocation(self.gfx_shader, "texY")
	self.tex_w_loc = rl.getShaderLocation(self.gfx_shader, "texW")
	self.tex_h_loc = rl.getShaderLocation(self.gfx_shader, "texH")
	self.fog_mode_loc = rl.getShaderLocation(self.gfx_shader, "fogMode")
	self.fog_start_loc = rl.getShaderLocation(self.gfx_shader, "fogStart")
	self.fog_end_loc = rl.getShaderLocation(self.gfx_shader, "fogEnd")
	self.fog_color_loc = rl.getShaderLocation(self.gfx_shader, "fogColor")
	self.lighting_mode_loc = rl.getShaderLocation(self.gfx_shader, "lightingMode")
	self.ambient_factor_loc = rl.getShaderLocation(self.gfx_shader, "ambientFactor")
	self.ambient_color_loc = rl.getShaderLocation(self.gfx_shader, "ambientColor")

	-- get light attribute locs
	for i = 0, < GPU_LIGHTS_COUNT do
		light_attrib_locs[i][LightAttribute.ENABLED]   = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].enabled", i))
		light_attrib_locs[i][LightAttribute.TYPE]      = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].type", i))
		light_attrib_locs[i][LightAttribute.RADIUS]    = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].radius", i))
		light_attrib_locs[i][LightAttribute.POSITION]  = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].position", i))
		light_attrib_locs[i][LightAttribute.DIRECTION] = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].direction", i))
		light_attrib_locs[i][LightAttribute.COLOR]     = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].color", i))
	end

	self.system_cam2d = {
		offset={0.0,0.0},
		target={0.0,0.0},
		rotation=0.0,
		zoom=1.0
	}

	self.system_cam = {
		position={0,0,0},
		target={0,0,-1},
		up={0,1,0},
		fovy=45,
		projection=rl.cameraProjection.PERSPECTIVE
	}

	self:resetGPU()
end

function GPU:cleanup(): void
	rl.unloadShader(self.gfx_shader)
	rl.unloadTexture(self.gfx_font_texture)
	rl.unloadTexture(self.gfx_texture)

	for i = 0, < RenderTexture.COUNT do
		rl.unloadRenderTexture(self.gfx_rendertextures[i])
	end

	rl.unloadRenderTexture(self.gfx_master_rendertexture)

	rl.closeWindow()
end
