require("string")

require("raylib")
require("rlgl")

local GL_DEPTH_BUFFER_BIT <comptime> = 0x00000100
local function glClear(mask: cint): void <cimport> end

global GPU_ALPHA_BLACK <comptime> = 0x00000000
global GPU_ALPHA_WHITE <comptime> = 0xFFFFFF00
global GPU_BLACK       <comptime> = 0x000000FF
global GPU_GRAY        <comptime> = 0x808080FF
global GPU_WHITE       <comptime> = 0xFFFFFFFF
global GPU_RED         <comptime> = 0xFF0000FF
global GPU_GREEN       <comptime> = 0x00FF00FF
global GPU_BLUE        <comptime> = 0x0000FFFF

-- screen dimentions (vscreen is console's virtual resolution)
global GPU_VSCREEN_W <comptime> = 480
global GPU_VSCREEN_H <comptime> = 360
global GPU_SCREEN_W <comptime> = (GPU_VSCREEN_W * 2)
global GPU_SCREEN_H <comptime> = (GPU_VSCREEN_H * 2)
global GPU_CAMERAS_COUNT <comptime> = 4

global GPU_LINES <comptime> = 0
global GPU_TRIANGLES <comptime> = 1
global GPU_QUADS <comptime> = 2

global GPU_PROJECTION <comptime> = 0
global GPU_MODELVIEW <comptime> = 1

global GPU_TEXMEM_WIDTH <comptime> = 1024
global GPU_TEXMEM_HEIGHT <comptime> = 1024
global GPU_TEXMEM_SIZE <comptime> = (GPU_TEXMEM_WIDTH * GPU_TEXMEM_HEIGHT) -- 4MiB (1024*1024 pixels (32BPP))
global GPU_OBJMEM_SIZE <comptime> = (32768 * 3 * 9) -- 32768 triangles, 9 IntFloats per vertex

global GPU_OMPBANK_SIZE <comptime> = ((13 * 1024 * 1024) + (512 * 1024)) -- 1MiB + 256 KiB
global GPU_OBJMAP_SIZE <comptime> = (512 * 12) -- 6KiB

global GPU_LIGHTS_COUNT <comptime> = 8
local lightAttribute = @enum {
	ENABLED = 0,
	TYPE,
	RADIUS,
	POSITION,
	DIRECTION,
	COLOR,
	COUNT -- not an actual attribute, used to count the number of attributes
}

global GPU_VERT_SRC <const> = [[
#version 330

// Input vertex attributes
in vec3 vertexPosition;
in vec2 vertexTexCoord;
//in vec3 vertexNormal;
in vec4 vertexColor;

// Input uniform values
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matNormal;

// Output vertex attributes (to fragment shader)
out vec2 fragTexCoord;
out vec4 fragColor;

#define MAX_LIGHTS 8
#define LIGHT_POINT 0
#define LIGHT_DIRECTIONAL 1

struct Light {
	int enabled;
	int type;
	float radius;
	vec3 position;
	vec3 direction;
	vec3 color;
};

// custom uniforms
uniform int lightingMode;
uniform float ambientFactor;
uniform vec3 ambientColor;
uniform Light lights[MAX_LIGHTS];

vec4 calculateLighting() {
	// when lighting is enabled, use the vertex color xyz values as the normal
	vec3 rawNormal = vertexColor.xyz;

	// get vertex in world space
	vec3 vertex = vec3(matModel * vec4(vertexPosition, 1.0f));

	// get normal in world space?
	vec3 normal = normalize(vec3(matNormal * vec4(rawNormal, 1.0f)));

	vec3 lightDirection;
	float diffuseFactor;
	float attenuation;
	vec3 diffuseColor = vec3(0.0f);
	vec3 lightPos;

	for (int i = 0; i < MAX_LIGHTS; i++) {
		if (lights[i].enabled == 1) {
			lightPos = lights[i].position;

			if (lights[i].type == LIGHT_POINT) {
				// get direction to light
				lightDirection = normalize(lightPos - vertex);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				// get attenuation based on light radius 
				attenuation = smoothstep(lights[i].radius, 0.0f, length(lightPos - vertex));
	
				diffuseColor += lights[i].color * (diffuseFactor * attenuation);
			}
			else {
				// get direction of light
				lightDirection = normalize(-lights[i].direction);
	
				// get facing factor
				diffuseFactor = max(dot(normal, lightDirection), 0.0f);
	
				diffuseColor += lights[i].color * diffuseFactor;
			}
		}
	}

	// get ambient color
	vec3 ambientColorFinal = ambientFactor * ambientColor;

	//return min(vec4(diffuseColor + ambientColorFinal, 1.0f), vec4(1.0));
	return vec4(diffuseColor + ambientColorFinal, 1.0f);
}

void main()
{
	fragTexCoord = vertexTexCoord;
	
	if (lightingMode == 0) {
		fragColor = vertexColor;
	}
	else {
		fragColor = calculateLighting();
	}

	// calculate final vertex position
	gl_Position = mvp * vec4(vertexPosition, 1.0f);
}
]]

global GPU_FRAG_SRC <const> = [[
#version 330

// built-in values:
in vec2 fragTexCoord; // uv
in vec4 fragColor;    // vertex color

out vec4 finalColor;

uniform sampler2D texture0;
uniform vec4 colDiffuse;

// custom uniforms:
uniform int texMode;
uniform int texX;
uniform int texY;
uniform int texW;
uniform int texH;

uniform int fogMode;
uniform float fogStart;
uniform float fogEnd;
uniform vec4 fogColor;

vec4 getTexColor(vec2 coord) {
	// create vectors
	vec2 tMin = vec2(float(texX), float(texY));
	vec2 tMax = vec2(float(texX + texW), float((texY) + texH));
	vec2 tSize = vec2(1024.0f, 1024.0f);

	// get mapped uv coords
	vec2 mappedCoord = mix(tMin, tMax, coord) / tSize;
	
	// sample color from texture
	vec4 rawColor = texture(texture0, mappedCoord) * fragColor;

	return rawColor;
}

void main()
{
	vec4 rawColor;

	if (texMode == 0) {
		rawColor = getTexColor(mod(fragTexCoord, vec2(1.0f, 1.0f)));
	}
	else if (texMode == 1) {
		rawColor = getTexColor(clamp(fragTexCoord, vec2(0.0f, 0.0f), vec2(0.99f, 0.99f)));
	}
	else {
		rawColor = vec4(1.0f, 1.0f, 1.0f, 1.0f) * fragColor;
	}

	if (rawColor.a == 0) {
		discard;
	}

	if (fogMode == 1) {
		// calculate fog
		float dist = (gl_FragCoord.z / gl_FragCoord.w);
		float fogFactor;
		if (fogStart == fogEnd) {
			fogFactor = 1.0;
		}
		else {
			fogFactor = fogEnd - fogStart;
		}
		fogFactor = clamp((fogEnd - dist) / fogFactor, 0.0f, 1.0f);

		finalColor = mix(fogColor, rawColor, fogFactor);
	}
	else {
		finalColor = rawColor;
	}
}
]]

global Light = @record {
	enabled: cint,
	light_type: cint,
	radius: float32,
	position: rl.vector3,
	direction: rl.vector3,
	color: rl.vector3
}

-- holds graphics information for the vm
global GPU = @record {
	texmem: [GPU_TEXMEM_SIZE]rl.color,
	objmem: [GPU_OBJMEM_SIZE]util.IntFloat,
	cameras2D: [GPU_CAMERAS_COUNT]rl.camera2D,
	cameras: [GPU_CAMERAS_COUNT]rl.camera,
	lights: [GPU_LIGHTS_COUNT]Light,
	gfx_texture: rl.texture,
	gfx_shader: rl.shader,
	gfx_rendertex: rl.renderTexture,
	gfx_font_texture: rl.texture,
	texbank_ptr: *[0]rl.color,
	objbank_ptr: *[0]util.IntFloat,
	ompbank_ptr: *[0]uint8,
	sysmem_ptr: *[0]uint8,
	
	-- shader uniform locations
	mat_model_loc: cint,
	mat_normal_loc: cint,
	tex_mode_loc: cint,
	tex_x_loc: cint,
	tex_y_loc: cint,
	tex_w_loc: cint,
	tex_h_loc: cint,
	fog_mode_loc: cint,
	fog_start_loc: cint,
	fog_end_loc: cint,
	fog_color_loc: cint,
	lighting_mode_loc: cint,
	ambient_factor_loc: cint,
	ambient_color_loc: cint,

	update_tex: boolean, -- set when TEXMEM is updated. when set, TEXMEM is uploaded to the real GPU

	-- "triangle mode" data
	--
	-- RLGL currently doesn't allow primitives created using RL_TRIANGLES to use UV coordinates for textures.
	-- to mimic textured triangles, we use use RL_QUADS and send a copy of the first vertex as the last quad vertex
	triangle_mode: boolean,
	triangle_vert_index: integer,

	proj_matrix_count: uinteger, -- used to track matrix stack
	view_matrix_count: uinteger, -- used to track matrix stack
	matrix_mode: uinteger,
	
	-- graphics state
	cull_mode: uinteger,
	wire_mode: boolean,
	tex_mode: cint,
	tex_x: cint,
	tex_y: cint,
	tex_w: cint,
	tex_h: cint,
	fog_mode: cint,
	fog_start: float32,
	fog_end: float32,
	fog_color: rl.vector4,
	lighting_mode: cint,
	ambient_factor: float32,
	ambient_color: rl.vector3,
	blend_mode: cint,
	viewport_w: cint,
	viewport_h: cint
}

local light_attrib_locs: [GPU_LIGHTS_COUNT][lightAttribute.COUNT]cint

function GPU:clear(col: uint32): void
	local alpha: cuchar = (@cuchar)(col & 0xFF)

	if alpha ~= 0 then
		local clear_color: rl.color = {
			(@cuchar)(col >> 24),
			(@cuchar)((col & 0xFF0000) >> 16),
			(@cuchar)((col & 0x00FF00) >> 8),
			0xFF
		}

		rl.clearBackground(clear_color)
	else
		glClear(GL_DEPTH_BUFFER_BIT) -- clear the depth buffer, but not the color buffer
	end
end

function GPU:camera2D(id: uinteger): void
	local cam: rl.camera2D = self.cameras2D[id]

	rlgl.disableDepthTest()
	
	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
	rlgl.loadIdentity()
	rlgl.ortho(0.0, self.viewport_w, self.viewport_h, 0.0, 0.0, 1.0)

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	rl.beginMode2D(cam)
	
	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:camera3D(id: uinteger): void
	local cam: rl.camera = self.cameras[id]

	-- copy Raylib's BeginMode3D(),
	-- but we don't need to push a new projection matrix

	rlgl.drawRenderBatchActive()

	rlgl.matrixMode(rlgl.PROJECTION)
    rlgl.loadIdentity()

	local aspect: float32 = (@float32)(self.viewport_w) / (@float32)(self.viewport_h)

	-- 0.01 is the near clipping value
	-- 1000.0 is the far clipping value
	-- TODO: allow setting near/far?
	if cam.projection == rl.cameraProjection.PERSPECTIVE then
		local top: float64 = 0.01 * math.tan(cam.fovy * 0.5 * (math.pi / 180.0))
		local right: float64 = top * aspect

		rlgl.frustum(-right, right, -top, top, 0.01, 1000.0)
	elseif cam.projection == rl.cameraProjection.ORTHOGRAPHIC then
		local top: float64 = cam.fovy / 2.0
		local right: float64 = top * aspect

		rlgl.ortho(-right, right, -top, top, 0.01, 1000.0)
	end

	rlgl.matrixMode(rlgl.MODELVIEW)
	rlgl.loadIdentity()

	local mat_view: rl.matrix = rl.matrix.lookAt(cam.position, cam.target, cam.up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	rlgl.enableDepthTest()

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:beginMesh(mode: uint32): void
	switch mode do
		case GPU_LINES then
			self.triangle_mode = false
			mode = rlgl.LINES
		case GPU_TRIANGLES then
			self.triangle_mode = true
			self.triangle_vert_index = 0
			mode = rlgl.QUADS
		case GPU_QUADS then
			self.triangle_mode = false
			mode = rlgl.QUADS
	end

	rl.beginShaderMode(self.gfx_shader)

	rlgl.setTexture(self.gfx_texture.id)
	
	rlgl.begin(mode)
end

function GPU:endMesh(): void
	rlgl.ending()

	rl.endShaderMode()
end

function GPU:matrixMode(mode: uint32): void
	switch mode do
		case GPU_PROJECTION then
			rlgl.matrixMode(rlgl.PROJECTION)
			self.matrix_mode = rlgl.PROJECTION
		case GPU_MODELVIEW then
			rlgl.matrixMode(rlgl.MODELVIEW)
			self.matrix_mode = rlgl.MODELVIEW
	end
end

function GPU:vertex(v: rl.vector3): void
	rlgl.vertex3f(v.x, v.y, v.z)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex3f(v.x, v.y, v.z)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertex2D(v: rl.vector2): void
	rlgl.vertex2f(v.x, v.y)
	
	if self.triangle_mode then
		if self.triangle_vert_index == 0 then
			-- send copy of first vertex to allow textured tris
			rlgl.vertex2f(v.x, v.y)
		end

		self.triangle_vert_index = self.triangle_vert_index + 1
		if self.triangle_vert_index > 2 then
			self.triangle_vert_index = 0
		end
	end
end

function GPU:vertNormal(v: rl.vector3): void
	if self.lighting_mode ~= 0 then
		rlgl.color3f(v.x, v.y, v.z)
	end
end

function GPU:vertUV(v: rl.vector2): void
	rlgl.texCoord2f(v.x, v.y)
end

function GPU:vertColor(col: uint32): void
	if self.lighting_mode == 0 then
		local r: cuchar = (@cuchar)(col >> 24)
		local g: cuchar = (@cuchar)((col & 0xFF0000) >> 16)
		local b: cuchar = (@cuchar)((col & 0x00FF00) >> 8)
		local a: cuchar = (@cuchar)(col & 0xFF)
		
		rlgl.color4ub(r, g, b, a)
	end
end

function GPU:drawChar2D(c: uint8, x: *int32, y: int32, color: rl.color): void
	local fx: float32 = (@float32)($x)
	local fy: float32 = (@float32)(y)

	if c < ' '_u8 then
		c = '?'_u8
	elseif c == ' '_u8 then
		$x = $x + 6
		return
	elseif c == '\t'_u8 then
		$x = $x + 12 -- tabs = 2 spaces
	else
		$x = $x + 6
	end

	if fx <= -6.0 or y <= -9.0 or color.a == 0 then
		return
	end

	local srcx: float32 = (@float32)((c %%% 32) * 6)
	local srcy: float32 = (@float32)((c /// 32) * 9)

	local src_rect: rl.rectangle = {srcx, srcy, 6.0, 9.0}
	local dest_rect: rl.rectangle = {fx, fy, 6.0, 9.0}

	rl.drawTexturePro(self.gfx_font_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, color)
end

-- print2D function for host program, doesn't do formatting
function GPU:print2D(x: int32, y: int32, col: uint32, text: string): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local i: uinteger = 1
	while i <= #text do
		local c: uint8

		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return
		end

		c = text[i]
		
		if c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			self:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end
end

-- printHexNibble2D function for host program, doesn't do formatting
function GPU:printHexNibble2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local nibble: uint8 = val & 0xF
	if nibble < 0xA then
		nibble = '0'_u8 + nibble
	else
		nibble = 'A'_u8 + (nibble - 0xA)
	end

	self:drawChar2D(nibble, &cur_x, y, ray_col)
end

-- printHexByte2D function for host program, doesn't do formatting
function GPU:printHexByte2D(x: int32, y: int32, col: uint32, val: uint8): void
	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local cur_x: int32 = x
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	local msn: uint8 = val >> 4
	if msn < 0xA then
		msn = '0'_u8 + msn
	else
		msn = 'A'_u8 + (msn - 0xA)
	end

	self:drawChar2D(msn, &cur_x, y, ray_col)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return
	end

	local lsn: uint8 = val & 0xF
	if lsn < 0xA then
		lsn = '0'_u8 + lsn
	else
		lsn = 'A'_u8 + (lsn - 0xA)
	end

	self:drawChar2D(lsn, &cur_x, y, ray_col)
end

function GPU:drawRect2D(x: int32, y: int32, w: int32, h: int32, col: uint32): void
	local fx0: float32 = (@float32)(x)
	local fy0: float32 = (@float32)(y)
	local fx1: float32 = (@float32)(x + w)
	local fy1: float32 = (@float32)(y + h)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	rl.drawRectangle(x, y, w, h, ray_col)
end

function GPU:uploadOBJMEMVertex(index: uint32): void
	local word_index: uinteger = index * 9

	self:vertColor(self.objmem[word_index + 8].u)
	self:vertUV({self.objmem[word_index + 6].f, self.objmem[word_index + 7].f})
	self:vertNormal({self.objmem[word_index + 3].f, self.objmem[word_index + 4].f, self.objmem[word_index + 5].f})
	self:vertex({self.objmem[word_index].f, self.objmem[word_index + 1].f, self.objmem[word_index + 2].f})
end

function GPU:drawObjEx(mode: uint32, start: uint32, n: uint32): void
	if n == 0 then
		return
	end

	self:beginMesh(mode)
		switch mode do
			case GPU_LINES then
				for i = 0, < n do
					local line_start: uint32 = start + (i * 2)
					self:uploadOBJMEMVertex(line_start)
					self:uploadOBJMEMVertex(line_start + 1)
				end
			case GPU_TRIANGLES then
				for i = 0, < n do
					local tri_start: uint32 = start + (i * 3)
					self:uploadOBJMEMVertex(tri_start)
					self:uploadOBJMEMVertex(tri_start + 1)
					self:uploadOBJMEMVertex(tri_start + 2)
				end
			case GPU_QUADS then
				for i = 0, < n do
					-- get vertices
					local quad_start: uint32 = start + (i * 4)
					self:uploadOBJMEMVertex(quad_start)
					self:uploadOBJMEMVertex(quad_start + 1)
					self:uploadOBJMEMVertex(quad_start + 2)
					self:uploadOBJMEMVertex(quad_start + 3)
				end
		end
	self:endMesh()
end

function GPU:drawObj(id: uint32): void
	-- get objmap entry pointer
	local entry_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84 + (id * 12)])

	-- get mode
	local mode: uint32 = ((@uint32)(entry_ptr[0]) << 24) | ((@uint32)(entry_ptr[1]) << 16) | ((@uint32)(entry_ptr[2]) << 8) | (@uint32)(entry_ptr[3])

	-- get start
	local start: uint32 = ((@uint32)(entry_ptr[4]) << 24) | ((@uint32)(entry_ptr[5]) << 16) | ((@uint32)(entry_ptr[6]) << 8) | (@uint32)(entry_ptr[7])

	-- get n
	local n: uint32 = ((@uint32)(entry_ptr[8]) << 24) | ((@uint32)(entry_ptr[9]) << 16) | ((@uint32)(entry_ptr[10]) << 8) | (@uint32)(entry_ptr[11])

	self:drawObjEx(mode, start, n)
end

function GPU:texture(x: int32, y: int32, w: int32, h: int32): void
	self.tex_x = (@cint)(x)
	self.tex_y = (@cint)(y)
	self.tex_w = (@cint)(w)
	self.tex_h = (@cint)(h)
	
	rl.setShaderValue(self.gfx_shader, self.tex_x_loc, &self.tex_x, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_y_loc, &self.tex_y, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_w_loc, &self.tex_w, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.tex_h_loc, &self.tex_h, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:updateVertexShaderMatrices(): void
	-- get required matrices
	local matModel: rl.matrix = rlgl.getMatrixTransform()
	local matNormal: rl.matrix = rl.matrix.transpose(rl.matrix.invert(matModel))

	-- upload to vertex shader
	rl.setShaderValueMatrix(self.gfx_shader, self.mat_model_loc, matModel)
	rl.setShaderValueMatrix(self.gfx_shader, self.mat_normal_loc, matNormal)
end

function GPU:setBlendMode(mode: uint32): void
	self.blend_mode = mode
	rlgl.setBlendMode(self.blend_mode)
end

function GPU:setLightingMode(mode: uint32): void
	self.lighting_mode = mode
	rl.setShaderValue(self.gfx_shader, self.lighting_mode_loc, &self.lighting_mode, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setAmbientFactor(factor: float32): void
	self.ambient_factor = factor / 100.0
	rl.setShaderValue(self.gfx_shader, self.ambient_factor_loc, &self.ambient_factor, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:setAmbientColor(col: uint32): void
	self.ambient_color = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, self.ambient_color_loc, &self.ambient_color, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightEnabled(id: uint32, enabled: uint32): void
	self.lights[id].enabled = (enabled ~= 0) and 1 or 0
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.ENABLED], &self.lights[id].enabled, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setLightType(id: uint32, light_type: uint32): void
	self.lights[id].light_type = (@cint)(light_type)
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.TYPE], &self.lights[id].light_type, rl.shaderUniformDataType.UNIFORM_INT)
end

function GPU:setLightRadius(id: uint32, radius: float32): void
	self.lights[id].radius = radius
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.RADIUS], &self.lights[id].radius, rl.shaderUniformDataType.UNIFORM_FLOAT)
end

function GPU:setLightPosition(id: uint32, pos: rl.vector3): void
	self.lights[id].position = pos
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.POSITION], &self.lights[id].position, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightDirection(id: uint32, dir: rl.vector3): void
	self.lights[id].direction = dir
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.DIRECTION], &self.lights[id].direction, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:setLightColor(id: uint32, col: uint32): void
	self.lights[id].color = {
		(@float32)(col >> 24) / 255.0,
		(@float32)((col >> 16) & 0xFF) / 255.0,
		(@float32)((col >> 8) & 0xFF) / 255.0
	}
	rl.setShaderValue(self.gfx_shader, light_attrib_locs[id][lightAttribute.COLOR], &self.lights[id].color, rl.shaderUniformDataType.UNIFORM_VEC3)
end

function GPU:loadTexBank(bank: uint8): void
	local src: *[0]rl.color = &self.texbank_ptr[GPU_TEXMEM_SIZE*bank]
	memory.copy(&self.texmem, src, GPU_TEXMEM_SIZE*#rl.color)
	self.update_tex = true
end

function GPU:loadObjBank(bank: uint8): void
	-- load objbank
	local src: *[0]util.IntFloat = &self.objbank_ptr[(GPU_OBJMEM_SIZE) * bank]
	memory.copy(&self.objmem, src, GPU_OBJMEM_SIZE * #util.IntFloat)

	-- load ompbank
	local objmap_ptr: *[0]uint8 = (@*[0]uint8)(&self.sysmem_ptr[84])
	local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.ompbank_ptr[(GPU_OBJMAP_SIZE * bank)])
	memory.copy(objmap_ptr, bank_ptr, GPU_OBJMAP_SIZE)

	self.update_tex = true
end

function GPU:loadTexturesheet(filename: string, bank_index: integer): boolean
	local img: rl.image = rl.loadImage(filename)

	if not rl.isImageReady(img) then
		return false
	end

	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	memory.copy(&self.texbank_ptr[GPU_TEXMEM_SIZE * bank_index], img.data, GPU_TEXMEM_SIZE * #rl.color)
	
	rl.unloadImage(img)

	return true
end

function GPU:loadModel(filename: string, bank_index: uint32, start_index: uint32): (boolean, uint32)
	local model: rl.model = rl.loadModel(filename)

	if not rl.isModelReady(model) then
		print("failed to load model")
		return false, 0
	end

	local vertex_count: uint32
	local bank_ptr: *[0]util.IntFloat = &self.objbank_ptr[(GPU_OBJMEM_SIZE) * bank_index]

	for i = 0, < model.meshCount do
		local mesh: rl.mesh = (@*[0]rl.mesh)(model.meshes)[i]
		local posptr: *[0]float32 = (@*[0]float32)(mesh.vertices)
		local uvptr: *[0]float32 = (@*[0]float32)(mesh.texcoords)
		local colptr: *[0]cuchar = (@*[0]cuchar)(mesh.colors)
		local normptr: *[0]float32 = (@*[0]float32)(mesh.normals)
		local idxptr: *[0]cushort = (@*[0]cushort)(mesh.indices)
		
		if idxptr ~= nilptr then
			for j = 0, < mesh.triangleCount do
				for k = 0, < 3 do
					local idx: cushort = idxptr[j * 3 + k]
					local posindex: uinteger = idx * 3
					local uvindex: uinteger = idx * 2
					local colindex: uinteger = idx * 4
					
					local pos: rl.vector3 = {
						posptr[posindex],
						posptr[posindex + 1],
						posptr[posindex + 2]
					}
					
					local uv: rl.vector2 = {
						uvptr[uvindex],
						uvptr[uvindex + 1]
					}
					
					local col: uint32
					if colptr ~= nilptr then
						col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
					else
						col = 0xFFFFFFFF
					end
					
					local objmemindex: uinteger = (start_index + vertex_count) * 9
					bank_ptr[objmemindex].f = pos.x
					bank_ptr[objmemindex + 1].f = pos.y
					bank_ptr[objmemindex + 2].f = pos.z
					bank_ptr[objmemindex + 6].f = uv.x
					bank_ptr[objmemindex + 7].f = uv.y
					bank_ptr[objmemindex + 8].u = col

					vertex_count = vertex_count + 1
				end
			end
		else
			for j = 0, < mesh.vertexCount do
				local posindex: uinteger = j * 3
				local uvindex: uinteger = j * 2
				local colindex: uinteger = j * 4
				local normindex: uinteger = j * 3
				
				local pos: rl.vector3 = {
					posptr[posindex],
					posptr[posindex + 1],
					posptr[posindex + 2]
				}

				local norm: rl.vector3 = {
					normptr[normindex],
					normptr[normindex + 1],
					normptr[normindex + 2]
				}
				
				local uv: rl.vector2 = {
					uvptr[uvindex],
					uvptr[uvindex + 1]
				}
				
				local col: uint32
				if colptr ~= nilptr then
					col = ((@uint32)(colptr[colindex]) << 24) | ((@uint32)(colptr[colindex + 1]) << 16) | ((@uint32)(colptr[colindex + 2]) << 8) | (@uint32)(colptr[colindex + 3])
				else
					col = 0xFFFFFFFF
				end
				
				local objmemindex: uinteger = (start_index + vertex_count) * 9
				bank_ptr[objmemindex].f = pos.x
				bank_ptr[objmemindex + 1].f = pos.y
				bank_ptr[objmemindex + 2].f = pos.z

				bank_ptr[objmemindex + 3].f = norm.x
				bank_ptr[objmemindex + 4].f = norm.y
				bank_ptr[objmemindex + 5].f = norm.z

				bank_ptr[objmemindex + 6].f = uv.x
				bank_ptr[objmemindex + 7].f = uv.y
				bank_ptr[objmemindex + 8].u = col

				vertex_count = vertex_count + 1
			end
		end
	end
	
	rl.unloadModel(model)
	
	return true, vertex_count
end

function GPU:resetMatrixStack(): void
	rlgl.matrixMode(rlgl.PROJECTION)

	while self.proj_matrix_count > 0 do
		rlgl.popMatrix()
		self.proj_matrix_count = self.proj_matrix_count - 1
	end

	rlgl.matrixMode(rlgl.MODELVIEW)

	while self.view_matrix_count > 0 do
		rlgl.popMatrix()
		self.view_matrix_count = self.view_matrix_count - 1
	end
end

function GPU:enableRenderState(): void
	switch self.cull_mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		else
			rlgl.disableBackfaceCulling()
	end

	if self.wire_mode then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	rlgl.enableScissorTest()
	rlgl.scissor(0, 0, GPU_VSCREEN_W, GPU_VSCREEN_H)

	self:setBlendMode(self.blend_mode)

	self.matrix_mode = rlgl.MODELVIEW
end

function GPU:disableRenderState(): void
	rlgl.enableBackfaceCulling()
	rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
	rlgl.disableWireMode()
	rlgl.disableScissorTest()
	rlgl.viewport(0, 0, GPU_SCREEN_W, GPU_SCREEN_H)
	self:setBlendMode(rl.blendMode.ALPHA)
end

function GPU:resetGPU(): void
	for i = 0, < GPU_CAMERAS_COUNT do
		self.cameras2D[i] = {
			offset={0.0,0.0},
			target={0.0,0.0},
			rotation=0.0,
			zoom=1.0
		}

		self.cameras[i] = {
			position={0,0,4},
			target={0,0,0},
			up={0,1,0},
			fovy=45,
			projection=rl.cameraProjection.PERSPECTIVE
		}
	end

	for i = 0, < GPU_LIGHTS_COUNT do
		self.lights[i] = {
			0,
			0,
			0.0,
			{0,0,0},
			{0,-1,0},
			{0,0,0}
		}
	end

	self.cull_mode = 0
	self.wire_mode = false
	
	self.tex_mode = 0
	rl.setShaderValue(self.gfx_shader, self.tex_mode_loc, &self.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)
	
	self.fog_mode = 0
	self.fog_start = 700.0
	self.fog_end = 1000.0
	self.fog_color = {1.0, 1.0, 1.0, 1.0}
	self.lighting_mode = 0
	self.ambient_factor = 0.0
	self.ambient_color = {0.0, 0.0, 0.0}
	rl.setShaderValue(self.gfx_shader, self.fog_mode_loc, &self.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.fog_start_loc, &self.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_end_loc, &self.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.fog_color_loc, &self.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)
	rl.setShaderValue(self.gfx_shader, self.lighting_mode_loc, &self.lighting_mode, rl.shaderUniformDataType.UNIFORM_INT)
	rl.setShaderValue(self.gfx_shader, self.ambient_factor_loc, &self.ambient_factor, rl.shaderUniformDataType.UNIFORM_FLOAT)
	rl.setShaderValue(self.gfx_shader, self.ambient_color_loc, &self.ambient_color, rl.shaderUniformDataType.UNIFORM_VEC3)
	
	self:texture(0, 0, 64, 64)

	self.viewport_w = GPU_VSCREEN_W
	self.viewport_h = GPU_VSCREEN_H
	self.proj_matrix_count = 0
	self.view_matrix_count = 0
end

function GPU:init(sysmem_ptr: *[0]uint8, texbank_ptr: *[0]rl.color, objbank_ptr: *[0]util.IntFloat, ompbank_ptr: *[0]uint8): void
	self.sysmem_ptr = sysmem_ptr
	self.texbank_ptr = texbank_ptr
	self.objbank_ptr = objbank_ptr
	self.ompbank_ptr = ompbank_ptr

	rl.setConfigFlags(rl.configFlags.VSYNC_HINT) -- enable vsync
	rl.setTraceLogLevel(rl.traceLogLevel.ERROR) -- only log errors

	rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
	--[[
	if rl.isWindowReady() then
		-- kinda gross "hack" to check if we need the HighDPI flag
		local dpi_scale: rl.vector2 = rl.getWindowScaleDPI()
		if dpi_scale.x > 1.0 or dpi_scale.y > 1.0 then
			rl.closeWindow()
			
			rl.setConfigFlags(rl.configFlags.VSYNC_HINT | rl.configFlags.WINDOW_HIGHDPI) -- enable vsync and HighDPI
			rl.initWindow(GPU_SCREEN_W, GPU_SCREEN_H, "ERA-3D")
		end
	end
	]]

	rl.setTargetFPS(30)
	rl.setExitKey(rl.keyboardKey.NULL)

	self.gfx_rendertex = rl.loadRenderTexture(GPU_VSCREEN_W, GPU_VSCREEN_H)

	local img: rl.image = rl.genImageColor(GPU_TEXMEM_WIDTH, GPU_TEXMEM_HEIGHT, {0,0,0,0})
	if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
		rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
	end
	--memory.copy(&self.texmem, img.data, GPU_TEXMEM_SIZE * #rl.color)
	self.gfx_texture = rl.loadTextureFromImage(img)
	rl.unloadImage(img)

	self.gfx_font_texture = rl.loadTexture("assets/font.png")
	
	self.gfx_shader = rl.loadShaderFromMemory(GPU_VERT_SRC, GPU_FRAG_SRC)
	
	self.mat_model_loc = rl.getShaderLocation(self.gfx_shader, "matModel")
	self.mat_normal_loc = rl.getShaderLocation(self.gfx_shader, "matNormal")
	self.tex_mode_loc = rl.getShaderLocation(self.gfx_shader, "texMode")
	self.tex_x_loc = rl.getShaderLocation(self.gfx_shader, "texX")
	self.tex_y_loc = rl.getShaderLocation(self.gfx_shader, "texY")
	self.tex_w_loc = rl.getShaderLocation(self.gfx_shader, "texW")
	self.tex_h_loc = rl.getShaderLocation(self.gfx_shader, "texH")
	self.fog_mode_loc = rl.getShaderLocation(self.gfx_shader, "fogMode")
	self.fog_start_loc = rl.getShaderLocation(self.gfx_shader, "fogStart")
	self.fog_end_loc = rl.getShaderLocation(self.gfx_shader, "fogEnd")
	self.fog_color_loc = rl.getShaderLocation(self.gfx_shader, "fogColor")
	self.lighting_mode_loc = rl.getShaderLocation(self.gfx_shader, "lightingMode")
	self.ambient_factor_loc = rl.getShaderLocation(self.gfx_shader, "ambientFactor")
	self.ambient_color_loc = rl.getShaderLocation(self.gfx_shader, "ambientColor")

	-- get light attribute locs
	for i = 0, < GPU_LIGHTS_COUNT do
		light_attrib_locs[i][lightAttribute.ENABLED]   = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].enabled", i))
		light_attrib_locs[i][lightAttribute.TYPE]      = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].type", i))
		light_attrib_locs[i][lightAttribute.RADIUS]    = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].radius", i))
		light_attrib_locs[i][lightAttribute.POSITION]  = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].position", i))
		light_attrib_locs[i][lightAttribute.DIRECTION] = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].direction", i))
		light_attrib_locs[i][lightAttribute.COLOR]     = rl.getShaderLocation(self.gfx_shader, string.format("lights[%d].color", i))
	end

	self:resetGPU()

	self:loadModel("test_data/viewcube.obj", 0, 0)
end

function GPU:cleanup(): void
	rl.unloadShader(self.gfx_shader)
	rl.unloadTexture(self.gfx_font_texture)
	rl.unloadTexture(self.gfx_texture)
	rl.unloadRenderTexture(self.gfx_rendertex)

	rl.closeWindow()
end
