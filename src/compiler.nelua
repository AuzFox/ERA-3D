require("string")
require("coroutine")
require("io")

require("definitions")

local type_names: []string = {
	"void",
	"int",
	"float",
	"vec2",
	"vec3",
	"struct",
	"string",
	"function",
	"unmapped type (8)",
	"unmapped type (9)",
	"unmapped type (10)",
	"unmapped type (11)",
	"unmapped type (12)",
	"unmapped type (13)",
	"unmapped type (14)",
	"unmapped type (15)"
}

local token_names: []string = {
	"int literal",
	"float literal",
	"string literal",
	"void",
	"int",
	"float",
	"vec2",
	"vec3",
	"struct identifier",
	"string",
	"struct",
	"function",
	"enum",
	"identifier",
	"else",
	"if",
	"return",
	"break",
	"continue",
	"sizeof",
	"for",
	"while",
	"...",
	"!",
	"~",
	"=",
	"?",
	"||",
	"&&",
	"|",
	"^",
	"&",
	"==",
	"!=",
	"<",
	">",
	"<=",
	">=",
	"<<",
	">>",
	">>>",
	"+",
	"-",
	"*",
	"/",
	"%",
	"->",
	".",
	"["
}

local function getTypeName(info: TypeInfo): string
	local sb: stringbuilder
	local full_type: uinteger = info.type_id
	local base_type: uinteger = info.type_id & (EVMType.POINTER - 1)

	if base_type < EVMType.VEC3 then
		sb:write(type_names[base_type])
	else
		sb:write(info.structref.name)
	end

	while full_type >= EVMType.POINTER do
		sb:writebyte('*'_u8)
		full_type = full_type - EVMType.POINTER
	end

	return sb:__tostring()
end

local function getTokenString(token: uinteger): string
	if token == 0 then
		return "EOF"
	elseif token < Token.INT_LITERAL then
		return string.format("%c", token)
	else
		return token_names[token - Token.INT_LITERAL]
	end
end

local function sizeOfType(info: TypeInfo): uint16
	-- returns size in words
	if (info.type_id >= EVMType.VEC2) and (info.type_id <= EVMType.STRING) then
		return info.structref.size
	end
	
	return 1
end

local function sizePointedTo(info: TypeInfo): uint16
	-- returns size in words
	local type_pointed_to: uinteger = info.type_id - EVMType.POINTER
	
	if (type_pointed_to >= EVMType.VEC2) and (type_pointed_to <= EVMType.STRING) then
		return info.structref.size
	end
	
	return 1
end

function Struct:addMember(member: *Identifier): void
	self.members:push(member)
	self.member_map[member.name] = #self.members

	self.size = self.size + sizeOfType(member.type_info)
end

function Struct:hasMember(name: string): boolean
	return self.member_map:has(name)
end

function Struct:getMember(name: string): (boolean, *Identifier)
	local has: boolean
	local index: uinteger

	has, index = self.member_map:has_and_get(name)
	if has then return true, self.members[index] end

	return false, nilptr
end

function EVM:pushScope(): void
	self.sym_tables:push(new(@hashmap(string, *Identifier)))
	self.scope_sizes:push(0)
end

function EVM:popScope(): void
	self.sym_tables:pop()
	self.scope_sizes:pop()
end

function EVM:addScopedSymbol(name: string, id: *Identifier): void
	self.sym_tables[#self.sym_tables][name] = id
end

function EVM:getScopeLocalsSize(): uinteger
	return self.scope_sizes[#self.scope_sizes]
end

function EVM:incScopeLocalsSize(size: uinteger): void
	local total: uinteger = self:getScopeLocalsSize()
	total = total + size
	self.scope_sizes[#self.scope_sizes] = total
end

function EVM:pushLoop(start: uint16): void
	self.loop_info_stack:push((@LoopInfo){loop_start = start})
end

function EVM:popLoop(): void
	local info: LoopInfo = self.loop_info_stack:pop()

	-- patch break jumps
	while info.break_count > 0 do
		local index: uint16 = self.loop_break_stack:pop()

		self.bytecode[index] = (info.loop_end >> 8)
		self.bytecode[index + 1] = (info.loop_end & 0xFF)

		info.break_count = info.break_count - 1
	end

	-- patch step jumps
	while info.step_count > 0 do
		local index: uint16 = self.loop_step_stack:pop()

		self.bytecode[index] = (info.loop_step >> 8)
		self.bytecode[index + 1] = (info.loop_step & 0xFF)

		info.step_count = info.step_count - 1
	end

	local size: uint16 = self.prev_scope_size
	while info.del_l_count > 0 do
		local index: uint16 = self.loop_del_l_stack:pop()
		
		if size > 0 then
			self.bytecode[index] = (size >> 8)
			self.bytecode[index + 1] = (size & 0xFF)
		end

		info.del_l_count = info.del_l_count - 1
	end
end

function EVM:getCurrentLoopInfo(): LoopInfo
	return self.loop_info_stack[#self.loop_info_stack]
end

function EVM:loopHasStep(): boolean
	return self.loop_info_stack[#self.loop_info_stack].has_step
end

function EVM:getLoopStart(): uint16
	return self.loop_info_stack[#self.loop_info_stack].loop_start
end

function EVM:getLoopStep(): uint16
	return self.loop_info_stack[#self.loop_info_stack].loop_step
end

function EVM:getLoopEnd(): uint16
	return self.loop_info_stack[#self.loop_info_stack].loop_end
end

function EVM:setLoopHasStep(): void
	self.loop_info_stack[#self.loop_info_stack].has_step = true
end

function EVM:setLoopStep(index: uint16): void
	local info: LoopInfo = self.loop_info_stack:pop()
	info.loop_step = index
	self.loop_info_stack:push(info)
end

function EVM:setLoopEnd(index: uint16): void
	self.loop_info_stack[#self.loop_info_stack].loop_end = index
end

function EVM:addBreak(index: uint16): void
	self.loop_break_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.break_count = info.break_count + 1
	self.loop_info_stack:push(info)
end

function EVM:addJumpToStep(index: uint16): void
	self.loop_step_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.step_count = info.step_count + 1
	self.loop_info_stack:push(info)
end

function EVM:addDelL(index: uint16): void
	self.loop_del_l_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.del_l_count = info.del_l_count + 1
	self.loop_info_stack:push(info)
end

function EVM:lookupID(name: string): boolean
	self.has_id, self.current_id = self.keywords:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.constants:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.api_ids:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.builtin_struct_ids:has_and_get(name)
	if self.has_id then return true end
	
	self.has_id, self.current_id = self.struct_ids:has_and_get(name)
	if self.has_id then return true end

	-- search scope stack
	for i = #self.sym_tables, > 0, -1  do
		local table: *hashmap(string, *Identifier) = self.sym_tables[i]
		self.has_id, self.current_id = table:has_and_get(name)
		if self.has_id then return true end
	end

	return false
end

function EVM:resetCompiler(): void
	self.token = 0
	self.token_val = 0
	self.token_valf = 0
	self.prev_token = 0
	self.prev_scope_size = 0
	self.expr_type = {}
	self.local_index = 0
	self.mlcomment_level = 0
	self.prev_opcode = 0
	self.has_id = false
	self.skip_next_id_lookup = false
	self.current_id = nilptr
	self.current_id_name = ""
	self.current_func_id = nilptr
	self.sb:clear()
	self.struct_ids:clear()
	self.sym_tables:clear()
	self.scope_sizes:clear()
	self.loop_info_stack:clear()
	self.loop_break_stack:clear()
	self.loop_step_stack:clear()
	self.loop_del_l_stack:clear()
end

function EVM:emitOp(val: uint8): void
	self.bytecode[self.bytecode_len] = val

	self.bytecode_len = self.bytecode_len + 1
	self.prev_opcode = val
end

function EVM:emit8(val: uint8): void
	self.bytecode[self.bytecode_len] = val

	self.bytecode_len = self.bytecode_len + 1
end

function EVM:emit16(val: uint16): void
	self.bytecode[self.bytecode_len] = val >> 8
	self.bytecode[self.bytecode_len + 1] = val & 0xFF

	self.bytecode_len = self.bytecode_len + 2
end

function EVM:emit32(val: uint32): void
	self.bytecode[self.bytecode_len] = val >> 24
	self.bytecode[self.bytecode_len + 1] = (val & 0xFF0000) >> 16
	self.bytecode[self.bytecode_len + 2] = (val & 0x00FF00) >> 8
	self.bytecode[self.bytecode_len + 3] = val & 0xFF

	self.bytecode_len = self.bytecode_len + 4
end

function EVM:emitF(val: float32): void
	local v: IntFloat = {f=val}

	self:emit32(v.u)
end

local function getChar(vm: *EVM): byte
	if vm.line > #core.src_lines then
		vm.token = 0
		return vm.token
	end
	
	if vm.line ~= vm.prev_line then
		vm.current_src_line = core.src_lines[vm.line]
		vm.prev_line = vm.line
	end

	if vm.src_index >= #vm.current_src_line then
		vm.token = '\n'_u8
	else
		vm.token = vm.current_src_line[vm.src_index]
	end
	
	return vm.token
end

local function next(vm: *EVM): void
	vm.prev_src_index = vm.src_index
	vm.prev_token = vm.token

	while getChar(vm) ~= 0 do
		vm.src_index = vm.src_index + 1

		if vm.token == '\n'_u8 then
			vm.line = vm.line + 1
			vm.src_index = 1
		elseif (vm.token >= 'a'_u8 and vm.token <= 'z'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'Z'_u8) or (vm.token == '_'_u8) then
			-- identifier
			vm.sb:clear()
			vm.sb:writebyte(vm.token)

			while true do
				getChar(vm)
				if (vm.token >= 'a'_u8 and vm.token <= 'z'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'Z'_u8) or (vm.token >= '0'_u8 and vm.token <= '9'_u8) or (vm.token == '_'_u8) then
					vm.src_index = vm.src_index + 1
					vm.sb:writebyte(vm.token)
				else
					break
				end
			end
			
			vm.current_id_name = vm.sb:__tostring()
			if vm.skip_next_id_lookup then
				vm.skip_next_id_lookup = false
				vm.token = Token.ID
				vm.has_id = true
				return
			end
			
			vm:lookupID(vm.current_id_name)

			if vm.has_id then
				vm.token = vm.current_id.token
				return
			else
				-- make new id
				vm.current_id = new(@Identifier)
				vm.current_id.token = Token.ID
				vm.current_id.name = vm.current_id_name
				vm.token = vm.current_id.token
				return
			end
		elseif vm.token >= '0'_u8 and vm.token <= '9'_u8 then
			local isfloat: boolean = false
			-- number
			vm.token_val = vm.token - '0'_u8
			if vm.token_val == 0 and getChar(vm) == 'x'_u8 then
				-- hex
				vm.src_index = vm.src_index + 1
				while true do
					getChar(vm)
					if (vm.token >= '0'_u8 and vm.token <= '9'_u8) or (vm.token >= 'a'_u8 and vm.token <= 'f'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'F'_u8) then
						vm.token_val = vm.token_val * 16 + (vm.token & 15)
						if vm.token >= 'A'_u8 then
							vm.token_val = vm.token_val + 9
						end
						vm.src_index = vm.src_index + 1
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						break
					end
				end
			elseif vm.token_val == 0 and getChar(vm) == 'b'_u8 then
				-- binary
				vm.src_index = vm.src_index + 1
				while true do
					getChar(vm)
					if vm.token == '0'_u8 or vm.token == '1'_u8 then
						vm.token_val = (vm.token_val * 2) + (vm.token - '0'_u8)
						vm.src_index = vm.src_index + 1
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						break
					end
				end
			else
				-- decimal
				local fract: float32 = 1.0
				while true do
					getChar(vm)
					if vm.token >= '0'_u8 and vm.token <= '9'_u8 then
						if isfloat then
							fract = fract / 10.0
							vm.token_valf = (vm.token_valf * 10) + (@float32)(vm.token - '0'_u8)
						else
							vm.token_val = (vm.token_val * 10) + (vm.token - '0'_u8)
						end
						vm.src_index = vm.src_index + 1
					elseif vm.token == '.'_u8 then
						if not isfloat then
							isfloat = true
							vm.token_valf = (@float32)(vm.token_val)
							vm.src_index = vm.src_index + 1
						else
							vm.error = string.format("line %d:\nmultiple decimal points in float literal", vm.line)
							vm.compile_err = true
							coroutine.yield()
						end
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						if isfloat then
							vm.token_valf = vm.token_valf * fract
						end
						break
					end
				end
			end
			if isfloat then
				vm.token = Token.FLOAT_LITERAL
			else
				vm.token = Token.INT_LITERAL
			end
			return
		elseif vm.token == '"'_u8 or vm.token == '\''_u8 then
			-- string/char literal
			local start: uinteger = vm.token
			local len: uinteger = 0
			local rom_start: uinteger = vm.rom_len

			-- TODO: reuse strings instead of repeating them in ROM

			while true do
				getChar(vm)
				if vm.token ~= 0 and vm.token ~= start then
					vm.token_val = vm.token
					vm.src_index = vm.src_index + 1
					if vm.token == '\\'_u8 then -- escape code
						getChar(vm)
						vm.src_index = vm.src_index + 1
						switch vm.token do
							case '\\'_u8 then -- \\
								vm.token_val = '\\'_u8
							case 'n'_u8 then -- \n
								vm.token_val = '\n'_u8
							else
								vm.error = string.format(
									"line %d:\ninvalid escape sequence '\\%c' in string",
									vm.line,
									vm.token
								)
								vm.compile_err = true
								coroutine.yield()
						end
					elseif vm.token == '\n'_u8 then
						vm.error = string.format("line %d:\nstring literals cannot contain unescaped newline characters", vm.line)
						vm.compile_err = true
						coroutine.yield()
					end
					
					if start == '"'_u8 then
						if vm.rom_len >= MEMORY_ROM_SIZE_ELEMENTS then
							vm.error = string.format("line %d:\nmaximum ROM size exceeded", vm.line)
							vm.compile_err = true
							coroutine.yield()
						end
						vm.cart.rom[vm.rom_len] = (@uint8)(vm.token_val)
						vm.rom_len = vm.rom_len + 1
					end
					
					len = len + 1
				else
					break
				end
			end

			vm.src_index = vm.src_index + 1

			if start == '"'_u8 then
				vm.string_len = len
				
				if len ~= 0 then
					vm.token_val = MEMORY_ROM_START_ADDR + rom_start
				else
					vm.token_val = MEMORY_NULL
				end

				vm.token = Token.STRING_LITERAL
			else
				if len == 1 then
					vm.token = Token.INT_LITERAL
				else
					vm.error = string.format("line %d:\ncharacter literals may only contain one character", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end
			end

			return
		elseif vm.token == '/'_u8 then
			local nxt: uinteger = getChar(vm)
			switch nxt do
				case '/'_u8 then -- single line comment
					vm.src_index = vm.src_index + 1
					while true do
						getChar(vm)
						if vm.token ~= 0 and vm.token ~= '\n'_u8 then
							vm.src_index = vm.src_index + 1
						else
							break
						end
					end
				case '*'_u8 then -- multi-line comment
					vm.mlcomment_level = 1
					vm.src_index = vm.src_index + 1
					while true do
						getChar(vm)
						if vm.token == 0 then
							break
						elseif vm.token == '*'_u8 then
							vm.src_index = vm.src_index + 1
							getChar(vm)
							if vm.token == '/'_u8 then
								vm.src_index = vm.src_index + 1
								vm.mlcomment_level = vm.mlcomment_level - 1
								if vm.mlcomment_level == 0 then
									break
								end
							elseif vm.token == '\n'_u8 then
								vm.line = vm.line + 1
								vm.src_index = 1
							end
						elseif vm.token == '/'_u8 then
							vm.src_index = vm.src_index + 1
							getChar(vm)
							if vm.token == '*'_u8 then
								vm.src_index = vm.src_index + 1
								vm.mlcomment_level = vm.mlcomment_level + 1
							elseif vm.token == '\n'_u8 then
								vm.line = vm.line + 1
								vm.src_index = 1
							end
						elseif vm.token == '\n'_u8 then
							vm.src_index = vm.src_index + 1
							vm.line = vm.line + 1
							vm.src_index = 1
						else
							vm.src_index = vm.src_index + 1
						end
					end
				else
					vm.token = Token.DIV
					return
			end
		elseif vm.token == '='_u8 then
			if getChar(vm) == '='_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.EQ
			else
				vm.token = Token.ASSIGN
			end
			
			return
		elseif vm.token == '+'_u8 then
			vm.token = Token.ADD
			return
		elseif vm.token == '-'_u8 then
			if getChar(vm) == '>'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.ARROW
			else
				vm.token = Token.SUB
			end
			
			return
		elseif vm.token == '*'_u8 then
			vm.token = Token.MUL
			return
		elseif vm.token == '!'_u8 then
			if getChar(vm) == '='_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.NE
			else
				vm.token = Token.LNOT
			end
			
			return
		elseif vm.token == '<'_u8 then
			local nxt: uinteger = getChar(vm)
			switch nxt do
				case '='_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.LE
				case '<'_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.LSHIFT
				else
					vm.token = Token.LT
			end
			
			return
		elseif vm.token == '>'_u8 then
			local nxt: uinteger = getChar(vm)
			switch nxt do
				case '='_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.GE
				case '>'_u8 then
					vm.src_index = vm.src_index + 1
					if getChar(vm) == '>'_u8 then
						vm.src_index = vm.src_index + 1
						vm.token = Token.ARSHIFT
					else
						vm.token = Token.RSHIFT
					end
				else
					vm.token = Token.GT
			end
			
			return
		elseif vm.token == '|'_u8 then
			if getChar(vm) == '|'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.LOR
			else
				vm.token = Token.OR
			end
			
			return
		elseif vm.token == '&'_u8 then
			if getChar(vm) == '&'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.LAND
			else
				vm.token = Token.AND
			end
			
			return
		elseif vm.token == '^'_u8 then
			vm.token = Token.XOR
			return
		elseif vm.token == '~'_u8 then
			vm.token = Token.NOT
			return
		elseif vm.token == '%'_u8 then
			vm.token = Token.MOD
			return
		elseif vm.token == '['_u8 then
			vm.token = Token.BRAK
			return
		elseif vm.token == '?'_u8 then
			vm.token = Token.COND
			return
		elseif vm.token == '.'_u8 then
			if getChar(vm) == '.'_u8 then
				vm.src_index = vm.src_index + 1
				if getChar(vm) == '.'_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.VARARGS
				else
					vm.error = string.format("line %d:\ninvalid token '..'", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end
			else
				vm.token = Token.DOT
			end
			
			return
		elseif (vm.token == ';'_u8 or vm.token == '{'_u8 or vm.token == '}'_u8 or vm.token == '('_u8 or vm.token == ')'_u8 or vm.token == ']'_u8 or vm.token == ','_u8 or vm.token == ':'_u8) then
			return
		end
	end
end

local function match(vm: *EVM, tk: uinteger): void
	if vm.token == tk then
		next(vm)
	else
		vm.error = string.format(
			"line %d:\nexpected token `%s`, got `%s`",
			vm.line,
			getTokenString(tk),
			getTokenString(vm.token)
		)
		vm.compile_err = true
		coroutine.yield()
	end
end

local function operatorTypeCheck(vm: *EVM, operator: uinteger, target_info: TypeInfo, allow_ptrs: boolean): void
	local target_type: uinteger = target_info.type_id

	if vm.expr_type.type_id == EVMType.VOID then
		vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
		vm.compile_err = true
		coroutine.yield()
	elseif target_type ~= vm.expr_type.type_id then
		-- can we convert types?
		local can_convert: boolean = false
		
		if target_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
			can_convert = true
			vm:emitOp(Opcode.FTOI)
		elseif target_type == EVMType.INT and (vm.expr_type.type_id == EVMType.VEC2 or vm.expr_type.type_id == EVMType.VEC3) then
			can_convert = operator == Token.MUL
		elseif target_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
			can_convert = true
			vm:emitOp(Opcode.ITOF)
		elseif target_type == EVMType.FLOAT and (vm.expr_type.type_id == EVMType.VEC2 or vm.expr_type.type_id == EVMType.VEC3) then
			can_convert = operator == Token.MUL
		elseif target_type == EVMType.VEC2 and (vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id == EVMType.FLOAT) then
			can_convert = ((operator == Token.MUL) or (operator == Token.DIV))
		elseif target_type == EVMType.VEC3 and (vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id == EVMType.FLOAT) then
			can_convert = ((operator == Token.MUL) or (operator == Token.DIV))
		elseif allow_ptrs and target_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
			if operator == Token.ADD or operator == Token.SUB then
				can_convert = target_type > EVMType.POINTER -- don't allow addition/subtraction with void pointers
			else
				can_convert = true
			end
		elseif allow_ptrs and target_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
			can_convert = operator == Token.EQ or operator == Token.NE
		end
		
		if not can_convert then
			vm.error = string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end
	elseif target_type == EVMType.STRUCT then
		vm.error = string.format(
			"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
			vm.line,
			getTokenString(operator),
			getTypeName(target_info),
			getTypeName(vm.expr_type)
		)
		vm.compile_err = true
		coroutine.yield()
	elseif target_type == EVMType.STRING then
		if operator ~= Token.EQ and operator ~= Token.NE then
			vm.error = string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end
	elseif target_type >= EVMType.POINTER then
		if not (allow_ptrs and (operator == Token.EQ or operator == Token.NE)) then
			vm.error = string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end
	end
end

local function expression(vm: *EVM, level: integer): void
	local id: *Identifier
	local temp: TypeInfo
	local addr: uinteger

	if vm.token == 0 then
		vm.error = string.format("line %d:\nunexpected EOF in expression", vm.line)
		vm.compile_err = true
		coroutine.yield()
	end

	-- unary operators
	if vm.token == Token.INT_LITERAL then
		match(vm, Token.INT_LITERAL)

		if vm.token_val == 0 then
			vm:emitOp(Opcode.PUSH_ZERO)
		elseif vm.token_val == 1 then
			vm:emitOp(Opcode.PUSH_ONE)
		elseif vm.token_val < 256 then -- simple optimization, turn small int literals into chars
			vm:emitOp(Opcode.PUSH_CHAR)
			vm:emit8((@uint8)(vm.token_val & 0xFF))
		else
			vm:emitOp(Opcode.PUSH_INT)
			vm:emit32(vm.token_val)
		end
		
		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.FLOAT_LITERAL then
		match(vm, Token.FLOAT_LITERAL)

		if vm.token_valf == 0.0 then
			vm:emitOp(Opcode.PUSH_ZEROF)
		elseif vm.token_valf == 1.0 then
			vm:emitOp(Opcode.PUSH_ONEF)
		else
			vm:emitOp(Opcode.PUSH_FLOAT)
			vm:emitF(vm.token_valf)
		end
		
		vm.expr_type = {EVMType.FLOAT}
	elseif vm.token == Token.STRING_LITERAL then
		match(vm, Token.STRING_LITERAL)

		vm:emitOp(Opcode.PUSH_STRING)
		vm:emit16(vm.string_len)
		vm:emit32(vm.token_val)
		
		vm.expr_type = {EVMType.STRING, vm.struct_string}
	elseif vm.token == Token.SIZEOF then
		match(vm, Token.SIZEOF)

		match(vm, '('_u8)

		local target_info: TypeInfo = {EVMType.INT, nilptr}
	
		if vm.token == Token.VOID then
			match(vm, Token.VOID)
			target_info.type_id = EVMType.VOID
		elseif vm.token == Token.INT then
			match(vm, Token.INT)
			target_info.type_id = EVMType.INT
		elseif vm.token == Token.FLOAT then
			match(vm, Token.FLOAT)
			target_info.type_id = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			target_info.structref = vm.struct_vec2
			match(vm, Token.VEC2)
			target_info.type_id = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			target_info.structref = vm.struct_vec3
			match(vm, Token.VEC3)
			target_info.type_id = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			target_info.structref = vm.current_id.type_info.structref
			match(vm, Token.STRUCT_ID)
			target_info.type_id = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			target_info.structref = vm.struct_string
			match(vm, Token.STRING)
			target_info.type_id = EVMType.STRING
		else
			vm.error = string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		while vm.token == Token.MUL do
			match(vm, Token.MUL)
			target_info.type_id = target_info.type_id + EVMType.POINTER
		end

		if target_info.type_id == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot get size of `void`", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, ')'_u8)

		local size: uinteger = sizeOfType(target_info) * 4

		if size < 256 then
			vm:emitOp(Opcode.PUSH_CHAR)
			vm:emit8(size)
		else
			vm:emitOp(Opcode.PUSH_INT)
			vm:emit32(size)
		end
		
		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.ID then
		match(vm, Token.ID)
		
		id = vm.current_id

		if not vm.has_id then
			vm.error = string.format("line %d:\nundefined identifier `%s`", vm.line, id.name)
			vm.compile_err = true
			coroutine.yield()
		end

		if vm.token == '('_u8 then
			-- function call
			match(vm, '('_u8)

			if id.class ~= Class.FUNCTION and id.class ~= Class.API then
				vm.error = string.format("line %d:\ncannot call non-function identifier `%s`", vm.line, id.name)
				vm.compile_err = true
				coroutine.yield()
			end

			local constructor_index: integer = -1
			local constructor_opcodes: []uint8 = {
				Opcode.PUSH_VEC2_ZERO,
				Opcode.PUSH_VEC3_ZERO
			}

			if id.name == "vec2Zero" then
				constructor_index = 0
			elseif id.name == "vec3Zero" then
				constructor_index = 1
			end

			local target_argc: isize = #id.argdata
			local target_info: TypeInfo
			local argc: isize = 0
			local size: uint16 = 0

			if not id.is_varargs and target_argc == 0 then
				if vm.token ~= ')'_u8 then
					vm.error = string.format("line %d:\ntoo many arguments in call to function `%s`. expected 0", vm.line, id.name)
					vm.compile_err = true
					coroutine.yield()
				end
			else
				while vm.token ~= ')'_u8 do
					-- only check arg count if:
					-- function is not varargs
					-- or

					if id.is_varargs then
						if argc < target_argc then
							target_info = id.argdata[argc + 1]
						end
					else
						if argc + 1 > target_argc then
							vm.error = string.format("line %d:\ntoo many arguments in call to function `%s`. expected %d", vm.line, id.name, target_argc)
							vm.compile_err = true
							coroutine.yield()
						else
							target_info = id.argdata[argc + 1]
						end
					end
					
					expression(vm, Token.ASSIGN)

					if vm.expr_type.type_id == EVMType.VOID then
						vm.error = string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line)
						vm.compile_err = true
						coroutine.yield()
					end

					-- only typecheck if:
					-- the function is not varargs
					-- or
					-- the function is varargs, and there are still required arguments
					if not id.is_varargs or (id.is_varargs and (argc < target_argc)) then
						if target_info.type_id ~= vm.expr_type.type_id then
							-- can we convert types?
							local can_convert: boolean = false
							
							if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
								can_convert = true
								vm:emitOp(Opcode.FTOI)
							elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
								vm:emitOp(Opcode.ITOF)
							elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
							elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							end
							
							if not can_convert then
								vm.error = string.format(
									"line %d:\ninvalid type for argument %d in call to function `%s`. expected `%s`, got `%s`",
									vm.line,
									argc + 1,
									id.name,
									getTypeName(target_info),
									getTypeName(vm.expr_type)
								)
								vm.compile_err = true
								coroutine.yield()
							end
						elseif target_info.type_id == EVMType.STRUCT then
							if target_info.structref ~= vm.expr_type.structref then
								vm.error = string.format("line %d:\ninvalid type for argument %d in call to function `%s`. expected `%s`, got `%s`", vm.line, argc + 1, id.name, target_info.structref.name, vm.expr_type.structref.name)
								vm.compile_err = true
								coroutine.yield()
							end
						end
					end

					if constructor_index == -1 then
						size = size + sizeOfType(vm.expr_type)
					end

					argc = argc + 1
					if vm.token == ','_u8 then
						match(vm, ','_u8)
					end
				end

				if argc < target_argc then
					if id.is_varargs then
						vm.error = string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc)
						vm.compile_err = true
						coroutine.yield()
					else
						vm.error = string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc)
						vm.compile_err = true
						coroutine.yield()
					end
				end
			end
			match(vm, ')'_u8)

			-- emit code
			if id.class == Class.API then
				if constructor_index ~= -1 then
					vm:emitOp(constructor_opcodes[constructor_index])
				else
					vm:emitOp(Opcode.API)
					vm:emit16(id.index)
					vm:emit16(size)
				end
			elseif id.class == Class.FUNCTION then
				vm:emitOp(Opcode.CALL)
				vm:emit16(id.index)
				vm:emit16(size)
			end

			vm.expr_type = id.type_info
		elseif id.class == Class.CONSTANT then
			switch id.type_info.type_id do
				case EVMType.INT then
					if id.const_val == 0 then
						vm:emitOp(Opcode.PUSH_ZERO)
					elseif id.const_val == 1 then
						vm:emitOp(Opcode.PUSH_ONE)
					elseif id.const_val < 256 then -- simple optimization, turn small enum values into chars
						vm:emitOp(Opcode.PUSH_CHAR)
						vm:emit8((@uint8)(id.const_val & 0xFF))
					else
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(id.const_val)
					end
				case EVMType.FLOAT then
					if id.const_valf == 0.0 then
						vm:emitOp(Opcode.PUSH_ZEROF)
					elseif id.const_valf == 1.0 then
						vm:emitOp(Opcode.PUSH_ONEF)
					else
						vm:emitOp(Opcode.PUSH_FLOAT)
						vm:emitF(id.const_valf)
					end
				else
					if id.type_info.type_id >= EVMType.POINTER then
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(id.const_val)
					end
			end
			
			vm.expr_type = id.type_info
		else
			-- variable
			if (id.class >= Class.GLOBAL) and (id.class <= Class.LOCAL) then
				if id.is_array then
					switch id.class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.ADDROF_G)
						case Class.ARG then
							vm:emitOp(Opcode.ADDROF_A)
						case Class.LOCAL then
							vm:emitOp(Opcode.ADDROF_L)
					end

					vm:emit16(id.index)
				else
					if id.class == Class.GLOBAL then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_GX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_G)
							vm:emit16(id.index)
						end
					elseif id.class == Class.ARG then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_AX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_A)
							vm:emit16(id.index)
						end
					elseif id.class == Class.LOCAL then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_LX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_L)
							vm:emit16(id.index)
						end
					end
				end
			else
				vm.error = string.format("line %d:\ninvalid identifier `%s`", vm.line, id.name)
				vm.compile_err = true
				coroutine.yield()
			end

			vm.expr_type = id.type_info
		end
	elseif vm.token == '('_u8 then
		match(vm, '('_u8)
		if vm.token >= Token.VOID and vm.token <= Token.STRING then
			-- cast or struct initializer
			local target_info: TypeInfo = {EVMType.INT}
	
			if vm.token == Token.VOID then
				match(vm, Token.VOID)
				target_info.type_id = EVMType.VOID
			elseif vm.token == Token.INT then
				match(vm, Token.INT)
				target_info.type_id = EVMType.INT
			elseif vm.token == Token.FLOAT then
				match(vm, Token.FLOAT)
				target_info.type_id = EVMType.FLOAT
			elseif vm.token == Token.VEC2 then
				target_info.structref = vm.struct_vec2
				match(vm, Token.VEC2)
				target_info.type_id = EVMType.VEC2
			elseif vm.token == Token.VEC3 then
				target_info.structref = vm.struct_vec3
				match(vm, Token.VEC3)
				target_info.type_id = EVMType.VEC3
			elseif vm.token == Token.STRUCT_ID then
				target_info.structref = vm.current_id.type_info.structref
				match(vm, Token.STRUCT_ID)
				target_info.type_id = EVMType.STRUCT
			elseif vm.token == Token.STRING then
				target_info.structref = vm.struct_string
				match(vm, Token.STRING)
				target_info.type_id = EVMType.STRING
			end
	
			while vm.token == Token.MUL do
				match(vm, Token.MUL)
				target_info.type_id = target_info.type_id + EVMType.POINTER
			end

			match(vm, ')'_u8)

			if vm.token == '{'_u8 then
				-- struct initializer

				if target_info.type_id >= EVMType.VEC2 and target_info.type_id <= EVMType.STRING then
					match(vm, '{'_u8)

					local target_struct: *Struct = target_info.structref
					local target_memberc: isize = #target_struct.members
					local target_member_info: TypeInfo
					local memberc: isize = 0
					
					while vm.token ~= '}'_u8 do
						if memberc + 1 > target_memberc then
							vm.error = string.format("line %d:\ntoo many member values in initializer for struct type `%s`. expected %d", vm.line, target_struct.name, target_memberc)
							vm.compile_err = true
							coroutine.yield()
						else
							target_member_info = target_struct.members[memberc + 1].type_info
						end
						
						expression(vm, Token.ASSIGN)
	
						if vm.expr_type.type_id == EVMType.VOID then
							vm.error = string.format("line %d:\ncannot pass expression of type `void` to struct initializer", vm.line)
							vm.compile_err = true
							coroutine.yield()
						elseif target_member_info.type_id ~= vm.expr_type.type_id then
							-- can we convert types?
							local can_convert: boolean = false
							
							if target_member_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
								can_convert = true
								vm:emitOp(Opcode.FTOI)
							elseif target_member_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif target_member_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
								vm:emitOp(Opcode.ITOF)
							elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
							elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							end
							
							if not can_convert then
								vm.error = string.format(
									"line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`",
									vm.line,
									memberc + 1,
									target_struct.name,
									getTypeName(target_member_info),
									getTypeName(vm.expr_type)
								)
								vm.compile_err = true
								coroutine.yield()
							end
						elseif target_member_info.type_id == EVMType.STRUCT then
							if target_member_info.structref ~= vm.expr_type.structref then
								vm.error = string.format("line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`", vm.line, memberc + 1, target_struct.name, target_member_info.structref.name, vm.expr_type.structref.name)
								vm.compile_err = true
								coroutine.yield()
							end
						end
	
						memberc = memberc + 1
						if vm.token == ','_u8 then
							match(vm, ','_u8)
						end
					end
	
					if memberc < target_memberc then
						vm.error = string.format("line %d:\ntoo few member values in initializer for struct type `%s`. expected %d, got %d", vm.line, target_struct.name, target_memberc, memberc)
						vm.compile_err = true
						coroutine.yield()
					end
					
					match(vm, '}'_u8)
				else
					vm.error = string.format(
						"line %d:\ninvalid type `%s` for struct initializer",
						vm.line,
						getTypeName(target_info)
					)
					vm.compile_err = true
					coroutine.yield()
				end
			else
				-- cast
				expression(vm, Token.ARROW)

				if target_info.type_id == EVMType.VOID then
					vm.error = string.format("line %d:\ncannot cast to type `void`", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end
				if vm.expr_type.type_id == EVMType.VOID then
					vm.error = string.format(
						"line %d:\ncannot cast expression of type `void` to `%s`",
						vm.line,
						getTypeName(target_info)
					)
					vm.compile_err = true
					coroutine.yield()
				elseif target_info.type_id ~= vm.expr_type.type_id then
					-- can we convert types?
					local can_convert: boolean = false
					
					if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
						can_convert = true
						vm:emitOp(Opcode.FTOI)
					elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
						vm:emitOp(Opcode.ITOF)
					elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
					elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					end
					
					if not can_convert then
						vm.error = string.format(
							"line %d:\ncannot cast expression of type `%s` to `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName(target_info)
						)
						vm.compile_err = true
						coroutine.yield()
					end
				elseif target_info.type_id == EVMType.STRUCT then
					if target_info.structref ~= vm.expr_type.structref then
						vm.error = string.format("line %d:\ncannot cast expression of type `%s` to `%s`", vm.line, vm.expr_type.structref.name, target_info.structref.name)
						vm.compile_err = true
						coroutine.yield()
					end
				end
			end
			
			vm.expr_type = target_info
		else
			expression(vm, Token.ASSIGN)
			match(vm, ')'_u8)
		end
	elseif vm.token == Token.MUL then
		match(vm, Token.MUL)
	    
		expression(vm, Token.ARROW)

		if vm.expr_type.type_id > EVMType.POINTER then
			vm.expr_type.type_id = vm.expr_type.type_id - EVMType.POINTER
		else
			vm.error = string.format(
				"line %d:\ncannot dereference expression of type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		if (vm.expr_type.type_id >= EVMType.VEC2) and (vm.expr_type.type_id <= EVMType.STRING) then
			vm:emitOp(Opcode.GET_MX)
			vm:emit16(0)
			vm:emit16(vm.expr_type.structref.size)
		else
			vm:emitOp(Opcode.GET_M)
			vm:emit16(0)
		end
	elseif vm.token == Token.AND then
		match(vm, Token.AND)
		
		expression(vm, Token.ARROW)

		--[[
			we've already emitted code for fetching the variable/value:

			GET_G/A/L <index>
			or
			GET_(G/A/L)X <index> <size>

			or if dereference:
			GET_M
			or
			GET_MX <size>

			we need to overwrite that with:

			ADDROF_G/A/L <index>
			
			or if dereference, just remove GET_M/MX and leave address on the stack
		]]

		local op: uint8 = vm.prev_opcode
		local index: uint16
		if op == Opcode.GET_G or op == Opcode.GET_L or op == Opcode.GET_A then
			vm.bytecode_len = vm.bytecode_len - 3
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX then
			vm.bytecode_len = vm.bytecode_len - 5
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_M then
			vm.bytecode_len = vm.bytecode_len - 3
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_MX then
			vm.bytecode_len = vm.bytecode_len - 5
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		else
			vm.error = string.format("line %d:\ninvalid rvalue for address-of", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		switch op do
			case Opcode.GET_G, Opcode.GET_GX then
				vm:emitOp(Opcode.ADDROF_G)
				vm:emit16(index)
			case Opcode.GET_L, Opcode.GET_LX then
				vm:emitOp(Opcode.ADDROF_L)
				vm:emit16(index)
			case Opcode.GET_A, Opcode.GET_AX then
				vm:emitOp(Opcode.ADDROF_A)
				vm:emit16(index)
			case Opcode.GET_M, Opcode.GET_MX then
				if index > 0 then
					-- we were fetching with an offset, we need to add that offset to the pointer

					-- optimize offset bytecode
					if index == 1 then
						vm:emitOp(Opcode.PUSH_ONE)
					elseif index < 256 then
						vm:emitOp(Opcode.PUSH_CHAR)
						vm:emit8((@uint8)(index & 0xFF))
					else
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(index)
					end
					
					vm:emitOp(Opcode.ADDP)
					vm:emit16(1)
				end
		end

		vm.expr_type.type_id = vm.expr_type.type_id + EVMType.POINTER
	elseif vm.token == Token.LNOT then
		match(vm, Token.LNOT)

		expression(vm, Token.ARROW)

		if vm.expr_type.type_id == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
		
		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.LNOT)
		elseif vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp(Opcode.LNOTP)
		else
			vm.error = string.format(
				"line %d:\ncannot use operator `!` on type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.NOT then
		match(vm, Token.NOT)
		
		expression(vm, Token.ARROW)
		
		if vm.expr_type.type_id == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
		
		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.NOT)
		else
			vm.error = string.format("line %d:\ncannot use operator `~` on type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.SUB then
		match(vm, Token.SUB)

		if vm.token == Token.INT_LITERAL then
			if vm.token_val == 0 then
				vm:emitOp(Opcode.PUSH_ZERO)
			elseif vm.token_val == 1 then
				vm:emitOp(Opcode.PUSH_ONE)
				vm:emitOp(Opcode.NEG)
			elseif vm.token_val < 256 then -- simple optimization, turn small int literals into chars
				vm:emitOp(Opcode.PUSH_CHAR)
				vm:emit8((@uint8)(vm.token_val & 0xFF))
				vm:emitOp(Opcode.NEG)
			else
				vm:emitOp(Opcode.PUSH_INT)
				vm:emit32(-(@int32)(vm.token_val))
			end
			
			match(vm, Token.INT_LITERAL)
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.FLOAT_LITERAL then
			if vm.token_valf == 0.0 then
				vm:emitOp(Opcode.PUSH_ZEROF)
				vm:emitOp(Opcode.NEGF)
			elseif vm.token_valf == 1.0 then
				vm:emitOp(Opcode.PUSH_ONEF)
				vm:emitOp(Opcode.NEGF)
			else
				vm:emitOp(Opcode.PUSH_FLOAT)
				vm:emitF(-vm.token_valf)
			end

			match(vm, Token.FLOAT_LITERAL)
			vm.expr_type = {EVMType.FLOAT}
		else
			expression(vm, Token.ARROW)

			switch vm.expr_type.type_id do
				case EVMType.VOID then
					vm.error = string.format("line %d:\ncannot negate expression of type `void`", vm.line)
					vm.compile_err = true
					coroutine.yield()
				case EVMType.INT then
					vm.expr_type = {EVMType.INT}
					vm:emitOp(Opcode.NEG)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.NEGF)
					vm.expr_type = {EVMType.FLOAT}
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.NEGV)
					vm:emit8(vm.expr_type.type_id == EVMType.VEC3 and 1 or 0)
				else
					vm.error = string.format("line %d:\ncannot negate expression of type `%s`", vm.line, vm.expr_type.structref.name)
					vm.compile_err = true
					coroutine.yield()
			end
		end
	else
		vm.error = string.format(
			"line %d:\nunexpected token `%s`",
			vm.line,
			getTokenString(vm.token)
		)
		vm.compile_err = true
		coroutine.yield()
	end

	-- binary operators
	while vm.token >= level do
		temp = vm.expr_type

		if vm.token == Token.ASSIGN then
			id = vm.current_id
			
			match(vm, Token.ASSIGN)

			--[[
				we've already emitted code for fetching the variable/value:

				GET_G/A/L <index>
				or
				GET_(G/A/L)X <index> <size>

				or if dereference:
				GET_M
				or
				GET_MX <size>

				we need to overwrite that with the following expression,
				and finish with code storing the result into the variable/address
			]]
			
			local op: uint8 = vm.prev_opcode
			local class: uinteger
			local index: uint16
			local size: uint16 = 1
			if op == Opcode.GET_G or op == Opcode.GET_L or op == Opcode.GET_A then
				vm.bytecode_len = vm.bytecode_len - 3
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
			elseif op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX then
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_M then
				vm.bytecode_len = vm.bytecode_len - 3
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
			elseif op == Opcode.GET_MX then
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_S then
				vm.bytecode_len = vm.bytecode_len - 1
			else
				vm.error = string.format("line %d:\ninvalid lvalue in assignment", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end

			switch op do
				case Opcode.GET_G, Opcode.GET_GX then
					class = Class.GLOBAL
				case Opcode.GET_L, Opcode.GET_LX then
					class = Class.LOCAL
				case Opcode.GET_A, Opcode.GET_AX then
					class = Class.ARG
				case Opcode.GET_M, Opcode.GET_MX then
					class = Class.MEMORY
				case Opcode.GET_S then
					temp = {EVMType.INT} -- we are writing a char into the string
					class = Class.STRING
			end

			expression(vm, Token.ASSIGN)

			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format(
					"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
					vm.line,
					getTypeName(temp)
				)
				vm.compile_err = true
				coroutine.yield()
			elseif temp.type_id ~= vm.expr_type.type_id then
				-- can we convert types?
				local can_convert: boolean = false
				
				if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
					can_convert = true
					vm:emitOp(Opcode.FTOI)
				elseif temp.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
					vm:emitOp(Opcode.ITOF)
				elseif temp.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
				elseif temp.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				end
				
				if not can_convert then
					vm.error = string.format(
						"line %d:\ncannot assign `%s` to symbol of type `%s`",
						vm.line,
						getTypeName(vm.expr_type),
						getTypeName(temp)
					)
					vm.compile_err = true
					coroutine.yield()
				end

				switch class do
					case Class.GLOBAL then
						vm:emitOp(Opcode.SET_G)
						vm:emit16(index)
					case Class.LOCAL then
						vm:emitOp(Opcode.SET_L)
						vm:emit16(index)
					case Class.ARG then
						vm:emitOp(Opcode.SET_A)
						vm:emit16(index)
					case Class.MEMORY then
						vm:emitOp(Opcode.SET_M)
						vm:emit16(index)
					case Class.STRING then
						vm:emitOp(Opcode.SET_S)
				end
			else
				if temp.type_id == EVMType.VEC2 or temp.type_id == EVMType.VEC3 then
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_GX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_LX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.ARG then
							vm:emitOp(Opcode.SET_AX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_MX)
							vm:emit16(index)
							vm:emit16(size)
					end
				elseif temp.type_id == EVMType.STRUCT or temp.type_id == EVMType.STRING then
					if temp.structref ~= vm.expr_type.structref then
						vm.error = string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, temp.structref.name, vm.expr_type.structref.name)
						vm.compile_err = true
						coroutine.yield()
					end
					
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_GX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_LX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.ARG then
							vm:emitOp(Opcode.SET_AX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_MX)
							vm:emit16(index)
							vm:emit16(size)
					end
				else
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_G)
							vm:emit16(index)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_L)
							vm:emit16(index)
						case Class.ARG then
							vm:emitOp(Opcode.SET_A)
							vm:emit16(index)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_M)
							vm:emit16(index)
						case Class.STRING then
							vm:emitOp(Opcode.SET_S)
					end
				end
			end

			vm.expr_type = {EVMType.VOID} -- don't allow assignment chaining
		elseif vm.token == Token.COND then
			-- TODO: complete this
		elseif vm.token == Token.LOR then
			--[[
				<expr1> || <expr2>

				<expr1>
				JUMP_NZD b or JUMP_NNULLD b
				<expr2>
				ITOB or PTOB
				b:
			]]

			match(vm, Token.LOR)

			if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
				-- short circuit evaluation
				vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.JUMP_NZD or Opcode.JUMP_NNULLD)
				
				addr = vm.bytecode_len
				
				vm:emit16(0)
			else
				vm.error = string.format(
					"line %d:\ninvalid lvalue type for operator '||', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			expression(vm, Token.LAND)
			
			if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.ITOB or Opcode.PTOB)
			else
				vm.error = string.format(
					"line %d:\ninvalid rvalue type for operator '||', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			-- patch JUMP_NZD/JUMP_NNULLD address
			vm.bytecode[addr] = ((vm.bytecode_len) >> 8)
			vm.bytecode[addr + 1] = ((vm.bytecode_len) & 0xFF)
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LAND then
			--[[
				<expr1> && <expr2>

				<expr1>
				JUMP_ZD b or JUMP_NULLD b
				<expr2>
				ITOB or PTOB
				b:
			]]

			match(vm, Token.LAND)

			if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
				-- short circuit evaluation
				vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.JUMP_ZD or Opcode.JUMP_NULLD)
				
				addr = vm.bytecode_len
				
				vm:emit16(0)
			else
				vm.error = string.format(
					"line %d:\ninvalid lvalue type for operator '&&', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end

			expression(vm, Token.OR)
			
			if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.ITOB or Opcode.PTOB)
			else
				vm.error = string.format(
					"line %d:\ninvalid rvalue type for operator '&&', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end

			-- patch JUMP_ZD/JUMP_NULLD address
			vm.bytecode[addr] = ((vm.bytecode_len) >> 8)
			vm.bytecode[addr + 1] = ((vm.bytecode_len) & 0xFF)
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.OR then
			match(vm, Token.OR)

			expression(vm, Token.XOR)
			
			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.OR)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `|` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.XOR then
			match(vm, Token.XOR)

			expression(vm, Token.AND)
			
			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.XOR)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `^` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.AND then
			match(vm, Token.AND)
			
			expression(vm, Token.EQ)
			
			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.AND)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `&` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.EQ then
			match(vm, Token.EQ)

			expression(vm, Token.NE)

			operatorTypeCheck(vm, Token.EQ, temp, true)
			
			switch temp.type_id do
				case EVMType.FLOAT then
					vm:emitOp(Opcode.EQF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.EQV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				case EVMType.STRING then
					vm:emitOp(Opcode.EQS)
				else
					vm:emitOp(Opcode.EQ)
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.NE then
			match(vm, Token.NE)

			expression(vm, Token.LT)

			operatorTypeCheck(vm, Token.NE, temp, true)
			
			switch temp.type_id do
				case EVMType.FLOAT then
					vm:emitOp(Opcode.NEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.NEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				case EVMType.STRING then
					vm:emitOp(Opcode.NES)
				else
					vm:emitOp(Opcode.NE)
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LT then
			match(vm, Token.LT)

			expression(vm, Token.LSHIFT)

			operatorTypeCheck(vm, Token.LT, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.LTI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.LTF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.LTV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.GT then
			match(vm, Token.GT)

			expression(vm, Token.LSHIFT)

			operatorTypeCheck(vm, Token.GT, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.GTI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.GTF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.GTV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LE then
			match(vm, Token.LE)

			expression(vm, Token.LSHIFT)

			operatorTypeCheck(vm, Token.LE, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.LEI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.LEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.LEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.GE then
			match(vm, Token.GE)

			expression(vm, Token.LSHIFT)

			operatorTypeCheck(vm, Token.GE, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.GEI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.GEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.GEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LSHIFT then
			match(vm, Token.LSHIFT)

			expression(vm, Token.ADD)

			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.LSHIFT)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `<<` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.RSHIFT then
			match(vm, Token.RSHIFT)

			expression(vm, Token.ADD)
			
			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.RSHIFT)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `>>` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.ARSHIFT then
			match(vm, Token.ARSHIFT)

			expression(vm, Token.ADD)

			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ARSHIFT)
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `>>>` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.ADD then
			match(vm, Token.ADD)

			expression(vm, Token.MUL)
			
			operatorTypeCheck(vm, Token.ADD, temp, true)

			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.ADD)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.ADDF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.ADDV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				else
					if temp.type_id > EVMType.POINTER then
						vm:emitOp(Opcode.ADDP)
						vm:emit16(sizePointedTo(temp))
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.SUB then
			match(vm, Token.SUB)
			
			expression(vm, Token.MUL)

			operatorTypeCheck(vm, Token.SUB, temp, true)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.SUB)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.SUBF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.SUBV)
					vm:emit8(temp == EVMType.VEC3 and 1 or 0)
				else
					if temp.type_id > EVMType.POINTER then
						vm:emitOp(Opcode.SUBP)
						vm:emit16(sizePointedTo(temp))
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.MUL then
			match(vm, Token.MUL)

			expression(vm, Token.BRAK)

			operatorTypeCheck(vm, Token.MUL, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					switch vm.expr_type.type_id do
						case EVMType.VEC2 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.INT_V2)
						case EVMType.VEC3 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.INT_V3)
						else
							vm.expr_type = temp
							vm:emitOp(Opcode.MUL)
					end
				case EVMType.FLOAT then
					switch vm.expr_type.type_id do
						case EVMType.VEC2 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.FLOAT_V2)
						case EVMType.VEC3 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.FLOAT_V3)
						else
							vm.expr_type = temp
							vm:emitOp(Opcode.MULF)
					end
				case EVMType.VEC2 then
					vm:emitOp(Opcode.MULV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(MulVMode.V2_INT)
						case EVMType.FLOAT then
							vm:emit8(MulVMode.V2_FLOAT)
						case EVMType.VEC2 then
							vm:emit8(MulVMode.V2_V2)
					end
					vm.expr_type = temp
				case EVMType.VEC3 then
					vm:emitOp(Opcode.MULV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(MulVMode.V3_INT)
						case EVMType.FLOAT then
							vm:emit8(MulVMode.V3_FLOAT)
						case EVMType.VEC3 then
							vm:emit8(MulVMode.V3_V3)
					end
					vm.expr_type = temp
			end
		elseif vm.token == Token.DIV then
			match(vm, Token.DIV)
			
			expression(vm, Token.BRAK)

			operatorTypeCheck(vm, Token.DIV, temp, false)
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.DIV)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.DIVF)
				case EVMType.VEC2 then
					vm:emitOp(Opcode.DIVV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(DivVMode.V2_INT)
						case EVMType.FLOAT then
							vm:emit8(DivVMode.V2_FLOAT)
						case EVMType.VEC2 then
							vm:emit8(DivVMode.V2_V2)
					end
				case EVMType.VEC3 then
					vm:emitOp(Opcode.DIVV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(DivVMode.V3_INT)
						case EVMType.FLOAT then
							vm:emit8(DivVMode.V3_FLOAT)
						case EVMType.VEC3 then
							vm:emit8(DivVMode.V3_V3)
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.MOD then
			match(vm, Token.MOD)

			expression(vm, Token.BRAK)
			
			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.MOD)
				vm.expr_type = {EVMType.INT}
			elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ITOF)
				vm:emitOp(Opcode.MODF)
				vm.expr_type = {EVMType.FLOAT}
			elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.FLOAT then
				vm:emitOp(Opcode.MODF)
				vm.expr_type = {EVMType.FLOAT}
			else
				vm.error = string.format(
					"line %d:\ncannot use operator `%` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
		elseif vm.token == Token.ARROW then
			if not (vm.expr_type.type_id >= (EVMType.VEC2 + EVMType.POINTER) and vm.expr_type.type_id <= (EVMType.STRING + EVMType.POINTER)) then
				vm.error = string.format("line %d:\ncannot index members of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			vm.skip_next_id_lookup = true -- we need to look up member ids manually
			match(vm, Token.ARROW)
			match(vm, Token.ID)
	
			-- lookup member
			vm.has_id, vm.current_id = vm.expr_type.structref:getMember(vm.current_id_name)
			if not vm.has_id then
				vm.error = string.format("line %d:\ncannot index member `%s` of symbol `%s`", vm.line, vm.current_id_name, id.name)
				vm.compile_err = true
				coroutine.yield()
			end

			if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
				vm:emitOp(Opcode.GET_MX)
				vm:emit16(vm.current_id.index)
				vm:emit16(vm.current_id.type_info.structref.size)
			else
				vm:emitOp(Opcode.GET_M)
				vm:emit16(vm.current_id.index)
			end

			vm.expr_type = vm.current_id.type_info
		elseif vm.token == Token.DOT then
			id = vm.current_id
			
			if not (vm.expr_type.type_id >= EVMType.VEC2 and vm.expr_type.type_id <= EVMType.STRING) then
				vm.error = string.format(
					"line %d:\ncannot index members of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end

			local op: uint8 = vm.prev_opcode
			local class: uinteger
			local index: uint16
			local size: uint16 = 1
			local valid_lvalue: boolean = false
			
			if (vm.prev_token == Token.ID) and (op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX) then
				valid_lvalue = true
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_MX then
				valid_lvalue = true
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			end

			if not valid_lvalue then
				vm.error = string.format("line %d:\ninvalid lvalue for member index", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end

			switch op do
				case Opcode.GET_GX then
					class = Class.GLOBAL
				case Opcode.GET_LX then
					class = Class.LOCAL
				case Opcode.GET_AX then
					class = Class.ARG
				case Opcode.GET_MX then
					class = Class.MEMORY
			end
			
			vm.skip_next_id_lookup = true -- we need to look up member ids manually
			match(vm, Token.DOT)
			match(vm, Token.ID)
	
			-- lookup member
			vm.has_id, vm.current_id = temp.structref:getMember(vm.current_id_name)
			if not vm.has_id then
				vm.error = string.format("line %d:\ncannot index member `%s` of symbol `%s`", vm.line, vm.current_id_name, id.name)
				vm.compile_err = true
				coroutine.yield()
			end

			if class == Class.GLOBAL then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_GX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_G)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.ARG then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_AX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_A)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.LOCAL then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_LX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_L)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.MEMORY then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_MX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_M)
					vm:emit16(index + vm.current_id.index)
				end
			end

			vm.expr_type = vm.current_id.type_info
		elseif vm.token == Token.BRAK then
			match(vm, Token.BRAK)
			
			local is_string: boolean = false
			local size: uint16

			if vm.expr_type.type_id > EVMType.POINTER then
				size = sizePointedTo(vm.expr_type)
				vm.expr_type.type_id = vm.expr_type.type_id - EVMType.POINTER
				temp = vm.expr_type
			elseif vm.expr_type.type_id == EVMType.STRING then
				temp = {EVMType.INT}
				is_string = true
			else
				vm.error = string.format(
					"line %d:\ncannot subscript expression of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
			
			expression(vm, Token.ASSIGN)

			match(vm, ']'_u8)

			if (vm.expr_type.type_id < EVMType.INT) or (vm.expr_type.type_id > EVMType.FLOAT) then
				vm.error = string.format(
					"line %d:\ncannot use type `%s` as an array index",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			elseif vm.expr_type.type_id == EVMType.FLOAT then
				vm:emitOp(Opcode.FTOI)
			end

			if is_string then
				vm:emitOp(Opcode.GET_S)
			else
				vm:emitOp(Opcode.ADDP)
				vm:emit16(size)

				if (temp.type_id >= EVMType.VEC2) and (temp.type_id <= EVMType.STRING) then
					vm:emitOp(Opcode.GET_MX)
					vm:emit16(0)
					vm:emit16(size)
				else
					vm:emitOp(Opcode.GET_M)
					vm:emit16(0)
				end
			end

			vm.expr_type = temp
		else
			vm.error = string.format(
				"line %d:\nunexpected token `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end
	end
end

local function statement(vm: *EVM): void
	local a: uinteger
	local b: uinteger
	
	if vm.token >= Token.VOID and vm.token <= Token.STRING then
		-- local variable declaration
		local var_type: uinteger = EVMType.INT
		local structref: *Struct

		if vm.token == Token.VOID then
			match(vm, Token.VOID)
			var_type = EVMType.VOID
		elseif vm.token == Token.INT then
			match(vm, Token.INT)
			var_type = EVMType.INT
		elseif vm.token == Token.FLOAT then
			match(vm, Token.FLOAT)
			var_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			structref = vm.struct_vec2
			match(vm, Token.VEC2)
			var_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			structref = vm.struct_vec3
			match(vm, Token.VEC3)
			var_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			structref = vm.current_id.type_info.structref
			match(vm, Token.STRUCT_ID)
			var_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			structref = vm.struct_string
			match(vm, Token.STRING)
			var_type = EVMType.STRING
		end

		while vm.token == Token.MUL do
			match(vm, Token.MUL)
			var_type = var_type + EVMType.POINTER
		end

		if var_type == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot declare variable of type `void`", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
		if vm.token ~= Token.ID then
			vm.error = string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end
		if vm.has_id then
			vm.error = string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name)
			vm.compile_err = true
			coroutine.yield()
		end

		if structref and not structref.is_complete then
			vm.error = string.format("line %d:\ncannot declare variable of incomplete type", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, Token.ID)

		vm.current_id.class = Class.LOCAL
		vm.current_id.type_info = {var_type, structref}
		vm.current_id.index = vm.local_index
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)

		local type_size: uinteger = sizeOfType(vm.current_id.type_info)
		
		if vm.token == Token.BRAK then
			vm.current_id.is_array = true
			vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

			match(vm, Token.BRAK)
			
			local array_size: uinteger

			if vm.token == Token.INT_LITERAL then
				array_size = vm.token_val
				match(vm, Token.INT_LITERAL)
			elseif vm.token == Token.ID then
				if not vm.has_id then
					vm.error = string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name)
					vm.compile_err = true
					coroutine.yield()
				elseif vm.current_id.class ~= Class.CONSTANT then
					vm.error = string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name)
					vm.compile_err = true
					coroutine.yield()
				end

				array_size = vm.current_id.const_val
				
				match(vm, Token.ID)
			else
				vm.error = string.format(
					"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
					vm.line,
					getTokenString(vm.token)
				)
				vm.compile_err = true
				coroutine.yield()
			end

			if array_size == 0 then
				vm.error = string.format("line %d:\ncannot declare array of length 0", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end

			array_size = array_size * type_size

			vm.local_index = vm.local_index + array_size
			vm:incScopeLocalsSize(array_size)

			match(vm, ']'_u8)
		else			
			vm.local_index = vm.local_index + type_size
			vm:incScopeLocalsSize(type_size)

			if vm.token == Token.ASSIGN then
				local id: *Identifier = vm.current_id
	
				match(vm, Token.ASSIGN)
	
				expression(vm, Token.ASSIGN)
	
				if vm.expr_type.type_id == EVMType.VOID then
					vm.error = string.format(
						"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
						vm.line,
						getTypeName({var_type, structref})
					)
					vm.compile_err = true
					coroutine.yield()
				elseif var_type ~= vm.expr_type.type_id then
					-- can we convert types?
					local can_convert: boolean = false
					
					if var_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
						can_convert = true
						vm:emitOp(Opcode.FTOI)
					elseif var_type == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif var_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
						vm:emitOp(Opcode.ITOF)
					elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
					elseif var_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					end
	
					if not can_convert then
						vm.error = string.format(
							"line %d:\ncannot assign `%s` to symbol of type `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName({var_type, structref})
						)
						vm.compile_err = true
						coroutine.yield()
					end
	
					vm:emitOp(Opcode.SET_L)
					vm:emit16(id.index)
				else
					if var_type == EVMType.VEC2 or var_type == EVMType.VEC3 then
						vm:emitOp(Opcode.SET_LX)
						vm:emit16(id.index)
						vm:emit16(type_size)
					elseif var_type == EVMType.STRUCT or var_type == EVMType.STRING then
						if structref ~= vm.expr_type.structref then
							vm.error = string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, vm.expr_type.structref.name, structref.name)
							vm.compile_err = true
							coroutine.yield()
						end
						
						vm:emitOp(Opcode.SET_LX)
						vm:emit16(id.index)
						vm:emit16(id.type_info.structref.size)
					else
						vm:emitOp(Opcode.SET_L)
						vm:emit16(id.index)
					end
				end
			end
		end

		if vm.local_index > MEMORY_LOCALS_SIZE_ELEMENTS then
			vm.error = string.format("line %d:\nfunction local variable storage limit exceeded by %d word(s)", vm.line, vm.local_index - MEMORY_LOCALS_SIZE_ELEMENTS)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, ';'_u8)
	elseif vm.token == Token.IF then
		--[[
			ERA-C:         | BYTECODE:
			---------------+-------------
			if (<cond>)    | <cond>
			               | JUMP_Z a
			  <true code>  | <true code>
			else:          | JUMP b
			a:             | a:
			  <false code> | <false code>
			b:             | b:
			-----------------------------
		]]
		
		match(vm, Token.IF)
		match(vm, '('_u8)
		expression(vm, Token.ASSIGN)

		if vm.expr_type.type_id == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot use expression of type `void` as if statement condition", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.JUMP_Z or Opcode.JUMP_NULL)

			b = vm.bytecode_len
		
			vm:emit16(0)
		else
			vm.error = string.format(
				"line %d:\ninvalid type for if statement condition. expected `int` or pointer, got `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, ')'_u8)

		statement(vm)
		if vm.token == Token.ELSE then
			match(vm, Token.ELSE)

			-- write jump_z address
			vm.bytecode[b] = ((vm.bytecode_len + 3) >> 8)
			vm.bytecode[b + 1] = ((vm.bytecode_len + 3) & 0xFF)

			-- emit bytecode for JUMP b
			vm:emitOp(Opcode.JUMP)
			b = vm.bytecode_len
			vm:emit16(0)

			statement(vm)
		end
		
		vm.bytecode[b] = ((vm.bytecode_len) >> 8)
		vm.bytecode[b + 1] = ((vm.bytecode_len) & 0xFF)
	elseif vm.token == Token.FOR then
		--[[
			ERA-C:                        | BYTECODE:
			------------------------------+-------------
			for (<init>; <cond>; <step>)  | <init>
			                              | a:
										  | <cond>
										  | JUMP_Z b
			  <statement>                 | <statement>
										  | <step>
										  | JUMP a
										  | b:
		]]

		local for_line: uinteger = vm.line

		match(vm, Token.FOR)
		
		vm:pushScope()
		
		vm:emitOp(Opcode.NEW_L)
		local new_l_index: uinteger = vm.bytecode_len
		vm:emit16(0)
		
		match(vm, '('_u8)

		-- init
		while vm.token ~= ';'_u8 do
			if vm.token >= Token.VOID and vm.token <= Token.STRING then
				-- init variable declaration
				local var_type: uinteger = EVMType.INT
				local structref: *Struct

				if vm.token == Token.VOID then
					match(vm, Token.VOID)
					var_type = EVMType.VOID
				elseif vm.token == Token.INT then
					match(vm, Token.INT)
					var_type = EVMType.INT
				elseif vm.token == Token.FLOAT then
					match(vm, Token.FLOAT)
					var_type = EVMType.FLOAT
				elseif vm.token == Token.VEC2 then
					structref = vm.struct_vec2
					match(vm, Token.VEC2)
					var_type = EVMType.VEC2
				elseif vm.token == Token.VEC3 then
					structref = vm.struct_vec3
					match(vm, Token.VEC3)
					var_type = EVMType.VEC3
				elseif vm.token == Token.STRUCT_ID then
					structref = vm.current_id.type_info.structref
					match(vm, Token.STRUCT_ID)
					var_type = EVMType.STRUCT
				elseif vm.token == Token.STRING then
					structref = vm.struct_string
					match(vm, Token.STRING)
					var_type = EVMType.STRING
				end

				while vm.token == Token.MUL do
					match(vm, Token.MUL)
					var_type = var_type + EVMType.POINTER
				end

				if var_type == EVMType.VOID then
					vm.error = string.format("line %d:\ncannot declare variable of type `void`", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end
				if vm.token ~= Token.ID then
					vm.error = string.format(
						"line %d:\nexpected token `identifier`, got `%s`",
						vm.line,
						getTokenString(vm.token)
					)
					vm.compile_err = true
					coroutine.yield()
				end
				if vm.has_id then
					vm.error = string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name)
					vm.compile_err = true
					coroutine.yield()
				end

				if structref and not structref.is_complete then
					vm.error = string.format("line %d:\ncannot declare variable of incomplete type", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end

				match(vm, Token.ID)

				vm.current_id.class = Class.LOCAL
				vm.current_id.type_info = {var_type, structref}
				vm.current_id.index = vm.local_index
				vm:addScopedSymbol(vm.current_id.name, vm.current_id)

				local type_size: uinteger = sizeOfType(vm.current_id.type_info)
				
				if vm.token == Token.BRAK then
					vm.current_id.is_array = true
					vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

					match(vm, Token.BRAK)
					
					local array_size: uinteger

					if vm.token == Token.INT_LITERAL then
						array_size = vm.token_val
						match(vm, Token.INT_LITERAL)
					elseif vm.token == Token.ID then
						if not vm.has_id then
							vm.error = string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name)
							vm.compile_err = true
							coroutine.yield()
						elseif vm.current_id.class ~= Class.CONSTANT then
							vm.error = string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name)
							vm.compile_err = true
							coroutine.yield()
						end

						array_size = vm.current_id.const_val
						
						match(vm, Token.ID)
					else
						vm.error = string.format(
							"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
							vm.line,
							getTokenString(vm.token)
						)
						vm.compile_err = true
						coroutine.yield()
					end

					if array_size == 0 then
						vm.error = string.format("line %d:\ncannot declare array of length 0", vm.line)
						vm.compile_err = true
						coroutine.yield()
					end

					array_size = array_size * type_size

					vm.local_index = vm.local_index + array_size
					vm:incScopeLocalsSize(array_size)

					match(vm, ']'_u8)
				else
					vm.local_index = vm.local_index + type_size
					vm:incScopeLocalsSize(type_size)

					if vm.token == Token.ASSIGN then
						local id: *Identifier = vm.current_id
			
						match(vm, Token.ASSIGN)
			
						expression(vm, Token.ASSIGN)
			
						if vm.expr_type.type_id == EVMType.VOID then
							vm.error = string.format(
								"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
								vm.line,
								getTypeName({var_type, structref})
							)
							vm.compile_err = true
							coroutine.yield()
						elseif var_type ~= vm.expr_type.type_id then
							-- can we convert types?
							local can_convert: boolean = false
							
							if var_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
								can_convert = true
								vm:emitOp(Opcode.FTOI)
							elseif var_type == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif var_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
								vm:emitOp(Opcode.ITOF)
							elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
							elseif var_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							end
			
							if not can_convert then
								vm.error = string.format(
									"line %d:\ncannot assign `%s` to symbol of type `%s`",
									vm.line,
									vm.expr_type.type_id,
									getTypeName({var_type, structref})
								)
								vm.compile_err = true
								coroutine.yield()
							end
			
							vm:emitOp(Opcode.SET_L)
							vm:emit16(id.index)
						else
							if var_type == EVMType.VEC2 or var_type == EVMType.VEC3 then
								vm:emitOp(Opcode.SET_LX)
								vm:emit16(id.index)
								vm:emit16(type_size)
							elseif var_type == EVMType.STRUCT or var_type == EVMType.STRING then
								if structref ~= vm.expr_type.structref then
									vm.error = string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, vm.expr_type.structref.name, structref.name)
									vm.compile_err = true
									coroutine.yield()
								end
								
								vm:emitOp(Opcode.SET_LX)
								vm:emit16(id.index)
								vm:emit16(id.type_info.structref.size)
							else
								vm:emitOp(Opcode.SET_L)
								vm:emit16(id.index)
							end
						end
					end
				end

				if vm.local_index > MEMORY_LOCALS_SIZE_ELEMENTS then
					vm.error = string.format("line %d:\nfunction local variable storage limit exceeded by %d word(s)", vm.line, vm.local_index - MEMORY_LOCALS_SIZE_ELEMENTS)
					vm.compile_err = true
					coroutine.yield()
				end
			else
				expression(vm, Token.ASSIGN)
			end

			if vm.token == ','_u8 then
				match(vm, ','_u8)
			end
		end

		match(vm, ';'_u8)
		
		-- cond
		a = vm.bytecode_len

		vm:pushLoop(vm.bytecode_len)
		
		local has_condition: boolean = false
		if vm.token ~= ';'_u8 then
			has_condition = true

			expression(vm, Token.ASSIGN)

			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot use expression of type `void` as loop condition", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
	
			if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.JUMP_Z or Opcode.JUMP_NULL)
	
				b = vm.bytecode_len
			
				vm:emit16(0)
			else
				vm.error = string.format(
					"line %d:\ninvalid type for loop condition. expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				)
				vm.compile_err = true
				coroutine.yield()
			end
		end
		
		local step_line: uinteger = vm.line

		match(vm, ';'_u8)
		
		-- save our spot
		-- we're skipping over the step expressions for now,
		-- but we'll be back!
		local step_prev_token: uinteger = vm.prev_token
		local step_index: uinteger = vm.prev_src_index
		
		if vm.token ~= ')'_u8 then
			vm:setLoopHasStep()
		end
		while vm.token ~= ')'_u8 and vm.token ~= 0 do
			next(vm)
		end
		
		match(vm, ')'_u8)
		
		-- loop body
		statement(vm)
		
		-- save our spot again
		-- we'll return to the step expressions now,
		-- but we'll be back! ...again!
		local end_prev_token: uinteger = vm.prev_token
		local end_index: uinteger = vm.prev_src_index
		local end_line: uinteger = vm.line - 1

		vm.prev_token = step_prev_token
		vm.src_index = step_index
		vm.prev_line = 0
		vm.line = step_line
		
		-- ok, we're back
		-- we need to generate the step expressions now
		local has_step: boolean

		next(vm)
		if vm.token ~= ')'_u8 then
			vm:setLoopStep(vm.bytecode_len)
		end
		while vm.token ~= ')'_u8 do
			expression(vm, Token.ASSIGN)
			
			if vm.token == ','_u8 then
				match(vm, ','_u8)
			end
		end

		match(vm, ')'_u8)

		-- time to wrap up the loop with a jump
		vm:emitOp(Opcode.JUMP)
		vm:emit16(a)

		vm:setLoopEnd(vm.bytecode_len)
		
		if has_condition then
			vm.bytecode[b] = ((vm.bytecode_len) >> 8)
			vm.bytecode[b + 1] = ((vm.bytecode_len) & 0xFF)
		end

		vm:popLoop()

		-- and now we can jump back to the end of the loop body
		vm.prev_token = end_prev_token
		vm.prev_line = 0
		vm.line = end_line
		vm.src_index = end_index
		
		next(vm)

		-- cleanup any loop init variables allocated
		local size: uinteger = vm:getScopeLocalsSize()
		if size > 0 then
			-- patch new_l size
			if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
				vm.error = string.format("line %d:\nloop local variable allocation limit exceeded by %d word(s)", for_line, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1))
				vm.compile_err = true
				coroutine.yield()
			end

			vm.bytecode[new_l_index] = ((size) >> 8)
			vm.bytecode[new_l_index + 1] = ((size) & 0xFF)
			
			-- cleanup
			vm:emitOp(Opcode.DEL_L)
			vm:emit16(size)
			
			vm.local_index = vm.local_index - size
		end
		
		vm:popScope()
	elseif vm.token == Token.WHILE then
		--[[
			ERA-C:         | BYTECODE:
			---------------+-------------
			a:             | a:
			while (<cond>) | <cond>
			               | JMP_Z b
			  <statement>  | <statement>
			               | JUMP a
			b:             | b:
			-----------------------------
		]]

		match(vm, Token.WHILE)

		a = vm.bytecode_len

		vm:pushLoop(vm.bytecode_len)

		match(vm, '('_u8)

		expression(vm, Token.ASSIGN)

		if vm.expr_type.type_id == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot use expression of type `void` as loop condition", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		if vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp((vm.expr_type.type_id == EVMType.INT) and Opcode.JUMP_Z or Opcode.JUMP_NULL)

			b = vm.bytecode_len
		
			vm:emit16(0)
		else
			vm.error = string.format(
				"line %d:\ninvalid type for loop condition. expected `int` or pointer, got `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			)
			vm.compile_err = true
			coroutine.yield()
		end
		
		match(vm, ')'_u8)

		statement(vm)

		vm:emitOp(Opcode.JUMP)
		vm:emit16(a)

		vm:setLoopEnd(vm.bytecode_len)

		vm.bytecode[b] = ((vm.bytecode_len) >> 8)
		vm.bytecode[b + 1] = ((vm.bytecode_len) & 0xFF)

		vm:popLoop()
	elseif vm.token == Token.RETURN then
		match(vm, Token.RETURN)

		if vm.token ~= ';'_u8 then
			if vm.current_func_id.type_info.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot return a value from function of type `void`", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end

			expression(vm, Token.ASSIGN)
			
			local target_info: TypeInfo = vm.current_func_id.type_info

			if vm.expr_type.type_id == EVMType.VOID then
				vm.error = string.format("line %d:\ncannot return expression of type `void`", vm.line)
				vm.compile_err = true
				coroutine.yield()
			elseif target_info.type_id ~= vm.expr_type.type_id then
				-- can we convert types?
				local can_convert: boolean = false
				
				if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
					can_convert = true
					vm:emitOp(Opcode.FTOI)
				elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
					vm:emitOp(Opcode.ITOF)
				elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
				elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				end
				
				if not can_convert then
					vm.error = string.format(
						"line %d:\ncannot return `%s` from function of type `%s`",
						vm.line,
						getTypeName(vm.expr_type),
						getTypeName(target_info)
					)
					vm.compile_err = true
					coroutine.yield()
				end
			elseif target_info.type_id == EVMType.STRUCT then
				if target_info.structref ~= vm.expr_type.structref then
					vm.error = string.format("line %d:\ncannot return `%s` from function of type `%s`", vm.line, vm.expr_type.structref.name, target_info.structref.name)
					vm.compile_err = true
					coroutine.yield()
				end
			end
		elseif vm.current_func_id.type_info.type_id ~= EVMType.VOID then
			vm.error = string.format(
				"line %d:\nfunction of type `%s` must return a value",
				vm.line,
				getTypeName(vm.current_func_id.type_info)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, ';'_u8)

		vm:emitOp(Opcode.RETURN)
	elseif vm.token == Token.BREAK then
		match(vm, Token.BREAK)

		if #vm.loop_info_stack == 0 then
			vm.error = string.format("line %d:\nbreak statement is not in a loop", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		vm:emitOp(Opcode.DEL_L)
		vm:addDelL(vm.bytecode_len)
		vm:emit16(0)
		
		vm:emitOp(Opcode.JUMP)
		vm:addBreak(vm.bytecode_len)
		vm:emit16(0)
		
		match(vm, ';'_u8)
	elseif vm.token == Token.CONTINUE then
		match(vm, Token.CONTINUE)

		if #vm.loop_info_stack == 0 then
			vm.error = string.format("line %d:\ncontinue statement is not in a loop", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		vm:emitOp(Opcode.DEL_L)
		vm:addDelL(vm.bytecode_len)
		vm:emit16(0)
		
		vm:emitOp(Opcode.JUMP)

		if vm:loopHasStep() then
			vm:addJumpToStep(vm.bytecode_len)
			vm:emit16(0)
		else
			vm:emit16(vm:getLoopStart())
		end

		match(vm, ';'_u8)
	elseif vm.token == '{'_u8 then
		local scope_line: uinteger = vm.line

		match(vm, '{'_u8)

		vm:pushScope()

		vm:emitOp(Opcode.NEW_L)
		local new_l_index: uinteger = vm.bytecode_len
		vm:emit16(0)
		
		while vm.token ~= '}'_u8 do
			statement(vm)
		end

		match(vm, '}'_u8)

		-- cleanup any local variables allocated
		local size: uinteger = vm:getScopeLocalsSize()
		vm.prev_scope_size = size
		
		-- patch new_l size
		if size > 0 then
			if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
				vm.error = string.format("line %d:\nscope local variable allocation limit exceeded by %d word(s)", scope_line, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1))
				vm.compile_err = true
				coroutine.yield()
			end

			vm.bytecode[new_l_index] = ((size) >> 8)
			vm.bytecode[new_l_index + 1] = ((size) & 0xFF)

			-- cleanup
			vm:emitOp(Opcode.DEL_L)
			vm:emit16(size)

			vm.local_index = vm.local_index - size
		end
		
		vm:popScope()
	elseif vm.token == ';'_u8 then
		-- empty statement
		match(vm, ';'_u8)
	else
		-- TODO: don't allow expressions that will leave an unused value on the opstack
		expression(vm, Token.ASSIGN)
		match(vm, ';'_u8)
	end
end

local function enumDeclaration(vm: *EVM): void
	local i: int32
	while vm.token ~= '}'_u8 do
		if vm.token ~= Token.ID then
			vm.error = string.format(
				"line %d:\nbad enum identifier", vm.line
			)
			vm.compile_err = true
			coroutine.yield()
		end
		next(vm)

		if vm.token == Token.ASSIGN then
			next(vm)
			if vm.token ~= Token.INT_LITERAL then
				vm.error = string.format("line %d:\nbad enum value", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
			i = vm.token_val
			next(vm)
		end

		vm.current_id.class = Class.CONSTANT
		vm.current_id.type_info = {EVMType.INT}
		vm.current_id.const_val = i
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)
		i = i + 1

		if vm.token == ','_u8 then
			next(vm)
		end
	end
end

local function functionParameters(vm: *EVM, hook_index: integer): void
	local arg_type: uinteger
	local arg_index: uinteger

	while vm.token ~= ')'_u8 do
		local structref: *Struct = nilptr
		arg_type = EVMType.INT
		
		if vm.token == Token.VOID then
			match(vm, Token.VOID)
			arg_type = EVMType.VOID
		elseif vm.token == Token.INT then
			match(vm, Token.INT)
			arg_type = EVMType.INT
		elseif vm.token == Token.FLOAT then
			match(vm, Token.FLOAT)
			arg_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			structref = vm.struct_vec2
			match(vm, Token.VEC2)
			arg_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			structref = vm.struct_vec3
			match(vm, Token.VEC3)
			arg_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			structref = vm.current_id.type_info.structref
			match(vm, Token.STRUCT_ID)
			arg_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			structref = vm.struct_string
			match(vm, Token.STRING)
			arg_type = EVMType.STRING
		elseif vm.token == Token.VARARGS then
			match(vm, Token.VARARGS)
			vm.current_func_id.is_varargs = true
			vm.current_func_id.varargs_index = arg_index
			break
		else
			vm.error = string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		while vm.token == Token.MUL do
			match(vm, Token.MUL)
			arg_type = arg_type + EVMType.POINTER
		end

		if arg_type == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot declare function parameter of type `void`", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
		if vm.token ~= Token.ID then
			vm.error = string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end
		if vm.has_id then
			vm.error = string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, Token.ID)

		vm.current_id.class = Class.ARG
		vm.current_id.type_info = {arg_type, structref}
		vm.current_id.index = arg_index
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)
		
		if structref and not structref.is_complete then
			vm.error = string.format("line %d:\ncannot declare function parameter of incomplete type", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		arg_index = arg_index + sizeOfType(vm.current_id.type_info)

		vm.current_func_id.argdata:push(vm.current_id.type_info)

		if vm.token == ','_u8 then
			match(vm, ','_u8)
		end
	end

	if hook_index ~= -1 then
		if hook_index == Hook.UPDATE then
			if #vm.current_func_id.argdata ~= 1 or vm.current_func_id.is_varargs then
				vm.error = string.format("line %d:\ninvalid signature for hook function `update`, expected `void update(float)`", vm.line)
				vm.compile_err = true
				coroutine.yield()
			elseif vm.current_func_id.argdata[1].type_id ~= EVMType.FLOAT or vm.current_func_id.is_varargs then
				vm.error = string.format("line %d:\ninvalid signature for hook function `update`, expected `void update(float)`", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end
		else
			if #vm.current_func_id.argdata ~= 0 or vm.current_func_id.is_varargs then
				vm.error = string.format("line %d:\ninvalid signature for hook function `%s`, expected `void %s()`", vm.line, vm.current_func_id.name, vm.current_func_id.name)
				vm.compile_err = true
				coroutine.yield()
			end
		end
	end
end

local function functionBody(vm: *EVM): void
	vm.local_index = 0
	while vm.token ~= '}'_u8 do
		statement(vm)
	end

	--if vm.prev_opcode ~= Opcode.RETURN then
	vm:emitOp(Opcode.RETURN)
end

local function functionDeclaration(vm: *EVM, hook_index: integer): void
	vm:pushScope() -- function scope
	match(vm, '('_u8)
	functionParameters(vm, hook_index)
	match(vm, ')'_u8)
	match(vm, '{'_u8)

	if vm.current_func_id.is_varargs then
		-- establish starting point for vararg pointer and set vargs flag
		vm:emitOp(Opcode.VARGP)
		vm:emit16(vm.current_func_id.varargs_index)
	end
	
	vm:emitOp(Opcode.NEW_L)
	local new_l_index: uinteger = vm.bytecode_len
	vm:emit16(0)
	
	functionBody(vm)
	match(vm, '}'_u8)
	
	-- patch new_l size
	local size: uinteger = vm:getScopeLocalsSize()
	if size > 0 then
		if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
			vm.error = string.format("function `%s` local variable allocation limit exceeded by %d word(s)", vm.current_func_id.name, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1))
			vm.compile_err = true
			coroutine.yield()
		end

		vm.bytecode[new_l_index] = ((size) >> 8)
		vm.bytecode[new_l_index + 1] = ((size) & 0xFF)
	end

	vm:popScope()
end

local function structDeclaration(vm: *EVM): void
	local struct_id: *Identifier
	local struct: *Struct = new(@Struct)
	local member: *Identifier
	local member_type: uinteger
	local member_index: uinteger
	local member_structref: *Struct
	local base_type: uinteger

	struct.is_complete = false
	
	match(vm, Token.STRUCT)

	if vm.token ~= Token.ID then
		vm.error = string.format(
			"line %d:\nexpected token `identifier`, got `%s`",
			vm.line,
			getTokenString(vm.token)
		)
		vm.compile_err = true
		coroutine.yield()
	end
	if vm.has_id then
		vm.error = string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name)
		vm.compile_err = true
		coroutine.yield()
	end

	struct.name = vm.current_id.name
	struct_id = vm.current_id
	struct_id.token = Token.STRUCT_ID
	struct_id.class = Class.STRUCT
	struct_id.type_info = {EVMType.STRUCT, struct}
	vm.struct_ids[struct_id.name] = struct_id

	match(vm, Token.ID)
	match(vm, '{'_u8)

	while vm.token ~= '}'_u8 do
		member_structref = nilptr
		base_type = EVMType.INT
		
		if vm.token == Token.VOID then
			vm.skip_next_id_lookup = true
			match(vm, Token.VOID)
			base_type = EVMType.VOID
		elseif vm.token == Token.INT then
			vm.skip_next_id_lookup = true
			match(vm, Token.INT)
		elseif vm.token == Token.FLOAT then
			vm.skip_next_id_lookup = true
			match(vm, Token.FLOAT)
			base_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			member_structref = vm.struct_vec2
			vm.skip_next_id_lookup = true
			match(vm, Token.VEC2)
			base_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			member_structref = vm.struct_vec3
			vm.skip_next_id_lookup = true
			match(vm, Token.VEC3)
			base_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			member_structref = vm.current_id.type_info.structref
			vm.skip_next_id_lookup = true
			match(vm, Token.STRUCT_ID)
			base_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			member_structref = vm.struct_string
			vm.skip_next_id_lookup = true
			match(vm, Token.STRING)
			base_type = EVMType.STRING
		else
			vm.error = string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		member_type = base_type

		while vm.token == Token.MUL do
			match(vm, Token.MUL)
			member_type = member_type + EVMType.POINTER
		end

		if member_type == EVMType.VOID then
			vm.error = string.format("line %d:\ncannot declare struct member of type `void`", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		if vm.token ~= Token.ID then
			vm.error = string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			)
			vm.compile_err = true
			coroutine.yield()
		end

		vm.has_id = struct:hasMember(vm.current_id_name)
		if vm.has_id then
			vm.error = string.format("line %d:\nduplicate declaration of struct member `%s`", vm.line, vm.current_id_name)
			vm.compile_err = true
			coroutine.yield()
		end

		match(vm, Token.ID)
		member = new(@Identifier)
		member.name = vm.current_id_name
		member.type_info = {member_type, member_structref}
		member.index = member_index

		if member_structref and (member_type < EVMType.POINTER) and (not member_structref.is_complete) then
			vm.error = string.format("line %d:\ncannot declare struct member of incomplete type", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
		
		member_index = member_index + sizeOfType(member.type_info)
		
		struct:addMember(member)
		
		match(vm, ';'_u8)
	end

	struct.is_complete = true

	match(vm, '}'_u8)
end

local function globalDeclaration(vm: *EVM): void
	local base_type: uinteger
	local var_type: uinteger
	local temp: uinteger
	local structref: *Struct = nilptr

	base_type = EVMType.INT

	if vm.token == Token.ENUM then
		match(vm, Token.ENUM)
		match(vm, '{'_u8)
		enumDeclaration(vm)
		match(vm, '}'_u8)
		match(vm, ';'_u8)
		return
	elseif vm.token == Token.STRUCT then
		structDeclaration(vm)
		match(vm, ';'_u8)
		return
	end

	if vm.token == Token.VOID then
		match(vm, Token.VOID)
		base_type = EVMType.VOID
	elseif vm.token == Token.INT then
		match(vm, Token.INT)
		base_type = EVMType.INT
	elseif vm.token == Token.FLOAT then
		match(vm, Token.FLOAT)
		base_type = EVMType.FLOAT
	elseif vm.token == Token.VEC2 then
		structref = vm.struct_vec2
		match(vm, Token.VEC2)
		base_type = EVMType.VEC2
	elseif vm.token == Token.VEC3 then
		structref = vm.struct_vec3
		match(vm, Token.VEC3)
		base_type = EVMType.VEC3
	elseif vm.token == Token.STRUCT_ID then
		structref = vm.current_id.type_info.structref
		match(vm, Token.STRUCT_ID)
		base_type = EVMType.STRUCT
	elseif vm.token == Token.STRING then
		structref = vm.struct_string
		match(vm, Token.STRING)
		base_type = EVMType.STRING
	else
		vm.error = string.format(
			"line %d:\nexpected type identifier, got `%s`",
			vm.line,
			getTokenString(vm.token)
		)
		vm.compile_err = true
		coroutine.yield()
	end
	
	var_type = base_type
	
	while vm.token == Token.MUL do
		match(vm, Token.MUL)
		var_type = var_type + EVMType.POINTER
	end

	if vm.token ~= Token.ID then
		vm.error = string.format(
			"line %d:\nexpected token `identifier`, got `%s`",
			vm.line,
			getTokenString(vm.token)
		)
		vm.compile_err = true
		coroutine.yield()
	end
	if vm.has_id then
		vm.error = string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name)
		vm.compile_err = true
		coroutine.yield()
	end

	match(vm, Token.ID)
	vm.current_id.type_info = {var_type, structref}
	vm:addScopedSymbol(vm.current_id.name, vm.current_id)

	if vm.token == '('_u8 then
		vm.current_id.class = Class.FUNCTION
		vm.current_id.index = vm.bytecode_len -- address of function

		if structref and not structref.is_complete then
			vm.error = string.format("line %d:\ncannot declare function with incomplete return type", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end

		-- register hooks
		local hook_index: integer = -1
		if vm.current_id.name == "init" then
			hook_index = Hook.INIT
		elseif vm.current_id.name == "update" then
			hook_index = Hook.UPDATE
		elseif vm.current_id.name == "draw" then
			hook_index = Hook.DRAW
		end

		if hook_index ~= -1 then
			vm.hook_flags[hook_index] = true
			vm.hook_addresses[hook_index] = vm.current_id.index

			if var_type ~= EVMType.VOID then
				vm.error = string.format("line %d:\nhook function `%s` must have a return type of `void`", vm.line, vm.current_id.name)
				vm.compile_err = true
				coroutine.yield()
			end
		end

		vm.current_func_id = vm.current_id
		functionDeclaration(vm, hook_index)
	else
		if var_type ~= EVMType.VOID then
			vm.current_id.class = Class.GLOBAL
			vm.current_id.index = vm.globals_len

			if structref and not structref.is_complete then
				vm.error = string.format("line %d:\ncannot declare variable of incomplete type", vm.line)
				vm.compile_err = true
				coroutine.yield()
			end

			local type_size: uinteger = sizeOfType(vm.current_id.type_info)

			if vm.token == Token.BRAK then
				vm.current_id.is_array = true
				vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

				match(vm, Token.BRAK)
				
				local array_size: uinteger

				if vm.token == Token.INT_LITERAL then
					array_size = vm.token_val
					match(vm, Token.INT_LITERAL)
				elseif vm.token == Token.ID then
					if not vm.has_id then
						vm.error = string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name)
						vm.compile_err = true
						coroutine.yield()
					elseif vm.current_id.class ~= Class.CONSTANT then
						vm.error = string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name)
						vm.compile_err = true
						coroutine.yield()
					end

					array_size = vm.current_id.const_val
					
					match(vm, Token.ID)
				else
					vm.error = string.format(
						"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
						vm.line,
						getTokenString(vm.token)
					)
					vm.compile_err = true
					coroutine.yield()
				end

				if array_size == 0 then
					vm.error = string.format("line %d:\ncannot declare array of length 0", vm.line)
					vm.compile_err = true
					coroutine.yield()
				end

				array_size = array_size * type_size

				vm.globals_len = vm.globals_len + array_size

				match(vm, ']'_u8)
			else
				vm.globals_len = vm.globals_len + type_size
			end

			if vm.globals_len > MEMORY_GLOBALS_SIZE_ELEMENTS then
				vm.error = string.format("line %d:\nglobal variable storage limit exceeded by %d word(s)", vm.line, vm.globals_len - MEMORY_GLOBALS_SIZE_ELEMENTS)
				vm.compile_err = true
				coroutine.yield()
			end

			match(vm, ';'_u8)
		else
			vm.error = string.format("line %d:\ncannot declare variable of type `void`", vm.line)
			vm.compile_err = true
			coroutine.yield()
		end
	end
end

local function program(vm: *EVM): void
	vm.rom_len = 0
	vm.bytecode_len = 0
	vm.globals_len = 0

	for i = 0, < Hook.COUNT do
		vm.hook_addresses[i] = 0
		vm.hook_flags[i] = false
	end

	vm.line = 1
	vm.src_index = 1
	vm.prev_src_index = 1
	vm:pushScope() -- global scope
	
	next(vm)
	while vm.token ~= 0 do
		globalDeclaration(vm)
	end

	vm:popScope()

	-- check if at least one hook function was declared
	local declared: boolean
	for i = 0, < Hook.COUNT do
		if vm.hook_flags[i] then
			declared = true
			break
		end
	end

	if not declared then
		vm.error = string.format("no hook functions defined\ndefine `void init()`, `void update(float delta_time)`, or `void draw()`")
		vm.compile_err = true
	end
end

function EVM:compile(): boolean
	local success: boolean
	local co: coroutine
	local errmsg: string

	self.compile_err = false
	co, errmsg = coroutine.create(program)
	success, errmsg = coroutine.resume(co, self)
	self:resetCompiler()
	return success and not self.compile_err
end
