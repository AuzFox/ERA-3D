require("string")
require("io")

require("definitions")

local type_names: []string = {
	"void",
	"int",
	"float"
}

local token_names: []string = {
	"int literal",
	"float literal",
	"string literal",
	"multi-line comment",
	"invalid token",
	"void",
	"int",
	"float",
	"vec2",
	"vec3",
	"struct identifier",
	"string",
	"struct",
	"enum",
	"identifier",
	"else",
	"if",
	"return",
	"break",
	"continue",
	"sizeof",
	"for",
	"while",
	"...",
	"!",
	"~",
	"=",
	"?",
	"||",
	"&&",
	"|",
	"^",
	"&",
	"==",
	"!=",
	"<",
	">",
	"<=",
	">=",
	"<<",
	">>",
	">>>",
	"+",
	"-",
	"*",
	"/",
	"%",
	"->",
	".",
	"["
}

local compile_err: boolean

-- macro for raising a compile error
## function compileError(messsage)
	compile_err = true
	vm.error = #[messsage]#
	return
## end

-- macro for raising a compile error and returning a value
## function compileErrorReturn(messsage, val)
	compile_err = true
	vm.error = #[messsage]#
	return #[val]#
## end

-- macro for running a compiler function and checking for errors
## function try(block)
	## inject_statement(block)
	if compile_err then
		return
	end
## end

local function getTypeName(info: TypeInfo): string
	local sb: stringbuilder
	local full_type: uinteger = info.type_id
	local base_type: uinteger = info.type_id & (EVMType.POINTER - 1)

	if base_type < EVMType.VEC2 then
		sb:write(type_names[base_type])
	elseif base_type == EVMType.FUNC_POINTER then
		sb:write(getTypeName(info.fptr_info.return_type))

		sb:write("(")
		
		for i = 1, <= #info.fptr_info.argdata do
			local arg_info: TypeInfo = info.fptr_info.argdata[i]

			sb:write(getTypeName(arg_info))
			
			if i < #info.fptr_info.argdata then
				sb:write(",")
			elseif info.fptr_info.is_varargs then
				sb:write(",...")
			end
		end
		
		sb:write(")")
	else
		sb:write(info.structref.name)
	end

	while full_type >= EVMType.POINTER do
		sb:writebyte('*'_u8)
		full_type = full_type - EVMType.POINTER
	end

	return sb:__tostring()
end

local function getTokenString(token: uinteger): string
	if token == 0 then
		return "EOF"
	elseif token < Token.INT_LITERAL then
		return string.format("%c", token)
	else
		return token_names[token - Token.INT_LITERAL]
	end
end

local function sizeOfType(info: TypeInfo): uint16
	-- returns size in words
	if (info.type_id >= EVMType.VEC2) and (info.type_id <= EVMType.STRING) then
		return info.structref.size
	end
	
	return 1
end

local function sizePointedTo(info: TypeInfo): uint16
	-- returns size in words
	local type_pointed_to: uinteger = info.type_id - EVMType.POINTER
	
	if (type_pointed_to >= EVMType.VEC2) and (type_pointed_to <= EVMType.STRING) then
		return info.structref.size
	end
	
	return 1
end

function Struct:addMember(member: *Identifier): void
	self.members:push(member)
	self.member_map[member.name] = #self.members

	self.size = self.size + sizeOfType(member.type_info)
end

function Struct:hasMember(name: string): boolean
	return self.member_map:has(name)
end

function Struct:getMember(name: string): (boolean, *Identifier)
	local has: boolean
	local index: uinteger

	has, index = self.member_map:has_and_get(name)
	if has then return true, self.members[index] end

	return false, nilptr
end

function EVM:pushScope(): void
	self.sym_tables:push(new(@hashmap(string, *Identifier)))
	self.scope_sizes:push(0)
end

function EVM:popScope(): void
	self.sym_tables:pop()
	self.scope_sizes:pop()
end

function EVM:addScopedSymbol(name: string, id: *Identifier): void
	self.sym_tables[#self.sym_tables][name] = id
end

function EVM:getScopeLocalsSize(): uinteger
	return self.scope_sizes[#self.scope_sizes]
end

function EVM:incScopeLocalsSize(size: uinteger): void
	local total: uinteger = self:getScopeLocalsSize()
	total = total + size
	self.scope_sizes[#self.scope_sizes] = total
end

function EVM:pushLoop(start: uint32): void
	self.loop_info_stack:push((@LoopInfo){loop_start = start})
end

function EVM:popLoop(): void
	local info: LoopInfo = self.loop_info_stack:pop()

	-- patch break jumps
	while info.break_count > 0 do
		local index: uint32 = self.loop_break_stack:pop()

		self.bytecode[index] = ((info.loop_end & 0xFF0000) >> 16)
		self.bytecode[index + 1] = ((info.loop_end & 0xFF00) >> 8)
		self.bytecode[index + 2] = (info.loop_end & 0xFF)

		info.break_count = info.break_count - 1
	end

	-- patch step jumps
	while info.step_count > 0 do
		local index: uint32 = self.loop_step_stack:pop()

		self.bytecode[index] = ((info.loop_step & 0xFF0000) >> 16)
		self.bytecode[index + 1] = ((info.loop_step & 0xFF00) >> 8)
		self.bytecode[index + 2] = (info.loop_step & 0xFF)

		info.step_count = info.step_count - 1
	end

	local size: uint16 = self.prev_scope_size
	while info.del_l_count > 0 do
		local index: uint32 = self.loop_del_l_stack:pop()
		
		if size > 0 then
			self.bytecode[index] = (size >> 8)
			self.bytecode[index + 1] = (size & 0xFF)
		end

		info.del_l_count = info.del_l_count - 1
	end
end

function EVM:getCurrentLoopInfo(): LoopInfo
	return self.loop_info_stack[#self.loop_info_stack]
end

function EVM:loopHasStep(): boolean
	return self.loop_info_stack[#self.loop_info_stack].has_step
end

function EVM:getLoopStart(): uint32
	return self.loop_info_stack[#self.loop_info_stack].loop_start
end

function EVM:getLoopStep(): uint32
	return self.loop_info_stack[#self.loop_info_stack].loop_step
end

function EVM:getLoopEnd(): uint32
	return self.loop_info_stack[#self.loop_info_stack].loop_end
end

function EVM:setLoopHasStep(): void
	self.loop_info_stack[#self.loop_info_stack].has_step = true
end

function EVM:setLoopStep(index: uint32): void
	local info: LoopInfo = self.loop_info_stack:pop()
	info.loop_step = index
	self.loop_info_stack:push(info)
end

function EVM:setLoopEnd(index: uint32): void
	self.loop_info_stack[#self.loop_info_stack].loop_end = index
end

function EVM:addBreak(index: uint32): void
	self.loop_break_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.break_count = info.break_count + 1
	self.loop_info_stack:push(info)
end

function EVM:addJumpToStep(index: uint32): void
	self.loop_step_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.step_count = info.step_count + 1
	self.loop_info_stack:push(info)
end

function EVM:addDelL(index: uint32): void
	self.loop_del_l_stack:push(index)

	local info: LoopInfo = self.loop_info_stack:pop()
	info.del_l_count = info.del_l_count + 1
	self.loop_info_stack:push(info)
end

function EVM:lookupID(name: string): boolean
	self.has_id, self.current_id = self.keywords:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.constants:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.api_ids:has_and_get(name)
	if self.has_id then return true end

	self.has_id, self.current_id = self.builtin_struct_ids:has_and_get(name)
	if self.has_id then return true end
	
	self.has_id, self.current_id = self.struct_ids:has_and_get(name)
	if self.has_id then return true end

	-- search scope stack
	for i = #self.sym_tables, > 0, -1  do
		local table: *hashmap(string, *Identifier) = self.sym_tables[i]
		self.has_id, self.current_id = table:has_and_get(name)
		if self.has_id then return true end
	end

	return false
end

function EVM:resetCompiler(): void
	self.token = 0
	self.token_val = 0
	self.token_valf = 0
	self.prev_token = 0
	self.prev_scope_size = 0
	self.expr_type = {}
	self.local_index = 0
	self.mlcomment_level = 0
	self.prev_opcode = 0
	self.has_id = false
	self.skip_next_id_lookup = false
	self.current_id = nilptr
	self.current_id_name = ""
	self.current_func_id = nilptr
	self.sb:clear()
	self.struct_ids:clear()
	self.sym_tables:clear()
	self.scope_sizes:clear()
	self.loop_info_stack:clear()
	self.loop_break_stack:clear()
	self.loop_step_stack:clear()
	self.loop_del_l_stack:clear()
end

function EVM:emitOp(val: uint8): void
	self.bytecode[self.bytecode_len] = val

	self.bytecode_len = self.bytecode_len + 1
	self.prev_opcode = val
end

function EVM:emit8(val: uint8): void
	self.bytecode[self.bytecode_len] = val

	self.bytecode_len = self.bytecode_len + 1
end

function EVM:emit16(val: uint16): void
	self.bytecode[self.bytecode_len] = val >> 8
	self.bytecode[self.bytecode_len + 1] = val & 0xFF

	self.bytecode_len = self.bytecode_len + 2
end

function EVM:emit24(val: uint32): void
	self.bytecode[self.bytecode_len] = (val & 0xFF0000) >> 16
	self.bytecode[self.bytecode_len + 1] = (val & 0x00FF00) >> 8
	self.bytecode[self.bytecode_len + 2] = val & 0xFF

	self.bytecode_len = self.bytecode_len + 3
end

function EVM:emit32(val: uint32): void
	self.bytecode[self.bytecode_len] = val >> 24
	self.bytecode[self.bytecode_len + 1] = (val & 0xFF0000) >> 16
	self.bytecode[self.bytecode_len + 2] = (val & 0x00FF00) >> 8
	self.bytecode[self.bytecode_len + 3] = val & 0xFF

	self.bytecode_len = self.bytecode_len + 4
end

function EVM:emitF(val: float32): void
	local v: IntFloat = {f=val}

	self:emit32(v.u)
end

local function getChar(): byte
	if vm.line > #core.src_lines then
		vm.token = 0
		return vm.token
	end
	
	if vm.line ~= vm.prev_line then
		vm.current_src_line = core.src_lines[vm.line]
		vm.prev_line = vm.line
	end

	if vm.src_index >= #vm.current_src_line then
		vm.token = '\n'_u8
	else
		vm.token = vm.current_src_line[vm.src_index]
	end
	
	return vm.token
end

local function next(): void
	vm.prev_src_index = vm.src_index
	vm.prev_token = vm.token

	while getChar() ~= 0 do
		vm.src_index = vm.src_index + 1

		if vm.token == '\n'_u8 then
			vm.line = vm.line + 1
			vm.src_index = 1
		elseif (vm.token >= 'a'_u8 and vm.token <= 'z'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'Z'_u8) or (vm.token == '_'_u8) then
			-- identifier
			vm.sb:clear()
			vm.sb:writebyte(vm.token)

			while true do
				getChar()
				if (vm.token >= 'a'_u8 and vm.token <= 'z'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'Z'_u8) or (vm.token >= '0'_u8 and vm.token <= '9'_u8) or (vm.token == '_'_u8) then
					vm.src_index = vm.src_index + 1
					vm.sb:writebyte(vm.token)
				else
					break
				end
			end
			
			vm.current_id_name = vm.sb:__tostring()
			if vm.skip_next_id_lookup then
				vm.skip_next_id_lookup = false
				vm.token = Token.ID
				vm.has_id = true
				return
			end
			
			vm:lookupID(vm.current_id_name)

			if vm.has_id then
				vm.token = vm.current_id.token
				return
			else
				-- make new id
				vm.current_id = new(@Identifier)
				vm.current_id.token = Token.ID
				vm.current_id.name = vm.current_id_name
				vm.token = vm.current_id.token
				return
			end
		elseif vm.token >= '0'_u8 and vm.token <= '9'_u8 then
			local isfloat: boolean = false
			-- number
			vm.token_val = vm.token - '0'_u8
			if vm.token_val == 0 and getChar() == 'x'_u8 then
				-- hex
				vm.src_index = vm.src_index + 1
				while true do
					getChar()
					if (vm.token >= '0'_u8 and vm.token <= '9'_u8) or (vm.token >= 'a'_u8 and vm.token <= 'f'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'F'_u8) then
						vm.token_val = vm.token_val * 16 + (vm.token & 15)
						if vm.token >= 'A'_u8 then
							vm.token_val = vm.token_val + 9
						end
						vm.src_index = vm.src_index + 1
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						break
					end
				end
			elseif vm.token_val == 0 and getChar() == 'b'_u8 then
				-- binary
				vm.src_index = vm.src_index + 1
				while true do
					getChar()
					if vm.token == '0'_u8 or vm.token == '1'_u8 then
						vm.token_val = (vm.token_val * 2) + (vm.token - '0'_u8)
						vm.src_index = vm.src_index + 1
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						break
					end
				end
			elseif vm.token_val == 0 and getChar() == 'n'_u8 then
				-- soundchip note
				local note: int32 = 0xFF
				local octave: int32 = 0xFF
				vm.src_index = vm.src_index + 1

				-- get note name
				getChar()
				if (vm.token >= 'a'_u8 and vm.token <= 'g'_u8) or (vm.token >= 'A'_u8 and vm.token <= 'G'_u8) then
					switch vm.token do
						case 'a'_u8, 'A'_u8 then
							note = 9 -- BK_A_0
						case 'b'_u8, 'B'_u8 then
							note = 11 -- BK_B_0
						case 'c'_u8, 'C'_u8 then
							note = 0 -- BK_C_0
						case 'd'_u8, 'D'_u8 then
							note = 2 -- BK_D_0
						case 'e'_u8, 'E'_u8 then
							note = 4 -- BK_E_0
						case 'f'_u8, 'F'_u8 then
							note = 5 -- BK_F_0
						case 'g'_u8, 'G'_u8 then
							note = 7 -- BK_G_0
					end
					vm.src_index = vm.src_index + 1
				else
					compileError!(string.format("line %d:\ninvalid or missing note in note literal", vm.line))
				end

				-- get sharp symbol (if present)
				getChar()
				if vm.token == '#'_u8 then
					if note == 4 or note == 11 then
						compileError!(string.format("line %d:\nnote in note literal cannot be made sharp", vm.line))
					else
						note = note + 1
						vm.src_index = vm.src_index + 1
						getChar()
					end
				end

				-- octave
				if (vm.token >= '0'_u8 and vm.token <= '8'_u8) then
					octave = vm.token - '0'_u8
					vm.src_index = vm.src_index + 1
				else
					compileError!(string.format("line %d:\ninvalid or missing octave in note literal", vm.line))
				end

				vm.token_val = (octave * 12) + note
			else
				-- decimal
				local fract: float32 = 1.0
				while true do
					getChar()
					if vm.token >= '0'_u8 and vm.token <= '9'_u8 then
						if isfloat then
							fract = fract / 10.0
							vm.token_valf = (vm.token_valf * 10) + (@float32)(vm.token - '0'_u8)
						else
							vm.token_val = (vm.token_val * 10) + (vm.token - '0'_u8)
						end
						vm.src_index = vm.src_index + 1
					elseif vm.token == '.'_u8 then
						if not isfloat then
							isfloat = true
							vm.token_valf = (@float32)(vm.token_val)
							vm.src_index = vm.src_index + 1
						else
							compileError!(string.format("line %d:\nmultiple decimal points in float literal", vm.line))
						end
					elseif vm.token == '_'_u8 then
						vm.src_index = vm.src_index + 1
					else
						if isfloat then
							vm.token_valf = vm.token_valf * fract
						end
						break
					end
				end
			end
			if isfloat then
				vm.token = Token.FLOAT_LITERAL
			else
				vm.token = Token.INT_LITERAL
			end
			return
		elseif vm.token == '"'_u8 or vm.token == '\''_u8 then
			-- string/char literal
			local start: uinteger = vm.token
			local len: uinteger = 0
			local rom_start: uinteger = vm.rom_len

			-- TODO: reuse strings instead of repeating them in ROM

			while true do
				getChar()
				if vm.token ~= 0 and vm.token ~= start then
					vm.token_val = vm.token
					vm.src_index = vm.src_index + 1
					if vm.token == '\\'_u8 then -- escape code
						getChar()
						vm.src_index = vm.src_index + 1
						switch vm.token do
							case '\\'_u8 then -- \\
								vm.token_val = '\\'_u8
							case 'n'_u8 then -- \n
								vm.token_val = '\n'_u8
							case '"'_u8 then -- \""
								vm.token_val = '\"'_u8
							else
								compileError!(string.format(
									"line %d:\ninvalid escape sequence '\\%c' in string",
									vm.line,
									vm.token
								))
						end
					elseif vm.token == '\n'_u8 then
						compileError!(string.format("line %d:\nstring literals cannot contain unescaped newline characters", vm.line))
					end
					
					if start == '"'_u8 then
						if vm.rom_len >= MEMORY_ROM_SIZE_ELEMENTS then
							compileError!(string.format("line %d:\nmaximum ROM size exceeded", vm.line))
						end
						vm.cart.rom[vm.rom_len] = (@uint8)(vm.token_val)
						vm.rom_len = vm.rom_len + 1
					end
					
					len = len + 1
				else
					break
				end
			end

			vm.src_index = vm.src_index + 1

			if start == '"'_u8 then
				vm.string_len = len
				
				if len ~= 0 then
					vm.token_val = MEMORY_ROM_START_ADDR + rom_start
				else
					vm.token_val = MEMORY_NULL
				end

				vm.token = Token.STRING_LITERAL
			else
				if len == 1 then
					vm.token = Token.INT_LITERAL
				else
					compileError!(string.format("line %d:\ncharacter literals may only contain one character", vm.line))
				end
			end

			return
		elseif vm.token == '/'_u8 then
			local nxt: uinteger = getChar()
			switch nxt do
				case '/'_u8 then -- single line comment
					vm.src_index = vm.src_index + 1
					while true do
						getChar()
						if vm.token ~= 0 and vm.token ~= '\n'_u8 then
							vm.src_index = vm.src_index + 1
						else
							break
						end
					end
				case '*'_u8 then -- multi-line comment
					vm.mlcomment_level = 1
					vm.src_index = vm.src_index + 1
					while true do
						getChar()
						if vm.token == 0 then
							break
						elseif vm.token == '*'_u8 then
							vm.src_index = vm.src_index + 1
							getChar()
							if vm.token == '/'_u8 then
								vm.src_index = vm.src_index + 1
								vm.mlcomment_level = vm.mlcomment_level - 1
								if vm.mlcomment_level == 0 then
									break
								end
							elseif vm.token == '\n'_u8 then
								vm.line = vm.line + 1
								vm.src_index = 1
							end
						elseif vm.token == '/'_u8 then
							vm.src_index = vm.src_index + 1
							getChar()
							if vm.token == '*'_u8 then
								vm.src_index = vm.src_index + 1
								vm.mlcomment_level = vm.mlcomment_level + 1
							elseif vm.token == '\n'_u8 then
								vm.line = vm.line + 1
								vm.src_index = 1
							end
						elseif vm.token == '\n'_u8 then
							vm.src_index = vm.src_index + 1
							vm.line = vm.line + 1
							vm.src_index = 1
						else
							vm.src_index = vm.src_index + 1
						end
					end
				else
					vm.token = Token.DIV
					return
			end
		elseif vm.token == '='_u8 then
			if getChar() == '='_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.EQ
			else
				vm.token = Token.ASSIGN
			end
			
			return
		elseif vm.token == '+'_u8 then
			vm.token = Token.ADD
			return
		elseif vm.token == '-'_u8 then
			if getChar() == '>'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.ARROW
			else
				vm.token = Token.SUB
			end
			
			return
		elseif vm.token == '*'_u8 then
			vm.token = Token.MUL
			return
		elseif vm.token == '!'_u8 then
			if getChar() == '='_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.NE
			else
				vm.token = Token.LNOT
			end
			
			return
		elseif vm.token == '<'_u8 then
			local nxt: uinteger = getChar()
			switch nxt do
				case '='_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.LE
				case '<'_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.LSHIFT
				else
					vm.token = Token.LT
			end
			
			return
		elseif vm.token == '>'_u8 then
			local nxt: uinteger = getChar()
			switch nxt do
				case '='_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.GE
				case '>'_u8 then
					vm.src_index = vm.src_index + 1
					if getChar() == '>'_u8 then
						vm.src_index = vm.src_index + 1
						vm.token = Token.ARSHIFT
					else
						vm.token = Token.RSHIFT
					end
				else
					vm.token = Token.GT
			end
			
			return
		elseif vm.token == '|'_u8 then
			if getChar() == '|'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.LOR
			else
				vm.token = Token.OR
			end
			
			return
		elseif vm.token == '&'_u8 then
			if getChar() == '&'_u8 then
				vm.src_index = vm.src_index + 1
				vm.token = Token.LAND
			else
				vm.token = Token.AND
			end
			
			return
		elseif vm.token == '^'_u8 then
			vm.token = Token.XOR
			return
		elseif vm.token == '~'_u8 then
			vm.token = Token.NOT
			return
		elseif vm.token == '%'_u8 then
			vm.token = Token.MOD
			return
		elseif vm.token == '['_u8 then
			vm.token = Token.BRAK
			return
		elseif vm.token == '?'_u8 then
			vm.token = Token.COND
			return
		elseif vm.token == '.'_u8 then
			if getChar() == '.'_u8 then
				vm.src_index = vm.src_index + 1
				if getChar() == '.'_u8 then
					vm.src_index = vm.src_index + 1
					vm.token = Token.VARARGS
				else
					compileError!(string.format("line %d:\ninvalid token '..'", vm.line))
				end
			else
				vm.token = Token.DOT
			end
			
			return
		elseif (vm.token == ';'_u8 or vm.token == '{'_u8 or vm.token == '}'_u8 or vm.token == '('_u8 or vm.token == ')'_u8 or vm.token == ']'_u8 or vm.token == ','_u8 or vm.token == ':'_u8 or vm.token == '`'_u8 or vm.token == '#'_u8 or vm.token == '$'_u8 or vm.token == '@'_u8) then
			return
		end
	end
end

local function match(tk: uinteger): void
	if vm.token == tk then
		try!(next())
	else
		compileError!(string.format(
			"line %d:\nexpected token `%s`, got `%s`",
			vm.line,
			getTokenString(tk),
			getTokenString(vm.token)
		))
	end
end

local function functionPointerType(base_structref: *Struct, var_type: uinteger, skip_id_lookup: boolean): *FuncPointerInfo
	local result: *FuncPointerInfo = new(@FuncPointerInfo)

	-- add argument types
	-- if '(' after type, recurse
	local arg_type: uinteger
	local arg_index: uinteger

	while vm.token ~= ')'_u8 do
		local structref: *Struct = nilptr
		local fptr_info: *FuncPointerInfo = nilptr
		arg_type = EVMType.INT
		
		if vm.token == Token.VOID then
			try!(match(Token.VOID))
			arg_type = EVMType.VOID
		elseif vm.token == Token.INT then
			try!(match(Token.INT))
			arg_type = EVMType.INT
		elseif vm.token == Token.FLOAT then
			try!(match(Token.FLOAT))
			arg_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			structref = vm.struct_vec2
			try!(match(Token.VEC2))
			arg_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			structref = vm.struct_vec3
			try!(match(Token.VEC3))
			arg_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			structref = vm.current_id.type_info.structref
			try!(match(Token.STRUCT_ID))
			arg_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			structref = vm.struct_string
			try!(match(Token.STRING))
			arg_type = EVMType.STRING
		elseif vm.token == Token.VARARGS then
			try!(match(Token.VARARGS))
			result.is_varargs = true
			break
		else
			compileErrorReturn!(
					string.format(
					"line %d:\nexpected type identifier, got `%s`",
					vm.line,
					getTokenString(vm.token)
				),
				nilptr
			)
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			arg_type = arg_type + EVMType.POINTER
		end

		-- check for function pointer syntax
		if vm.token == '('_u8 then
			try!(match('('_u8))
			try!((
				do
					fptr_info = functionPointerType(structref, arg_type, false)
				end
			))
			structref = nilptr
			arg_type = EVMType.FUNC_POINTER
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			arg_type = arg_type + EVMType.POINTER
		end

		if arg_type == EVMType.VOID then
			compileErrorReturn!(
				string.format("line %d:\ncannot declare function pointer parameter of type `void`", vm.line),
				nilptr
			)
		end
		
		if structref and not structref.is_complete then
			compileErrorReturn!(
				string.format("line %d:\ncannot declare function pointer parameter of incomplete type", vm.line),
				nilptr
			)
		end
		
		local type_info: TypeInfo = {arg_type, structref, fptr_info}
		arg_index = arg_index + sizeOfType(type_info)
		result.argdata:push(type_info)

		if vm.token == ','_u8 then
			try!(match(','_u8))
		end
	end

	if skip_id_lookup then
		vm.skip_next_id_lookup = true
	end

	try!(match(')'_u8))

	result.return_type = {var_type, base_structref}
	return result
end

local function matchFuncPointerTypes(fa: *FuncPointerInfo, fb: *FuncPointerInfo): boolean
	if fa.return_type.type_id ~= fb.return_type.type_id then
		return false
	end

	if fa.return_type.type_id == EVMType.STRUCT and fa.return_type.structref ~= fb.return_type.structref then
		return false
	end

	if fa.return_type.type_id == EVMType.FUNC_POINTER then
		if not matchFuncPointerTypes(fa.return_type.fptr_info, fb.return_type.fptr_info) then
			return false
		end
	end

	if fa.is_varargs ~= fb.is_varargs then
		return false
	end

	if #fa.argdata ~= #fb.argdata then
		return false
	end

	-- compare arg types
	for i = 1, <= #fa.argdata do
		local arga: TypeInfo = fa.argdata[i]
		local argb: TypeInfo = fb.argdata[i]

		if arga.type_id ~= argb.type_id then
			return false
		end

		if arga.type_id == EVMType.STRUCT and arga.structref ~= argb.structref then
			return false
		end

		if arga.type_id == EVMType.FUNC_POINTER then
			if not matchFuncPointerTypes(arga.fptr_info, argb.fptr_info) then
				return false
			end
		end
	end

	return true
end

local function operatorTypeCheck(operator: uinteger, target_info: TypeInfo, allow_ptrs: boolean): void
	local target_type: uinteger = target_info.type_id

	if vm.expr_type.type_id == EVMType.VOID then
		compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
	elseif target_type ~= vm.expr_type.type_id then
		-- can we convert types?
		local can_convert: boolean = false
		
		if target_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
			can_convert = true
			vm:emitOp(Opcode.FTOI)
		elseif target_type == EVMType.INT and (vm.expr_type.type_id == EVMType.VEC2 or vm.expr_type.type_id == EVMType.VEC3) then
			can_convert = operator == Token.MUL
		elseif target_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
			can_convert = true
			vm:emitOp(Opcode.ITOF)
		elseif target_type == EVMType.FLOAT and (vm.expr_type.type_id == EVMType.VEC2 or vm.expr_type.type_id == EVMType.VEC3) then
			can_convert = operator == Token.MUL
		elseif target_type == EVMType.VEC2 and (vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id == EVMType.FLOAT) then
			can_convert = ((operator == Token.MUL) or (operator == Token.DIV))
		elseif target_type == EVMType.VEC3 and (vm.expr_type.type_id == EVMType.INT or vm.expr_type.type_id == EVMType.FLOAT) then
			can_convert = ((operator == Token.MUL) or (operator == Token.DIV))
		elseif allow_ptrs and target_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
			if operator == Token.ADD or operator == Token.SUB then
				can_convert = target_type > EVMType.POINTER -- don't allow addition/subtraction with void pointers
			else
				can_convert = true
			end
		elseif allow_ptrs and target_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
			can_convert = operator == Token.EQ or operator == Token.NE
		elseif allow_ptrs and target_type == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
			can_convert = (operator == Token.EQ or operator == Token.NE) and (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
		elseif allow_ptrs and target_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
			can_convert = (operator == Token.EQ or operator == Token.NE) and (target_type & (EVMType.POINTER - 1) == EVMType.VOID)
		end
		
		if not can_convert then
			compileError!(string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			))
		end
	elseif target_type == EVMType.STRUCT then
		compileError!(string.format(
			"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
			vm.line,
			getTokenString(operator),
			getTypeName(target_info),
			getTypeName(vm.expr_type)
		))
	elseif target_type == EVMType.STRING then
		if operator ~= Token.EQ and operator ~= Token.NE then
			compileError!(string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			))
		end
	elseif target_type >= EVMType.POINTER then
		if not (allow_ptrs and (operator == Token.EQ or operator == Token.NE)) then
			compileError!(string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			))
		end
	elseif target_type == EVMType.FUNC_POINTER then
		if operator ~= Token.EQ and operator ~= Token.NE then
			compileError!(string.format(
				"line %d:\ncannot use operator `%s` on types `%s` and `%s`",
				vm.line,
				getTokenString(operator),
				getTypeName(target_info),
				getTypeName(vm.expr_type)
			))
		end
	end
end

local function expression(level: integer): void
	local id: *Identifier
	local temp: TypeInfo
	local addr: uinteger

	if vm.token == 0 then
		compileError!(string.format("line %d:\nunexpected EOF in expression", vm.line))
	end

	-- literals, struct initializers, and unary operators
	if vm.token == Token.INT_LITERAL then
		try!(match(Token.INT_LITERAL))

		if vm.token_val == 0 then
			vm:emitOp(Opcode.PUSH_ZERO)
		elseif vm.token_val == 1 then
			vm:emitOp(Opcode.PUSH_ONE)
		elseif vm.token_val < 256 then -- simple optimization, turn small int literals into chars
			vm:emitOp(Opcode.PUSH_CHAR)
			vm:emit8((@uint8)(vm.token_val & 0xFF))
		else
			vm:emitOp(Opcode.PUSH_INT)
			vm:emit32(vm.token_val)
		end
		
		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.FLOAT_LITERAL then
		try!(match(Token.FLOAT_LITERAL))

		if vm.token_valf == 0.0 then
			vm:emitOp(Opcode.PUSH_ZEROF)
		elseif vm.token_valf == 1.0 then
			vm:emitOp(Opcode.PUSH_ONEF)
		else
			vm:emitOp(Opcode.PUSH_FLOAT)
			vm:emitF(vm.token_valf)
		end
		
		vm.expr_type = {EVMType.FLOAT}
	elseif vm.token == Token.STRING_LITERAL then
		try!(match(Token.STRING_LITERAL))

		vm:emitOp(Opcode.PUSH_STRING)
		vm:emit16(vm.string_len)
		vm:emit32(vm.token_val)
		
		vm.expr_type = {EVMType.STRING, vm.struct_string}
	elseif vm.token >= Token.VEC2 and vm.token <= Token.STRING then
		-- new-style struct initializer

		local target_info: TypeInfo = {EVMType.INT}

		switch vm.token do
			case Token.VEC2 then
				target_info.structref = vm.struct_vec2
				try!(match(Token.VEC2))
				target_info.type_id = EVMType.VEC2
			case Token.VEC3 then
				target_info.structref = vm.struct_vec3
				try!(match(Token.VEC3))
				target_info.type_id = EVMType.VEC3
			case Token.STRUCT_ID then
				target_info.structref = vm.current_id.type_info.structref
				try!(match(Token.STRUCT_ID))
				target_info.type_id = EVMType.STRUCT
			case Token.STRING then
				target_info.structref = vm.struct_string
				try!(match(Token.STRING))
				target_info.type_id = EVMType.STRING
		end

		try!(match('('_u8))

		local target_struct: *Struct = target_info.structref
		local colobj_id: uint8 = 0xFF -- value not mapped to any collision object type

		if target_struct.name == "colpoint" then
			colobj_id = 0
		elseif target_struct.name == "colaabb" then
			colobj_id = 1
		elseif target_struct.name == "colsphere" then
			colobj_id = 2
		elseif target_struct.name == "colcylinder" then
			colobj_id = 3
		elseif target_struct.name == "coltriangle" then
			colobj_id = 4
		end

		if vm.token == ')'_u8 then
			try!(match(')'_u8))

			if colobj_id == 0xFF then
				vm:emitOp(Opcode.PUSH_ZERO_N)
				vm:emit16(target_struct.size)
			else
				vm:emitOp(Opcode.PUSH_CHAR)
				vm:emit8(colobj_id)
				vm:emitOp(Opcode.PUSH_ZERO_N)
				vm:emit16(target_struct.size - 1)
			end
		else
			local target_memberc: isize = #target_struct.members
			local target_member_info: TypeInfo
			local memberc: isize = 0
			local target_offset: integer = 0

			if colobj_id ~= 0xFF then
				memberc = 1
				target_offset = 1

				vm:emitOp(Opcode.PUSH_CHAR)
				vm:emit8(colobj_id)
			end
			
			while vm.token ~= ')'_u8 do
				if memberc + 1 > target_memberc then
					compileError!(string.format(
						"line %d:\ntoo many member values in initializer for struct type `%s`. expected %d",
						vm.line,
						target_struct.name,
						target_memberc - target_offset
					))
				else
					target_member_info = target_struct.members[memberc + 1].type_info
				end
				
				try!(expression(Token.ASSIGN))

				if vm.expr_type.type_id == EVMType.VOID then
					compileError!(string.format("line %d:\ncannot pass expression of type `void` to struct initializer", vm.line))
				elseif target_member_info.type_id ~= vm.expr_type.type_id then
					-- can we convert types?
					local can_convert: boolean = false
					
					if target_member_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
						can_convert = true
						vm:emitOp(Opcode.FTOI)
					elseif target_member_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif target_member_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
						vm:emitOp(Opcode.ITOF)
					elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
					elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif target_member_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
					elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
						can_convert = (target_member_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
					end
					
					if not can_convert then
						compileError!(string.format(
							"line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`",
							vm.line,
							(memberc + 1) - target_offset,
							target_struct.name,
							getTypeName(target_member_info),
							getTypeName(vm.expr_type)
						))
					end
				elseif target_member_info.type_id == EVMType.STRUCT then
					if target_member_info.structref ~= vm.expr_type.structref then
						compileError!(string.format("line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`", vm.line, memberc + 1, target_struct.name, target_member_info.structref.name, vm.expr_type.structref.name))
					end
				elseif target_member_info.type_id == EVMType.FUNC_POINTER then
					if not matchFuncPointerTypes(target_member_info.fptr_info, vm.expr_type.fptr_info) then
						compileError!(string.format(
							"line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`",
							vm.line,
							(memberc + 1) - target_offset,
							target_struct.name,
							getTypeName(target_member_info),
							getTypeName(vm.expr_type)
						))
					end
				end

				memberc = memberc + 1
				if vm.token == ','_u8 then
					try!(match(','_u8))
				end
			end

			if memberc < target_memberc then
				compileError!(string.format(
					"line %d:\ntoo few member values in initializer for struct type `%s`. expected %d, got %d",
					vm.line,
					target_struct.name,
					target_memberc - target_offset,
					memberc - target_offset
				))
			end
			
			try!(match(')'_u8))
		end

		vm.expr_type = target_info
	elseif vm.token == Token.SIZEOF then
		try!(match(Token.SIZEOF))

		try!(match('('_u8))

		local target_info: TypeInfo = {EVMType.INT, nilptr}
	
		if vm.token == Token.VOID then
			try!(match(Token.VOID))
			target_info.type_id = EVMType.VOID
		elseif vm.token == Token.INT then
			try!(match(Token.INT))
			target_info.type_id = EVMType.INT
		elseif vm.token == Token.FLOAT then
			try!(match(Token.FLOAT))
			target_info.type_id = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			target_info.structref = vm.struct_vec2
			try!(match(Token.VEC2))
			target_info.type_id = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			target_info.structref = vm.struct_vec3
			try!(match(Token.VEC3))
			target_info.type_id = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			target_info.structref = vm.current_id.type_info.structref
			try!(match(Token.STRUCT_ID))
			target_info.type_id = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			target_info.structref = vm.struct_string
			try!(match(Token.STRING))
			target_info.type_id = EVMType.STRING
		else
			compileError!(string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			target_info.type_id = target_info.type_id + EVMType.POINTER
		end

		-- check for function pointer syntax
		if vm.token == '('_u8 then
			try!(match('('_u8))
			try!((
				do
					target_info.fptr_info = functionPointerType(target_info.structref, target_info.type_id, false)
				end
			))
			target_info.structref = nilptr
			target_info.type_id = EVMType.FUNC_POINTER
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			target_info.type_id = target_info.type_id + EVMType.POINTER
		end

		if target_info.type_id == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot get size of `void`", vm.line))
		end

		try!(match(')'_u8))

		local size: uinteger = sizeOfType(target_info) * 4

		if size < 256 then
			vm:emitOp(Opcode.PUSH_CHAR)
			vm:emit8(size)
		else
			vm:emitOp(Opcode.PUSH_INT)
			vm:emit32(size)
		end
		
		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.ID then
		try!(match(Token.ID))
		
		id = vm.current_id

		if not vm.has_id then
			compileError!(string.format("line %d:\nundefined identifier `%s`", vm.line, id.name))
		end

		if vm.token == '('_u8 then
			-- function call
			try!(match('('_u8))

			local can_call: boolean = false
			local calling_ptr: boolean = false

			if id.class == Class.FUNCTION or id.class == Class.API then
				can_call = true
			elseif id.class >= Class.GLOBAL and id.class <= Class.LOCAL then
				if id.type_info.type_id == EVMType.FUNC_POINTER then
					can_call = true
					calling_ptr = true
				end
			end
			
			if not can_call then
				compileError!(string.format("line %d:\ncannot call non-function identifier `%s`", vm.line, id.name))
			end

			-- info needed for function call
			local argdata: sequence(TypeInfo)
			local is_varargs: boolean
			local result_type: TypeInfo

			if calling_ptr then
				argdata = id.type_info.fptr_info.argdata
				is_varargs = id.type_info.fptr_info.is_varargs
				result_type = id.type_info.fptr_info.return_type
			else
				argdata = id.argdata
				is_varargs = id.is_varargs
				result_type = id.type_info
			end

			local is_constructor: boolean = vm.api_ids:has(id.name) and id.func == nilptr
			local target_argc: isize = #argdata
			local target_info: TypeInfo
			local argc: isize = 0
			local size: uint16 = 0

			if not is_varargs and target_argc == 0 then
				if vm.token ~= ')'_u8 then
					compileError!(string.format("line %d:\ntoo many arguments in call to function `%s`. expected 0", vm.line, id.name))
				end
			else
				while vm.token ~= ')'_u8 do
					-- only check arg count if:
					-- function is not varargs
					-- or

					if is_varargs then
						if argc < target_argc then
							target_info = argdata[argc + 1]
						end
					else
						if argc + 1 > target_argc then
							compileError!(string.format("line %d:\ntoo many arguments in call to function `%s`. expected %d", vm.line, id.name, target_argc))
						else
							target_info = argdata[argc + 1]
						end
					end
					
					try!(expression(Token.ASSIGN))

					if vm.expr_type.type_id == EVMType.VOID then
						compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
					end

					-- only typecheck if:
					-- the function is not varargs
					-- or
					-- the function is varargs, and there are still required arguments
					if not is_varargs or (is_varargs and (argc < target_argc)) then
						if target_info.type_id ~= vm.expr_type.type_id then
							-- can we convert types?
							local can_convert: boolean = false
							
							if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
								can_convert = true
								vm:emitOp(Opcode.FTOI)
							elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
								vm:emitOp(Opcode.ITOF)
							elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
							elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
							elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
								can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
							end
							
							if not can_convert then
								compileError!(string.format(
									"line %d:\ninvalid type for argument %d in call to function `%s`. expected `%s`, got `%s`",
									vm.line,
									argc + 1,
									id.name,
									getTypeName(target_info),
									getTypeName(vm.expr_type)
								))
							end
						elseif target_info.type_id == EVMType.STRUCT then
							if target_info.structref ~= vm.expr_type.structref then
								compileError!(string.format("line %d:\ninvalid type for argument %d in call to function `%s`. expected `%s`, got `%s`", vm.line, argc + 1, id.name, target_info.structref.name, vm.expr_type.structref.name))
							end
						elseif target_info.type_id == EVMType.FUNC_POINTER then
							if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
								compileError!(string.format(
									"line %d:\ninvalid type for argument %d in call to function `%s`. expected `%s`, got `%s`",
									vm.line,
									argc + 1,
									id.name,
									getTypeName(target_info),
									getTypeName(vm.expr_type)
								))
							end
						end
					end

					if not is_constructor then
						size = size + sizeOfType(vm.expr_type)
					end

					argc = argc + 1
					if vm.token == ','_u8 then
						try!(match(','_u8))
					end
				end

				if argc < target_argc then
					if is_varargs then
						compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
					else
						compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
					end
				end
			end
			try!(match(')'_u8))

			-- emit code
			if calling_ptr then
				-- push pointer value
				switch id.class do
					case Class.GLOBAL then
						vm:emitOp(Opcode.GET_G)
					case Class.ARG then
						vm:emitOp(Opcode.GET_A)
					case Class.LOCAL then
						vm:emitOp(Opcode.GET_L)
				end
				vm:emit16(id.index)

				-- call pointer
				vm:emitOp(Opcode.CALL_FPTR)
				vm:emit16(size)
			else
				if id.class == Class.API then
					if is_constructor then
						vm:emitOp((@uint8)(id.const_val))
					else
						vm:emitOp(Opcode.API)
						vm:emit16(id.index)
						vm:emit16(size)
					end
				elseif id.class == Class.FUNCTION then
					vm:emitOp(Opcode.CALL)
					vm:emit24(id.index)
					vm:emit16(size)
				end
			end

			if vm.token == '('_u8 then
				-- function pointer value call (pointer from function call)
				try!(match('('_u8))

				if result_type.type_id ~= EVMType.FUNC_POINTER then
					compileError!(string.format("line %d:\ncannot call non-function type `%s`", vm.line, getTypeName(result_type)))
				end

				-- pop function pointer off the stack
				vm:emitOp(Opcode.SAVE_FPTR)

				-- info needed for function call
				argdata = result_type.fptr_info.argdata
				is_varargs = result_type.fptr_info.is_varargs
				result_type = result_type.fptr_info.return_type
				target_argc = #argdata
				argc = 0
				size = 0

				if not is_varargs and target_argc == 0 then
					if vm.token ~= ')'_u8 then
						compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected 0", vm.line))
					end
				else
					while vm.token ~= ')'_u8 do
						-- only check arg count if:
						-- function is not varargs
						-- or

						if is_varargs then
							if argc < target_argc then
								target_info = argdata[argc + 1]
							end
						else
							if argc + 1 > target_argc then
								compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected %d", vm.line, target_argc))
							else
								target_info = argdata[argc + 1]
							end
						end
						
						try!(expression(Token.ASSIGN))

						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
						end

						-- only typecheck if:
						-- the function is not varargs
						-- or
						-- the function is varargs, and there are still required arguments
						if not is_varargs or (is_varargs and (argc < target_argc)) then
							if target_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_info.type_id == EVMType.STRUCT then
								if target_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`", vm.line, argc + 1, target_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							end
						end

						size = size + sizeOfType(vm.expr_type)

						argc = argc + 1
						if vm.token == ','_u8 then
							try!(match(','_u8))
						end
					end

					if argc < target_argc then
						if is_varargs then
							compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
						else
							compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
						end
					end
				end
				try!(match(')'_u8))

				vm:emitOp(Opcode.CALL_SAVED_FPTR)
				vm:emit16(size)
			end

			vm.expr_type = result_type
		elseif id.class == Class.CONSTANT then
			switch id.type_info.type_id do
				case EVMType.INT then
					if id.const_val == 0 then
						vm:emitOp(Opcode.PUSH_ZERO)
					elseif id.const_val == 1 then
						vm:emitOp(Opcode.PUSH_ONE)
					elseif id.const_val < 256 then -- simple optimization, turn small enum values into chars
						vm:emitOp(Opcode.PUSH_CHAR)
						vm:emit8((@uint8)(id.const_val & 0xFF))
					else
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(id.const_val)
					end
				case EVMType.FLOAT then
					if id.const_valf == 0.0 then
						vm:emitOp(Opcode.PUSH_ZEROF)
					elseif id.const_valf == 1.0 then
						vm:emitOp(Opcode.PUSH_ONEF)
					else
						vm:emitOp(Opcode.PUSH_FLOAT)
						vm:emitF(id.const_valf)
					end
				else
					if id.type_info.type_id >= EVMType.POINTER then
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(id.const_val)
					end
			end
			
			vm.expr_type = id.type_info
		else
			-- variable/function name (fptr)
			if (id.class >= Class.GLOBAL) and (id.class <= Class.LOCAL) then
				if id.is_array then
					switch id.class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.ADDROF_G)
						case Class.ARG then
							vm:emitOp(Opcode.ADDROF_A)
						case Class.LOCAL then
							vm:emitOp(Opcode.ADDROF_L)
					end

					vm:emit16(id.index)
				else
					if id.class == Class.GLOBAL then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_GX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_G)
							vm:emit16(id.index)
						end
					elseif id.class == Class.ARG then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_AX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_A)
							vm:emit16(id.index)
						end
					elseif id.class == Class.LOCAL then
						if id.type_info.type_id >= EVMType.VEC2 and id.type_info.type_id <= EVMType.STRING then
							vm:emitOp(Opcode.GET_LX)
							vm:emit16(id.index)
							vm:emit16(id.type_info.structref.size)
						else
							vm:emitOp(Opcode.GET_L)
							vm:emit16(id.index)
						end
					end
				end

				vm.expr_type = id.type_info
			elseif id.class == Class.FUNCTION then
				-- push bytecode function pointer (0x10XXXXXX)
				vm:emitOp(Opcode.PUSH_INT)
				vm:emit32(0x10000000 | id.index)

				local fptr_info: *FuncPointerInfo = new(@FuncPointerInfo)
				fptr_info.return_type = id.type_info
				fptr_info.is_varargs = id.is_varargs
				fptr_info.argdata = id.argdata
				vm.expr_type = {EVMType.FUNC_POINTER, nilptr, fptr_info}
			elseif id.class == Class.API then
				-- push api function pointer (0x2000XXXX)
				vm:emitOp(Opcode.PUSH_INT)
				vm:emit32(0x20000000 | id.index)
				
				local fptr_info: *FuncPointerInfo = new(@FuncPointerInfo)
				fptr_info.return_type = id.type_info
				fptr_info.is_varargs = id.is_varargs
				fptr_info.argdata = id.argdata
				vm.expr_type = {EVMType.FUNC_POINTER, nilptr, fptr_info}
			else
				compileError!(string.format("line %d:\ninvalid identifier `%s`", vm.line, id.name))
			end
		end
	elseif vm.token == '('_u8 then
		temp = vm.expr_type

		try!(match('('_u8))
		if vm.token >= Token.VOID and vm.token <= Token.STRING then
			-- cast or struct initializer
			local target_info: TypeInfo = {EVMType.INT}
	
			if vm.token == Token.VOID then
				try!(match(Token.VOID))
				target_info.type_id = EVMType.VOID
			elseif vm.token == Token.INT then
				try!(match(Token.INT))
				target_info.type_id = EVMType.INT
			elseif vm.token == Token.FLOAT then
				try!(match(Token.FLOAT))
				target_info.type_id = EVMType.FLOAT
			elseif vm.token == Token.VEC2 then
				target_info.structref = vm.struct_vec2
				try!(match(Token.VEC2))
				target_info.type_id = EVMType.VEC2
			elseif vm.token == Token.VEC3 then
				target_info.structref = vm.struct_vec3
				try!(match(Token.VEC3))
				target_info.type_id = EVMType.VEC3
			elseif vm.token == Token.STRUCT_ID then
				target_info.structref = vm.current_id.type_info.structref
				try!(match(Token.STRUCT_ID))
				target_info.type_id = EVMType.STRUCT
			elseif vm.token == Token.STRING then
				target_info.structref = vm.struct_string
				try!(match(Token.STRING))
				target_info.type_id = EVMType.STRING
			end
	
			while vm.token == Token.MUL do
				try!(match(Token.MUL))
				target_info.type_id = target_info.type_id + EVMType.POINTER
			end

			-- check for function pointer syntax
			if vm.token == '('_u8 then
				try!(match('('_u8))
				try!((
					do
						target_info.fptr_info = functionPointerType(target_info.structref, target_info.type_id, false)
					end
				))
				target_info.structref = nilptr
				target_info.type_id = EVMType.FUNC_POINTER
			end

			while vm.token == Token.MUL do
				try!(match(Token.MUL))
				target_info.type_id = target_info.type_id + EVMType.POINTER
			end

			try!(match(')'_u8))

			if vm.token == '{'_u8 then
				-- C-style struct initializer

				if target_info.type_id >= EVMType.VEC2 and target_info.type_id <= EVMType.STRING then
					try!(match('{'_u8))

					local target_struct: *Struct = target_info.structref
					local colobj_id: uint8 = 0xFF -- value not mapped to any collision object type

					if target_struct.name == "colpoint" then
						colobj_id = 0
					elseif target_struct.name == "colaabb" then
						colobj_id = 1
					elseif target_struct.name == "colsphere" then
						colobj_id = 2
					elseif target_struct.name == "colcylinder" then
						colobj_id = 3
					elseif target_struct.name == "coltriangle" then
						colobj_id = 4
					end

					if vm.token == '}'_u8 then
						try!(match('}'_u8))
						
						if colobj_id == 0xFF then
							vm:emitOp(Opcode.PUSH_ZERO_N)
							vm:emit16(target_struct.size)
						else
							vm:emitOp(Opcode.PUSH_CHAR)
							vm:emit8(colobj_id)
							vm:emitOp(Opcode.PUSH_ZERO_N)
							vm:emit16(target_struct.size - 1)
						end
					else
						local target_memberc: isize = #target_struct.members
						local target_member_info: TypeInfo
						local memberc: isize = 0
						local target_offset: integer = 0

						if colobj_id ~= 0xFF then
							memberc = 1
							target_offset = 1

							vm:emitOp(Opcode.PUSH_CHAR)
							vm:emit8(colobj_id)
						end
						
						while vm.token ~= '}'_u8 do
							if memberc + 1 > target_memberc then
								compileError!(string.format(
									"line %d:\ntoo many member values in initializer for struct type `%s`. expected %d",
									vm.line,
									target_struct.name,
									target_memberc - target_offset
								))
							else
								target_member_info = target_struct.members[memberc + 1].type_info
							end
							
							try!(expression(Token.ASSIGN))
		
							if vm.expr_type.type_id == EVMType.VOID then
								compileError!(string.format("line %d:\ncannot pass expression of type `void` to struct initializer", vm.line))
							elseif target_member_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_member_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_member_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_member_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_member_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_member_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_member_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`",
										vm.line,
										(memberc + 1) - target_offset,
										target_struct.name,
										getTypeName(target_member_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_member_info.type_id == EVMType.STRUCT then
								if target_member_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`", vm.line, memberc + 1, target_struct.name, target_member_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_member_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_member_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for memeber value %d in initializer for struct type `%s`. expected `%s`, got `%s`",
										vm.line,
										(memberc + 1) - target_offset,
										target_struct.name,
										getTypeName(target_member_info),
										getTypeName(vm.expr_type)
									))
								end
							end
		
							memberc = memberc + 1
							if vm.token == ','_u8 then
								try!(match(','_u8))
							end
						end
		
						if memberc < target_memberc then
							compileError!(string.format(
								"line %d:\ntoo few member values in initializer for struct type `%s`. expected %d, got %d",
								vm.line,
								target_struct.name,
								(target_memberc) - target_offset,
								(memberc) - target_offset
							))
						end
						
						try!(match('}'_u8))
					end
				else
					compileError!(string.format(
						"line %d:\ninvalid type `%s` for struct initializer",
						vm.line,
						getTypeName(target_info)
					))
				end
			else
				-- cast
				try!(expression(Token.ARROW))

				if target_info.type_id == EVMType.VOID then
					compileError!(string.format("line %d:\ncannot cast to type `void`", vm.line))
				end
				if vm.expr_type.type_id == EVMType.VOID then
					compileError!(string.format(
						"line %d:\ncannot cast expression of type `void` to `%s`",
						vm.line,
						getTypeName(target_info)
					))
				elseif target_info.type_id ~= vm.expr_type.type_id then
					-- can we convert types?
					local can_convert: boolean = false
					
					if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
						can_convert = true
						vm:emitOp(Opcode.FTOI)
					elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
						vm:emitOp(Opcode.ITOF)
					elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
					elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
					elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
						can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
					end
					
					if not can_convert then
						compileError!(string.format(
							"line %d:\ncannot cast expression of type `%s` to `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName(target_info)
						))
					end
				elseif target_info.type_id == EVMType.STRUCT then
					if target_info.structref ~= vm.expr_type.structref then
						compileError!(string.format("line %d:\ncannot cast expression of type `%s` to `%s`", vm.line, vm.expr_type.structref.name, target_info.structref.name))
					end
				elseif target_info.type_id == EVMType.FUNC_POINTER then
					if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
						compileError!(string.format(
							"line %d:\ncannot cast expression of type `%s` to `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName(target_info)
						))
					end
				end
			end
			
			vm.expr_type = target_info
		else
			try!(expression(Token.ASSIGN))
			try!(match(')'_u8))

			if vm.token == '('_u8 then
				-- function pointer value call (pointer from array fetch)
				try!(match('('_u8))

				if vm.expr_type.type_id ~= EVMType.FUNC_POINTER then
					compileError!(string.format("line %d:\ncannot call non-function type `%s`", vm.line, getTypeName(vm.expr_type)))
				end

				-- pop function pointer off the stack
				vm:emitOp(Opcode.SAVE_FPTR)

				-- info needed for function call
				local argdata: sequence(TypeInfo) = vm.expr_type.fptr_info.argdata
				local is_varargs: boolean = vm.expr_type.fptr_info.is_varargs
				local result_type: TypeInfo = vm.expr_type.fptr_info.return_type
				local target_argc: isize = #argdata
				local target_info: TypeInfo
				local argc: isize = 0
				local size: uint16 = 0

				if not is_varargs and target_argc == 0 then
					if vm.token ~= ')'_u8 then
						compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected 0", vm.line))
					end
				else
					while vm.token ~= ')'_u8 do
						-- only check arg count if:
						-- function is not varargs
						-- or

						if is_varargs then
							if argc < target_argc then
								target_info = argdata[argc + 1]
							end
						else
							if argc + 1 > target_argc then
								compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected %d", vm.line, target_argc))
							else
								target_info = argdata[argc + 1]
							end
						end
						
						try!(expression(Token.ASSIGN))

						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
						end

						-- only typecheck if:
						-- the function is not varargs
						-- or
						-- the function is varargs, and there are still required arguments
						if not is_varargs or (is_varargs and (argc < target_argc)) then
							if target_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_info.type_id == EVMType.STRUCT then
								if target_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`", vm.line, argc + 1, target_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							end
						end

						size = size + sizeOfType(vm.expr_type)

						argc = argc + 1
						if vm.token == ','_u8 then
							try!(match(','_u8))
						end
					end

					if argc < target_argc then
						if is_varargs then
							compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
						else
							compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
						end
					end
				end
				try!(match(')'_u8))

				vm:emitOp(Opcode.CALL_SAVED_FPTR)
				vm:emit16(size)

				vm.expr_type = result_type
			end
		end
	elseif vm.token == Token.MUL then
		try!(match(Token.MUL))
	    
		try!(expression(Token.ARROW))

		if vm.expr_type.type_id > EVMType.POINTER then
			vm.expr_type.type_id = vm.expr_type.type_id - EVMType.POINTER
		else
			compileError!(string.format(
				"line %d:\ncannot dereference expression of type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			))
		end

		if (vm.expr_type.type_id >= EVMType.VEC2) and (vm.expr_type.type_id <= EVMType.STRING) then
			vm:emitOp(Opcode.GET_MX)
			vm:emit16(0)
			vm:emit16(vm.expr_type.structref.size)
		else
			vm:emitOp(Opcode.GET_M)
			vm:emit16(0)
		end
	elseif vm.token == Token.AND then
		try!(match(Token.AND))
		
		try!(expression(Token.ARROW))

		--[[
			we've already emitted code for fetching the variable/value:

			GET_G/A/L <index>
			or
			GET_(G/A/L)X <index> <size>

			or if dereference:
			GET_M
			or
			GET_MX <size>

			we need to overwrite that with:

			ADDROF_G/A/L <index>
			
			or if dereference, just remove GET_M/MX and leave address on the stack
		]]

		local op: uint8 = vm.prev_opcode
		local index: uint16
		if op == Opcode.GET_G or op == Opcode.GET_L or op == Opcode.GET_A then
			vm.bytecode_len = vm.bytecode_len - 3
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX then
			vm.bytecode_len = vm.bytecode_len - 5
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_M then
			vm.bytecode_len = vm.bytecode_len - 3
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		elseif op == Opcode.GET_MX then
			vm.bytecode_len = vm.bytecode_len - 5
			index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
		else
			compileError!(string.format("line %d:\ninvalid rvalue for address-of", vm.line))
		end

		switch op do
			case Opcode.GET_G, Opcode.GET_GX then
				vm:emitOp(Opcode.ADDROF_G)
				vm:emit16(index)
			case Opcode.GET_L, Opcode.GET_LX then
				vm:emitOp(Opcode.ADDROF_L)
				vm:emit16(index)
			case Opcode.GET_A, Opcode.GET_AX then
				vm:emitOp(Opcode.ADDROF_A)
				vm:emit16(index)
			case Opcode.GET_M, Opcode.GET_MX then
				if index > 0 then
					-- we were fetching with an offset, we need to add that offset to the pointer

					-- optimize offset bytecode
					if index == 1 then
						vm:emitOp(Opcode.PUSH_ONE)
					elseif index < 256 then
						vm:emitOp(Opcode.PUSH_CHAR)
						vm:emit8((@uint8)(index & 0xFF))
					else
						vm:emitOp(Opcode.PUSH_INT)
						vm:emit32(index)
					end
					
					vm:emitOp(Opcode.ADDP)
					vm:emit16(1)
				end
		end

		vm.expr_type.type_id = vm.expr_type.type_id + EVMType.POINTER
	elseif vm.token == Token.LNOT then
		try!(match(Token.LNOT))

		try!(expression(Token.ARROW))

		if vm.expr_type.type_id == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
		end
		
		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.LNOT)
		elseif vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp(Opcode.LNOTP)
		elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
			vm:emitOp(Opcode.LNOTFP)
		else
			compileError!(string.format(
				"line %d:\ncannot use operator `!` on type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			))
		end

		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.NOT then
		try!(match(Token.NOT))
		
		try!(expression(Token.ARROW))
		
		if vm.expr_type.type_id == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
		end
		
		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.NOT)
		else
			compileError!(string.format("line %d:\ncannot use operator `~` on type `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			))
		end

		vm.expr_type = {EVMType.INT}
	elseif vm.token == Token.SUB then
		try!(match(Token.SUB))

		if vm.token == Token.INT_LITERAL then
			if vm.token_val == 0 then
				vm:emitOp(Opcode.PUSH_ZERO)
			elseif vm.token_val == 1 then
				vm:emitOp(Opcode.PUSH_ONE)
				vm:emitOp(Opcode.NEG)
			elseif vm.token_val < 256 then -- simple optimization, turn small int literals into chars
				vm:emitOp(Opcode.PUSH_CHAR)
				vm:emit8((@uint8)(vm.token_val & 0xFF))
				vm:emitOp(Opcode.NEG)
			else
				vm:emitOp(Opcode.PUSH_INT)
				vm:emit32(-(@int32)(vm.token_val))
			end
			
			try!(match(Token.INT_LITERAL))
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.FLOAT_LITERAL then
			if vm.token_valf == 0.0 then
				vm:emitOp(Opcode.PUSH_ZEROF)
				vm:emitOp(Opcode.NEGF)
			elseif vm.token_valf == 1.0 then
				vm:emitOp(Opcode.PUSH_ONEF)
				vm:emitOp(Opcode.NEGF)
			else
				vm:emitOp(Opcode.PUSH_FLOAT)
				vm:emitF(-vm.token_valf)
			end

			try!(match(Token.FLOAT_LITERAL))
			vm.expr_type = {EVMType.FLOAT}
		else
			try!(expression(Token.ARROW))

			switch vm.expr_type.type_id do
				case EVMType.VOID then
					compileError!(string.format("line %d:\ncannot negate expression of type `void`", vm.line))
				case EVMType.INT then
					vm.expr_type = {EVMType.INT}
					vm:emitOp(Opcode.NEG)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.NEGF)
					vm.expr_type = {EVMType.FLOAT}
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.NEGV)
					vm:emit8(vm.expr_type.type_id == EVMType.VEC3 and 1 or 0)
				else
					compileError!(string.format("line %d:\ncannot negate expression of type `%s`", vm.line, vm.expr_type.structref.name))
			end
		end
	else
		compileError!(string.format(
			"line %d:\nunexpected token `%s`",
			vm.line,
			getTokenString(vm.token)
		))
	end

	-- binary operators
	while vm.token >= level do
		temp = vm.expr_type

		if vm.token == Token.ASSIGN then
			id = vm.current_id
			
			try!(match(Token.ASSIGN))

			--[[
				we've already emitted code for fetching the variable/value:

				GET_G/A/L <index>
				or
				GET_(G/A/L)X <index> <size>

				or if dereference:
				GET_M
				or
				GET_MX <size>

				we need to overwrite that with the following expression,
				and finish with code storing the result into the variable/address
			]]
			
			local op: uint8 = vm.prev_opcode
			local class: uinteger
			local index: uint16
			local size: uint16 = 1
			if op == Opcode.GET_G or op == Opcode.GET_L or op == Opcode.GET_A then
				vm.bytecode_len = vm.bytecode_len - 3
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
			elseif op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX then
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_M then
				vm.bytecode_len = vm.bytecode_len - 3
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
			elseif op == Opcode.GET_MX then
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_S then
				vm.bytecode_len = vm.bytecode_len - 1
			else
				compileError!(string.format("line %d:\ninvalid lvalue in assignment", vm.line))
			end

			switch op do
				case Opcode.GET_G, Opcode.GET_GX then
					class = Class.GLOBAL
				case Opcode.GET_L, Opcode.GET_LX then
					class = Class.LOCAL
				case Opcode.GET_A, Opcode.GET_AX then
					class = Class.ARG
				case Opcode.GET_M, Opcode.GET_MX then
					class = Class.MEMORY
				case Opcode.GET_S then
					temp = {EVMType.INT} -- we are writing a char into the string
					class = Class.STRING
			end

			try!(expression(Token.ASSIGN))

			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format(
					"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
					vm.line,
					getTypeName(temp)
				))
			elseif temp.type_id ~= vm.expr_type.type_id then
				-- can we convert types?
				local can_convert: boolean = false
				
				if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
					can_convert = true
					vm:emitOp(Opcode.FTOI)
				elseif temp.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
					vm:emitOp(Opcode.ITOF)
				elseif temp.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
				elseif temp.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif temp.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
				elseif temp.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
					can_convert = (temp.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
				end
				
				if not can_convert then
					compileError!(string.format(
						"line %d:\ncannot assign `%s` to symbol of type `%s`",
						vm.line,
						getTypeName(vm.expr_type),
						getTypeName(temp)
					))
				end

				switch class do
					case Class.GLOBAL then
						vm:emitOp(Opcode.SET_G)
						vm:emit16(index)
					case Class.LOCAL then
						vm:emitOp(Opcode.SET_L)
						vm:emit16(index)
					case Class.ARG then
						vm:emitOp(Opcode.SET_A)
						vm:emit16(index)
					case Class.MEMORY then
						vm:emitOp(Opcode.SET_M)
						vm:emit16(index)
					case Class.STRING then
						vm:emitOp(Opcode.SET_S)
				end
			else
				if temp.type_id == EVMType.VEC2 or temp.type_id == EVMType.VEC3 then
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_GX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_LX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.ARG then
							vm:emitOp(Opcode.SET_AX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_MX)
							vm:emit16(index)
							vm:emit16(size)
					end
				elseif temp.type_id == EVMType.STRUCT or temp.type_id == EVMType.STRING then
					if temp.structref ~= vm.expr_type.structref then
						compileError!(string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, vm.expr_type.structref.name, temp.structref.name))
					end
					
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_GX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_LX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.ARG then
							vm:emitOp(Opcode.SET_AX)
							vm:emit16(index)
							vm:emit16(size)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_MX)
							vm:emit16(index)
							vm:emit16(size)
					end
				elseif temp.type_id == EVMType.FUNC_POINTER then
					if not matchFuncPointerTypes(temp.fptr_info, vm.expr_type.fptr_info) then
						compileError!(string.format(
							"line %d:\ncannot assign `%s` to symbol of type `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName(temp)
						))
					end

					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_G)
							vm:emit16(index)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_L)
							vm:emit16(index)
						case Class.ARG then
							vm:emitOp(Opcode.SET_A)
							vm:emit16(index)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_M)
							vm:emit16(index)
					end
				else
					switch class do
						case Class.GLOBAL then
							vm:emitOp(Opcode.SET_G)
							vm:emit16(index)
						case Class.LOCAL then
							vm:emitOp(Opcode.SET_L)
							vm:emit16(index)
						case Class.ARG then
							vm:emitOp(Opcode.SET_A)
							vm:emit16(index)
						case Class.MEMORY then
							vm:emitOp(Opcode.SET_M)
							vm:emit16(index)
						case Class.STRING then
							vm:emitOp(Opcode.SET_S)
					end
				end
			end

			vm.expr_type = {EVMType.VOID} -- don't allow assignment chaining
		elseif vm.token == Token.COND then
			-- TODO: complete this
		elseif vm.token == Token.LOR then
			--[[
				<expr1> || <expr2>

				<expr1>
				JUMP_NZD b / JUMP_NNULLD b / JUMP_FPNNULLD
				<expr2>
				ITOB / PTOB / FPTOB
				b:
			]]

			try!(match(Token.LOR))

			if vm.expr_type.type_id == EVMType.INT then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_NZD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			elseif vm.expr_type.type_id >= EVMType.POINTER then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_NNULLD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_FPNNULLD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			else
				compileError!(string.format(
					"line %d:\ninvalid lvalue type for operator '||', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end
			
			try!(expression(Token.LAND))
			
			if vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ITOB)
			elseif vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp(Opcode.PTOB)
			elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
				vm:emitOp(Opcode.FPTOB)
			else
				compileError!(string.format(
					"line %d:\ninvalid rvalue type for operator '||', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end
			
			-- patch JUMP_NZD/JUMP_NNULLD/JUMP_FPNNULLD address
			vm.bytecode[addr] = ((vm.bytecode_len & 0xFF0000) >> 16)
			vm.bytecode[addr + 1] = ((vm.bytecode_len & 0xFF00) >> 8)
			vm.bytecode[addr + 2] = ((vm.bytecode_len) & 0xFF)
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LAND then
			--[[
				<expr1> && <expr2>

				<expr1>
				JUMP_ZD b / JUMP_NULLD b JUMP_FPNULLD
				<expr2>
				ITOB / PTOB / FPTOB
				b:
			]]

			try!(match(Token.LAND))

			if vm.expr_type.type_id == EVMType.INT then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_ZD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			elseif vm.expr_type.type_id >= EVMType.POINTER then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_NULLD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
				-- short circuit evaluation
				vm:emitOp(Opcode.JUMP_FPNULLD)
				
				addr = vm.bytecode_len
				
				vm:emit24(0)
			else
				compileError!(string.format(
					"line %d:\ninvalid lvalue type for operator '&&', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end

			try!(expression(Token.OR))
			
			if vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ITOB)
			elseif vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp(Opcode.PTOB)
			elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
				vm:emitOp(Opcode.FPTOB)
			else
				compileError!(string.format(
					"line %d:\ninvalid rvalue type for operator '&&', expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end

			-- patch JUMP_ZD/JUMP_NULLD/JUMP_FPNULLD address
			vm.bytecode[addr] = ((vm.bytecode_len & 0xFF0000) >> 16)
			vm.bytecode[addr + 1] = ((vm.bytecode_len & 0xFF00) >> 8)
			vm.bytecode[addr + 2] = ((vm.bytecode_len) & 0xFF)
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.OR then
			try!(match(Token.OR))

			try!(expression(Token.XOR))
			
			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.OR)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `|` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.XOR then
			try!(match(Token.XOR))

			try!(expression(Token.AND))
			
			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.XOR)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `^` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.AND then
			try!(match(Token.AND))
			
			try!(expression(Token.EQ))
			
			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.AND)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `&` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.EQ then
			try!(match(Token.EQ))

			try!(expression(Token.NE))

			try!(operatorTypeCheck(Token.EQ, temp, true))
			
			switch temp.type_id do
				case EVMType.FLOAT then
					vm:emitOp(Opcode.EQF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.EQV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				case EVMType.STRING then
					vm:emitOp(Opcode.EQS)
				else
					vm:emitOp(Opcode.EQ)
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.NE then
			try!(match(Token.NE))

			try!(expression(Token.LT))

			try!(operatorTypeCheck(Token.NE, temp, true))
			
			switch temp.type_id do
				case EVMType.FLOAT then
					vm:emitOp(Opcode.NEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.NEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				case EVMType.STRING then
					vm:emitOp(Opcode.NES)
				else
					vm:emitOp(Opcode.NE)
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LT then
			try!(match(Token.LT))

			try!(expression(Token.LSHIFT))

			try!(operatorTypeCheck(Token.LT, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.LTI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.LTF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.LTV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.GT then
			try!(match(Token.GT))

			try!(expression(Token.LSHIFT))

			try!(operatorTypeCheck(Token.GT, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.GTI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.GTF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.GTV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LE then
			try!(match(Token.LE))

			try!(expression(Token.LSHIFT))

			try!(operatorTypeCheck(Token.LE, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.LEI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.LEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.LEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.GE then
			try!(match(Token.GE))

			try!(expression(Token.LSHIFT))

			try!(operatorTypeCheck(Token.GE, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.GEI)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.GEF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.GEV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
			end

			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.LSHIFT then
			try!(match(Token.LSHIFT))

			try!(expression(Token.ADD))

			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.LSHIFT)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `<<` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.RSHIFT then
			try!(match(Token.RSHIFT))

			try!(expression(Token.ADD))
			
			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.RSHIFT)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `>>` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.ARSHIFT then
			try!(match(Token.ARSHIFT))

			try!(expression(Token.ADD))

			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ARSHIFT)
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `>>>` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
			
			vm.expr_type = {EVMType.INT}
		elseif vm.token == Token.ADD then
			try!(match(Token.ADD))

			try!(expression(Token.MUL))
			
			try!(operatorTypeCheck(Token.ADD, temp, true))

			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.ADD)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.ADDF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.ADDV)
					vm:emit8(temp.type_id == EVMType.VEC3 and 1 or 0)
				else
					if temp.type_id > EVMType.POINTER then
						vm:emitOp(Opcode.ADDP)
						vm:emit16(sizePointedTo(temp))
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.SUB then
			try!(match(Token.SUB))
			
			try!(expression(Token.MUL))

			try!(operatorTypeCheck(Token.SUB, temp, true))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.SUB)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.SUBF)
				case EVMType.VEC2, EVMType.VEC3 then
					vm:emitOp(Opcode.SUBV)
					vm:emit8(temp == EVMType.VEC3 and 1 or 0)
				else
					if temp.type_id > EVMType.POINTER then
						vm:emitOp(Opcode.SUBP)
						vm:emit16(sizePointedTo(temp))
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.MUL then
			try!(match(Token.MUL))

			try!(expression(Token.BRAK))

			try!(operatorTypeCheck(Token.MUL, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					switch vm.expr_type.type_id do
						case EVMType.VEC2 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.INT_V2)
						case EVMType.VEC3 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.INT_V3)
						else
							vm.expr_type = temp
							vm:emitOp(Opcode.MUL)
					end
				case EVMType.FLOAT then
					switch vm.expr_type.type_id do
						case EVMType.VEC2 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.FLOAT_V2)
						case EVMType.VEC3 then
							vm:emitOp(Opcode.MULV)
							vm:emit8(MulVMode.FLOAT_V3)
						else
							vm.expr_type = temp
							vm:emitOp(Opcode.MULF)
					end
				case EVMType.VEC2 then
					vm:emitOp(Opcode.MULV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(MulVMode.V2_INT)
						case EVMType.FLOAT then
							vm:emit8(MulVMode.V2_FLOAT)
						case EVMType.VEC2 then
							vm:emit8(MulVMode.V2_V2)
					end
					vm.expr_type = temp
				case EVMType.VEC3 then
					vm:emitOp(Opcode.MULV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(MulVMode.V3_INT)
						case EVMType.FLOAT then
							vm:emit8(MulVMode.V3_FLOAT)
						case EVMType.VEC3 then
							vm:emit8(MulVMode.V3_V3)
					end
					vm.expr_type = temp
			end
		elseif vm.token == Token.DIV then
			try!(match(Token.DIV))
			
			try!(expression(Token.BRAK))

			try!(operatorTypeCheck(Token.DIV, temp, false))
			
			switch temp.type_id do
				case EVMType.INT then
					vm:emitOp(Opcode.DIV)
				case EVMType.FLOAT then
					vm:emitOp(Opcode.DIVF)
				case EVMType.VEC2 then
					vm:emitOp(Opcode.DIVV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(DivVMode.V2_INT)
						case EVMType.FLOAT then
							vm:emit8(DivVMode.V2_FLOAT)
						case EVMType.VEC2 then
							vm:emit8(DivVMode.V2_V2)
					end
				case EVMType.VEC3 then
					vm:emitOp(Opcode.DIVV)
					switch vm.expr_type.type_id do
						case EVMType.INT then
							vm:emit8(DivVMode.V3_INT)
						case EVMType.FLOAT then
							vm:emit8(DivVMode.V3_FLOAT)
						case EVMType.VEC3 then
							vm:emit8(DivVMode.V3_V3)
					end
			end
			
			vm.expr_type = temp
		elseif vm.token == Token.MOD then
			try!(match(Token.MOD))

			try!(expression(Token.BRAK))
			
			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as rvalue", vm.line))
			end
			
			if temp.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.MOD)
				vm.expr_type = {EVMType.INT}
			elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.ITOF)
				vm:emitOp(Opcode.MODF)
				vm.expr_type = {EVMType.FLOAT}
			elseif temp.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.FLOAT then
				vm:emitOp(Opcode.MODF)
				vm.expr_type = {EVMType.FLOAT}
			else
				compileError!(string.format(
					"line %d:\ncannot use operator `%` on types `%s` and `%s`",
					vm.line,
					getTypeName(temp),
					getTypeName(vm.expr_type)
				))
			end
		elseif vm.token == Token.ARROW then
			if not (vm.expr_type.type_id >= (EVMType.VEC2 + EVMType.POINTER) and vm.expr_type.type_id <= (EVMType.STRING + EVMType.POINTER)) then
				compileError!(string.format("line %d:\ncannot index members of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end
			
			vm.skip_next_id_lookup = true -- we need to look up member ids manually
			try!(match(Token.ARROW))
			try!(match(Token.ID))
	
			-- lookup member
			vm.has_id, vm.current_id = vm.expr_type.structref:getMember(vm.current_id_name)
			if not vm.has_id then
				compileError!(string.format("line %d:\ncannot index member `%s` of symbol `%s`", vm.line, vm.current_id_name, id.name))
			end

			if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
				vm:emitOp(Opcode.GET_MX)
				vm:emit16(vm.current_id.index)
				vm:emit16(vm.current_id.type_info.structref.size)
			else
				vm:emitOp(Opcode.GET_M)
				vm:emit16(vm.current_id.index)
			end

			id = vm.current_id

			if vm.token == '('_u8 then
				-- function pointer value call (pointer from struct member dereference)
				try!(match('('_u8))

				if id.type_info.type_id ~= EVMType.FUNC_POINTER then
					compileError!(string.format("line %d:\ncannot call non-function type `%s`", vm.line, getTypeName(id.type_info)))
				end

				-- pop function pointer off the stack
				vm:emitOp(Opcode.SAVE_FPTR)

				-- info needed for function call
				local argdata: sequence(TypeInfo) = id.type_info.fptr_info.argdata
				local is_varargs: boolean = id.type_info.fptr_info.is_varargs
				local result_type: TypeInfo = id.type_info.fptr_info.return_type
				local target_argc: isize = #argdata
				local target_info: TypeInfo
				local argc: isize = 0
				local size: uint16 = 0

				if not is_varargs and target_argc == 0 then
					if vm.token ~= ')'_u8 then
						compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected 0", vm.line))
					end
				else
					while vm.token ~= ')'_u8 do
						-- only check arg count if:
						-- function is not varargs
						-- or

						if is_varargs then
							if argc < target_argc then
								target_info = argdata[argc + 1]
							end
						else
							if argc + 1 > target_argc then
								compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected %d", vm.line, target_argc))
							else
								target_info = argdata[argc + 1]
							end
						end
						
						try!(expression(Token.ASSIGN))

						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
						end

						-- only typecheck if:
						-- the function is not varargs
						-- or
						-- the function is varargs, and there are still required arguments
						if not is_varargs or (is_varargs and (argc < target_argc)) then
							if target_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_info.type_id == EVMType.STRUCT then
								if target_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`", vm.line, argc + 1, target_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							end
						end

						size = size + sizeOfType(vm.expr_type)

						argc = argc + 1
						if vm.token == ','_u8 then
							try!(match(','_u8))
						end
					end

					if argc < target_argc then
						if is_varargs then
							compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
						else
							compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
						end
					end
				end
				try!(match(')'_u8))

				vm:emitOp(Opcode.CALL_SAVED_FPTR)
				vm:emit16(size)

				vm.expr_type = result_type
			else
				vm.expr_type = vm.current_id.type_info
			end
		elseif vm.token == Token.DOT then
			id = vm.current_id
			
			if not (vm.expr_type.type_id >= EVMType.VEC2 and vm.expr_type.type_id <= EVMType.STRING) then
				compileError!(string.format(
					"line %d:\ncannot index members of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end

			local op: uint8 = vm.prev_opcode
			local class: uinteger
			local index: uint16
			local size: uint16 = 1
			local valid_lvalue: boolean = false
			
			if (vm.prev_token == Token.ID) and (op == Opcode.GET_GX or op == Opcode.GET_LX or op == Opcode.GET_AX) then
				valid_lvalue = true
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			elseif op == Opcode.GET_MX then
				valid_lvalue = true
				vm.bytecode_len = vm.bytecode_len - 5
				index = ((@uint16)(vm.bytecode[vm.bytecode_len + 1]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 2])
				size = ((@uint16)(vm.bytecode[vm.bytecode_len + 3]) << 8) | (@uint16)(vm.bytecode[vm.bytecode_len + 4])
			end

			if not valid_lvalue then
				compileError!(string.format("line %d:\ninvalid lvalue for member index", vm.line))
			end

			switch op do
				case Opcode.GET_GX then
					class = Class.GLOBAL
				case Opcode.GET_LX then
					class = Class.LOCAL
				case Opcode.GET_AX then
					class = Class.ARG
				case Opcode.GET_MX then
					class = Class.MEMORY
			end
			
			vm.skip_next_id_lookup = true -- we need to look up member ids manually
			try!(match(Token.DOT))
			try!(match(Token.ID))
	
			-- lookup member
			vm.has_id, vm.current_id = temp.structref:getMember(vm.current_id_name)
			if not vm.has_id then
				compileError!(string.format("line %d:\ncannot index member `%s` of symbol `%s`", vm.line, vm.current_id_name, id.name))
			end

			if class == Class.GLOBAL then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_GX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_G)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.ARG then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_AX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_A)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.LOCAL then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_LX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_L)
					vm:emit16(index + vm.current_id.index)
				end
			elseif class == Class.MEMORY then
				if vm.current_id.type_info.type_id >= EVMType.VEC2 and vm.current_id.type_info.type_id <= EVMType.STRING then
					vm:emitOp(Opcode.GET_MX)
					vm:emit16(index + vm.current_id.index)
					vm:emit16(vm.current_id.type_info.structref.size)
				else
					vm:emitOp(Opcode.GET_M)
					vm:emit16(index + vm.current_id.index)
				end
			end

			id = vm.current_id

			if vm.token == '('_u8 then
				-- function pointer value call (pointer from struct member)
				try!(match('('_u8))

				if id.type_info.type_id ~= EVMType.FUNC_POINTER then
					compileError!(string.format("line %d:\ncannot call non-function type `%s`", vm.line, getTypeName(id.type_info)))
				end

				-- pop function pointer off the stack
				vm:emitOp(Opcode.SAVE_FPTR)

				-- info needed for function call
				local argdata: sequence(TypeInfo) = id.type_info.fptr_info.argdata
				local is_varargs: boolean = id.type_info.fptr_info.is_varargs
				local result_type: TypeInfo = id.type_info.fptr_info.return_type
				local target_argc: isize = #argdata
				local target_info: TypeInfo
				local argc: isize = 0
				local size: uint16 = 0

				if not is_varargs and target_argc == 0 then
					if vm.token ~= ')'_u8 then
						compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected 0", vm.line))
					end
				else
					while vm.token ~= ')'_u8 do
						-- only check arg count if:
						-- function is not varargs
						-- or

						if is_varargs then
							if argc < target_argc then
								target_info = argdata[argc + 1]
							end
						else
							if argc + 1 > target_argc then
								compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected %d", vm.line, target_argc))
							else
								target_info = argdata[argc + 1]
							end
						end
						
						try!(expression(Token.ASSIGN))

						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
						end

						-- only typecheck if:
						-- the function is not varargs
						-- or
						-- the function is varargs, and there are still required arguments
						if not is_varargs or (is_varargs and (argc < target_argc)) then
							if target_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_info.type_id == EVMType.STRUCT then
								if target_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`", vm.line, argc + 1, target_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							end
						end

						size = size + sizeOfType(vm.expr_type)

						argc = argc + 1
						if vm.token == ','_u8 then
							try!(match(','_u8))
						end
					end

					if argc < target_argc then
						if is_varargs then
							compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
						else
							compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
						end
					end
				end
				try!(match(')'_u8))

				vm:emitOp(Opcode.CALL_SAVED_FPTR)
				vm:emit16(size)

				vm.expr_type = result_type
			else
				vm.expr_type = vm.current_id.type_info
			end
		elseif vm.token == Token.BRAK then
			try!(match(Token.BRAK))
			
			local is_string: boolean = false
			local size: uint16

			if vm.expr_type.type_id > EVMType.POINTER then
				size = sizePointedTo(vm.expr_type)
				vm.expr_type.type_id = vm.expr_type.type_id - EVMType.POINTER
				temp = vm.expr_type
			elseif vm.expr_type.type_id == EVMType.STRING then
				temp = {EVMType.INT}
				is_string = true
			else
				compileError!(string.format(
					"line %d:\ncannot subscript expression of type `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end
			
			try!(expression(Token.ASSIGN))

			try!(match(']'_u8))

			if (vm.expr_type.type_id < EVMType.INT) or (vm.expr_type.type_id > EVMType.FLOAT) then
				compileError!(string.format(
					"line %d:\ncannot use type `%s` as an array index",
					vm.line,
					getTypeName(vm.expr_type)
				))
			elseif vm.expr_type.type_id == EVMType.FLOAT then
				vm:emitOp(Opcode.FTOI)
			end

			if is_string then
				vm:emitOp(Opcode.GET_S)
			else
				vm:emitOp(Opcode.ADDP)
				vm:emit16(size)

				if (temp.type_id >= EVMType.VEC2) and (temp.type_id <= EVMType.STRING) then
					vm:emitOp(Opcode.GET_MX)
					vm:emit16(0)
					vm:emit16(size)
				else
					vm:emitOp(Opcode.GET_M)
					vm:emit16(0)
				end
			end

			if vm.token == '('_u8 then
				-- function pointer value call (pointer from array fetch)
				try!(match('('_u8))

				if temp.type_id ~= EVMType.FUNC_POINTER then
					compileError!(string.format("line %d:\ncannot call non-function type `%s`", vm.line, getTypeName(temp)))
				end

				-- pop function pointer off the stack
				vm:emitOp(Opcode.SAVE_FPTR)

				-- info needed for function call
				local argdata: sequence(TypeInfo) = temp.fptr_info.argdata
				local is_varargs: boolean = temp.fptr_info.is_varargs
				local result_type: TypeInfo = temp.fptr_info.return_type
				local target_argc: isize = #argdata
				local target_info: TypeInfo
				local argc: isize = 0
				local size: uint16 = 0

				if not is_varargs and target_argc == 0 then
					if vm.token ~= ')'_u8 then
						compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected 0", vm.line))
					end
				else
					while vm.token ~= ')'_u8 do
						-- only check arg count if:
						-- function is not varargs
						-- or

						if is_varargs then
							if argc < target_argc then
								target_info = argdata[argc + 1]
							end
						else
							if argc + 1 > target_argc then
								compileError!(string.format("line %d:\ntoo many arguments in call to function pointer. expected %d", vm.line, target_argc))
							else
								target_info = argdata[argc + 1]
							end
						end
						
						try!(expression(Token.ASSIGN))

						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format("line %d:\ncannot pass expression of type `void` as a function argument", vm.line))
						end

						-- only typecheck if:
						-- the function is not varargs
						-- or
						-- the function is varargs, and there are still required arguments
						if not is_varargs or (is_varargs and (argc < target_argc)) then
							if target_info.type_id ~= vm.expr_type.type_id then
								-- can we convert types?
								local can_convert: boolean = false
								
								if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
									can_convert = true
									vm:emitOp(Opcode.FTOI)
								elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
									vm:emitOp(Opcode.ITOF)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
									can_convert = true
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = true
								elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
									can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
									can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
								end
								
								if not can_convert then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							elseif target_info.type_id == EVMType.STRUCT then
								if target_info.structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`", vm.line, argc + 1, target_info.structref.name, vm.expr_type.structref.name))
								end
							elseif target_info.type_id == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ninvalid type for argument %d in call to function pointer. expected `%s`, got `%s`",
										vm.line,
										argc + 1,
										getTypeName(target_info),
										getTypeName(vm.expr_type)
									))
								end
							end
						end

						size = size + sizeOfType(vm.expr_type)

						argc = argc + 1
						if vm.token == ','_u8 then
							try!(match(','_u8))
						end
					end

					if argc < target_argc then
						if is_varargs then
							compileError!(string.format("line %d:\ntoo few arguments in call to varargs function `%s`. expected at least %d, got %d", vm.line, id.name, target_argc, argc))
						else
							compileError!(string.format("line %d:\ntoo few arguments in call to function `%s`. expected %d, got %d", vm.line, id.name, target_argc, argc))
						end
					end
				end
				try!(match(')'_u8))

				vm:emitOp(Opcode.CALL_SAVED_FPTR)
				vm:emit16(size)

				vm.expr_type = result_type
			else
				vm.expr_type = temp
			end
		else
			compileError!(string.format(
				"line %d:\nunexpected token `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end
	end
end

local function statement(): void
	local a: uinteger
	local b: uinteger
	
	if vm.token >= Token.VOID and vm.token <= Token.STRING then
		-- local variable declaration
		local var_type: uinteger = EVMType.INT
		local structref: *Struct
		local fptr_info: *FuncPointerInfo = nilptr

		if vm.token == Token.VOID then
			try!(match(Token.VOID))
			var_type = EVMType.VOID
		elseif vm.token == Token.INT then
			try!(match(Token.INT))
			var_type = EVMType.INT
		elseif vm.token == Token.FLOAT then
			try!(match(Token.FLOAT))
			var_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			structref = vm.struct_vec2
			try!(match(Token.VEC2))
			var_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			structref = vm.struct_vec3
			try!(match(Token.VEC3))
			var_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			structref = vm.current_id.type_info.structref
			try!(match(Token.STRUCT_ID))
			var_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			structref = vm.struct_string
			try!(match(Token.STRING))
			var_type = EVMType.STRING
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			var_type = var_type + EVMType.POINTER
		end

		-- check for function pointer syntax
		if vm.token == '('_u8 then
			try!(match('('_u8))
			try!((
				do
					fptr_info = functionPointerType(structref, var_type, false)
				end
			))
			structref = nilptr
			var_type = EVMType.FUNC_POINTER
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			var_type = var_type + EVMType.POINTER
		end

		if var_type == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot declare variable of type `void`", vm.line))
		end
		if vm.token ~= Token.ID then
			compileError!(string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end
		if vm.has_id then
			compileError!(string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name))
		end

		if structref and not structref.is_complete then
			compileError!(string.format("line %d:\ncannot declare variable of incomplete type", vm.line))
		end

		try!(match(Token.ID))

		vm.current_id.class = Class.LOCAL
		vm.current_id.type_info = {var_type, structref, fptr_info}
		vm.current_id.index = vm.local_index
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)

		local type_size: uinteger = sizeOfType(vm.current_id.type_info)
		
		if vm.token == Token.BRAK then
			vm.current_id.is_array = true
			vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

			try!(match(Token.BRAK))
			
			local array_size: uinteger

			if vm.token == Token.INT_LITERAL then
				array_size = vm.token_val
				try!(match(Token.INT_LITERAL))
			elseif vm.token == Token.ID then
				if not vm.has_id then
					compileError!(string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name))
				elseif vm.current_id.class ~= Class.CONSTANT then
					compileError!(string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name))
				end

				array_size = vm.current_id.const_val
				
				try!(match(Token.ID))
			else
				compileError!(string.format(
					"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
					vm.line,
					getTokenString(vm.token)
				))
			end

			if array_size == 0 then
				compileError!(string.format("line %d:\ncannot declare array of length 0", vm.line))
			end

			array_size = array_size * type_size

			vm.local_index = vm.local_index + array_size
			vm:incScopeLocalsSize(array_size)

			try!(match(']'_u8))
		else			
			vm.local_index = vm.local_index + type_size
			vm:incScopeLocalsSize(type_size)

			if vm.token == Token.ASSIGN then
				local id: *Identifier = vm.current_id
	
				try!(match(Token.ASSIGN))
	
				try!(expression(Token.ASSIGN))
	
				if vm.expr_type.type_id == EVMType.VOID then
					compileError!(string.format(
						"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
						vm.line,
						getTypeName({var_type, structref})
					))
				elseif var_type ~= vm.expr_type.type_id then
					-- can we convert types?
					local can_convert: boolean = false
					
					if var_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
						can_convert = true
						vm:emitOp(Opcode.FTOI)
					elseif var_type == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif var_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
						vm:emitOp(Opcode.ITOF)
					elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
						can_convert = true
					elseif var_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = true
					elseif var_type == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
						can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
					elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
						can_convert = (var_type & (EVMType.POINTER - 1) == EVMType.VOID)
					end
	
					if not can_convert then
						compileError!(string.format(
							"line %d:\ncannot assign `%s` to symbol of type `%s`",
							vm.line,
							getTypeName(vm.expr_type),
							getTypeName({var_type, structref, fptr_info})
						))
					end
	
					vm:emitOp(Opcode.SET_L)
					vm:emit16(id.index)
				else
					if var_type == EVMType.VEC2 or var_type == EVMType.VEC3 then
						vm:emitOp(Opcode.SET_LX)
						vm:emit16(id.index)
						vm:emit16(type_size)
					elseif var_type == EVMType.STRUCT or var_type == EVMType.STRING then
						if structref ~= vm.expr_type.structref then
							compileError!(string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, vm.expr_type.structref.name, structref.name))
						end
						
						vm:emitOp(Opcode.SET_LX)
						vm:emit16(id.index)
						vm:emit16(id.type_info.structref.size)
					elseif var_type == EVMType.FUNC_POINTER then
						if not matchFuncPointerTypes(fptr_info, vm.expr_type.fptr_info) then
							compileError!(string.format(
								"line %d:\ncannot assign `%s` to symbol of type `%s`",
								vm.line,
								getTypeName(vm.expr_type),
								getTypeName(id.type_info)
							))
						end

						vm:emitOp(Opcode.SET_L)
						vm:emit16(id.index)
					else
						vm:emitOp(Opcode.SET_L)
						vm:emit16(id.index)
					end
				end
			end
		end

		if vm.local_index > MEMORY_LOCALS_SIZE_ELEMENTS then
			compileError!(string.format("line %d:\nfunction local variable storage limit exceeded by %d word(s)", vm.line, vm.local_index - MEMORY_LOCALS_SIZE_ELEMENTS))
		end

		try!(match(';'_u8))
	elseif vm.token == Token.IF then
		--[[
			ERA-C:         | BYTECODE:
			---------------+-------------
			if (<cond>)    | <cond>
			               | JUMP_Z a
			  <true code>  | <true code>
			else:          | JUMP b
			a:             | a:
			  <false code> | <false code>
			b:             | b:
			-----------------------------
		]]
		
		try!(match(Token.IF))
		try!(match('('_u8))

		try!(expression(Token.ASSIGN))

		if vm.expr_type.type_id == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot use expression of type `void` as if statement condition", vm.line))
		end

		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.JUMP_Z)

			b = vm.bytecode_len
		
			vm:emit24(0)
		elseif vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp(Opcode.JUMP_NULL)

			b = vm.bytecode_len
		
			vm:emit24(0)
		elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
			vm:emitOp(Opcode.JUMP_FPNULL)

			b = vm.bytecode_len
		
			vm:emit24(0)
		else
			compileError!(string.format(
				"line %d:\ninvalid type for if statement condition. expected `int` or pointer, got `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			))
		end

		try!(match(')'_u8))

		try!(statement())
		
		if vm.token == Token.ELSE then
			try!(match(Token.ELSE))

			-- write jump_z address
			vm.bytecode[b] = (((vm.bytecode_len + 4) & 0xFF0000) >> 16)
			vm.bytecode[b + 1] = (((vm.bytecode_len + 4) & 0xFF00) >> 8)
			vm.bytecode[b + 2] = ((vm.bytecode_len + 4) & 0xFF)

			-- emit bytecode for JUMP b
			vm:emitOp(Opcode.JUMP)
			b = vm.bytecode_len
			vm:emit24(0)

			try!(statement())
		end

		vm.bytecode[b] = ((vm.bytecode_len & 0xFF0000) >> 16)
		vm.bytecode[b + 1] = ((vm.bytecode_len & 0xFF00) >> 8)
		vm.bytecode[b + 2] = ((vm.bytecode_len) & 0xFF)
	elseif vm.token == Token.FOR then
		--[[
			ERA-C:                        | BYTECODE:
			------------------------------+-------------
			for (<init>; <cond>; <step>)  | <init>
			                              | a:
										  | <cond>
										  | JUMP_Z b
			  <statement>                 | <statement>
										  | <step>
										  | JUMP a
										  | b:
		]]

		local for_line: uinteger = vm.line

		try!(match(Token.FOR))
		
		vm:pushScope()
		
		vm:emitOp(Opcode.NEW_L)
		local new_l_index: uinteger = vm.bytecode_len
		vm:emit16(0)
		
		try!(match('('_u8))

		-- init
		while vm.token ~= ';'_u8 do
			if vm.token >= Token.VOID and vm.token <= Token.STRING then
				-- init variable declaration
				local var_type: uinteger = EVMType.INT
				local structref: *Struct
				local fptr_info: *FuncPointerInfo

				if vm.token == Token.VOID then
					try!(match(Token.VOID))
					var_type = EVMType.VOID
				elseif vm.token == Token.INT then
					try!(match(Token.INT))
					var_type = EVMType.INT
				elseif vm.token == Token.FLOAT then
					try!(match(Token.FLOAT))
					var_type = EVMType.FLOAT
				elseif vm.token == Token.VEC2 then
					structref = vm.struct_vec2
					try!(match(Token.VEC2))
					var_type = EVMType.VEC2
				elseif vm.token == Token.VEC3 then
					structref = vm.struct_vec3
					try!(match(Token.VEC3))
					var_type = EVMType.VEC3
				elseif vm.token == Token.STRUCT_ID then
					structref = vm.current_id.type_info.structref
					try!(match(Token.STRUCT_ID))
					var_type = EVMType.STRUCT
				elseif vm.token == Token.STRING then
					structref = vm.struct_string
					try!(match(Token.STRING))
					var_type = EVMType.STRING
				end

				while vm.token == Token.MUL do
					try!(match(Token.MUL))
					var_type = var_type + EVMType.POINTER
				end

				-- check for function pointer syntax
				if vm.token == '('_u8 then
					try!(match('('_u8))
					try!((
						do
							fptr_info = functionPointerType(structref, var_type, false)
						end
					))
					structref = nilptr
					var_type = EVMType.FUNC_POINTER
				end

				while vm.token == Token.MUL do
					try!(match(Token.MUL))
					var_type = var_type + EVMType.POINTER
				end

				if var_type == EVMType.VOID then
					compileError!(string.format("line %d:\ncannot declare variable of type `void`", vm.line))
				end
				if vm.token ~= Token.ID then
					compileError!(string.format(
						"line %d:\nexpected token `identifier`, got `%s`",
						vm.line,
						getTokenString(vm.token)
					))
				end
				if vm.has_id then
					compileError!(string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name))
				end

				if structref and not structref.is_complete then
					compileError!(string.format("line %d:\ncannot declare variable of incomplete type", vm.line))
				end

				try!(match(Token.ID))

				vm.current_id.class = Class.LOCAL
				vm.current_id.type_info = {var_type, structref, fptr_info}
				vm.current_id.index = vm.local_index
				vm:addScopedSymbol(vm.current_id.name, vm.current_id)

				local type_size: uinteger = sizeOfType(vm.current_id.type_info)
				
				if vm.token == Token.BRAK then
					vm.current_id.is_array = true
					vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

					try!(match(Token.BRAK))
					
					local array_size: uinteger

					if vm.token == Token.INT_LITERAL then
						array_size = vm.token_val
						try!(match(Token.INT_LITERAL))
					elseif vm.token == Token.ID then
						if not vm.has_id then
							compileError!(string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name))
						elseif vm.current_id.class ~= Class.CONSTANT then
							compileError!(string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name))
						end

						array_size = vm.current_id.const_val
						
						try!(match(Token.ID))
					else
						compileError!(string.format(
							"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
							vm.line,
							getTokenString(vm.token)
						))
					end

					if array_size == 0 then
						compileError!(string.format("line %d:\ncannot declare array of length 0", vm.line))
					end

					array_size = array_size * type_size

					vm.local_index = vm.local_index + array_size
					vm:incScopeLocalsSize(array_size)

					try!(match(']'_u8))
				else
					vm.local_index = vm.local_index + type_size
					vm:incScopeLocalsSize(type_size)

					if vm.token == Token.ASSIGN then
						local id: *Identifier = vm.current_id
			
						try!(match(Token.ASSIGN))
			
						try!(expression(Token.ASSIGN))
			
						if vm.expr_type.type_id == EVMType.VOID then
							compileError!(string.format(
								"line %d:\ncannot assign expression of type `void` to symbol of type `%s`",
								vm.line,
								getTypeName({var_type, structref})
							))
						elseif var_type ~= vm.expr_type.type_id then
							-- can we convert types?
							local can_convert: boolean = false
							
							if var_type == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
								can_convert = true
								vm:emitOp(Opcode.FTOI)
							elseif var_type == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif var_type == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
								vm:emitOp(Opcode.ITOF)
							elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
								can_convert = true
							elseif var_type >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = true
							elseif var_type == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
								can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
							elseif var_type >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
								can_convert = (var_type & (EVMType.POINTER - 1) == EVMType.VOID)
							end
			
							if not can_convert then
								compileError!(string.format(
									"line %d:\ncannot assign `%s` to symbol of type `%s`",
									vm.line,
									vm.expr_type.type_id,
									getTypeName({var_type, structref, fptr_info})
								))
							end
			
							vm:emitOp(Opcode.SET_L)
							vm:emit16(id.index)
						else
							if var_type == EVMType.VEC2 or var_type == EVMType.VEC3 then
								vm:emitOp(Opcode.SET_LX)
								vm:emit16(id.index)
								vm:emit16(type_size)
							elseif var_type == EVMType.STRUCT or var_type == EVMType.STRING then
								if structref ~= vm.expr_type.structref then
									compileError!(string.format("line %d:\ncannot assign `%s` to symbol of type `%s`", vm.line, vm.expr_type.structref.name, structref.name))
								end
								
								vm:emitOp(Opcode.SET_LX)
								vm:emit16(id.index)
								vm:emit16(id.type_info.structref.size)
							elseif var_type == EVMType.FUNC_POINTER then
								if not matchFuncPointerTypes(fptr_info, vm.expr_type.fptr_info) then
									compileError!(string.format(
										"line %d:\ncannot assign `%s` to symbol of type `%s`",
										vm.line,
										getTypeName(vm.expr_type),
										getTypeName(id.type_info)
									))
								end
		
								vm:emitOp(Opcode.SET_L)
								vm:emit16(id.index)
							else
								vm:emitOp(Opcode.SET_L)
								vm:emit16(id.index)
							end
						end
					end
				end

				if vm.local_index > MEMORY_LOCALS_SIZE_ELEMENTS then
					compileError!(string.format("line %d:\nfunction local variable storage limit exceeded by %d word(s)", vm.line, vm.local_index - MEMORY_LOCALS_SIZE_ELEMENTS))
				end
			else
				try!(expression(Token.ASSIGN))
			end

			if vm.token == ','_u8 then
				try!(match(','_u8))
			end
		end

		try!(match(';'_u8))
		
		-- cond
		a = vm.bytecode_len

		vm:pushLoop(vm.bytecode_len)
		
		local has_condition: boolean = false
		if vm.token ~= ';'_u8 then
			has_condition = true

			try!(expression(Token.ASSIGN))

			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot use expression of type `void` as loop condition", vm.line))
			end
	
			if vm.expr_type.type_id == EVMType.INT then
				vm:emitOp(Opcode.JUMP_Z)
	
				b = vm.bytecode_len
			
				vm:emit24(0)
			elseif vm.expr_type.type_id >= EVMType.POINTER then
				vm:emitOp(Opcode.JUMP_NULL)
	
				b = vm.bytecode_len
			
				vm:emit24(0)
			elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
				vm:emitOp(Opcode.JUMP_FPNULL)
	
				b = vm.bytecode_len
			
				vm:emit24(0)
			else
				compileError!(string.format(
					"line %d:\ninvalid type for loop condition. expected `int` or pointer, got `%s`",
					vm.line,
					getTypeName(vm.expr_type)
				))
			end
		end
		
		local step_line: uinteger = vm.line

		try!(match(';'_u8))
		
		-- save our spot
		-- we're skipping over the step expressions for now,
		-- but we'll be back!
		local step_prev_token: uinteger = vm.prev_token
		local step_index: uinteger = vm.prev_src_index
		
		if vm.token ~= ')'_u8 then
			vm:setLoopHasStep()
		end
		while vm.token ~= ')'_u8 and vm.token ~= 0 do
			try!(next())
		end
		
		try!(match(')'_u8))
		
		-- loop body
		try!(statement())
		
		-- save our spot again
		-- we'll return to the step expressions now,
		-- but we'll be back! ...again!
		local end_prev_token: uinteger = vm.prev_token
		local end_index: uinteger = vm.prev_src_index
		local end_line: uinteger = vm.line - 1

		vm.prev_token = step_prev_token
		vm.src_index = step_index
		vm.prev_line = 0
		vm.line = step_line
		
		-- ok, we're back
		-- we need to generate the step expressions now
		local has_step: boolean

		try!(next())
		if vm.token ~= ')'_u8 then
			vm:setLoopStep(vm.bytecode_len)
		end
		while vm.token ~= ')'_u8 do
			try!(expression(Token.ASSIGN))
			
			if vm.token == ','_u8 then
				try!(match(','_u8))
			end
		end

		try!(match(')'_u8))

		-- time to wrap up the loop with a jump
		vm:emitOp(Opcode.JUMP)
		vm:emit24(a)

		vm:setLoopEnd(vm.bytecode_len)
		
		if has_condition then
			vm.bytecode[b] = ((vm.bytecode_len & 0xFF0000) >> 16)
			vm.bytecode[b + 1] = ((vm.bytecode_len & 0xFF00) >> 8)
			vm.bytecode[b + 2] = ((vm.bytecode_len) & 0xFF)
		end

		vm:popLoop()

		-- and now we can jump back to the end of the loop body
		vm.prev_token = end_prev_token
		vm.prev_line = 0
		vm.line = end_line
		vm.src_index = end_index
		
		try!(next())

		-- cleanup any loop init variables allocated
		local size: uinteger = vm:getScopeLocalsSize()
		if size > 0 then
			-- patch new_l size
			if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
				compileError!(string.format("line %d:\nloop local variable allocation limit exceeded by %d word(s)", for_line, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1)))
			end

			vm.bytecode[new_l_index] = ((size) >> 8)
			vm.bytecode[new_l_index + 1] = ((size) & 0xFF)
			
			-- cleanup
			vm:emitOp(Opcode.DEL_L)
			vm:emit16(size)
			
			vm.local_index = vm.local_index - size
		end
		
		vm:popScope()
	elseif vm.token == Token.WHILE then
		--[[
			ERA-C:         | BYTECODE:
			---------------+-------------
			a:             | a:
			while (<cond>) | <cond>
			               | JMP_Z b
			  <statement>  | <statement>
			               | JUMP a
			b:             | b:
			-----------------------------
		]]

		try!(match(Token.WHILE))

		a = vm.bytecode_len

		vm:pushLoop(vm.bytecode_len)

		try!(match('('_u8))

		try!(expression(Token.ASSIGN))

		if vm.expr_type.type_id == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot use expression of type `void` as loop condition", vm.line))
		end

		if vm.expr_type.type_id == EVMType.INT then
			vm:emitOp(Opcode.JUMP_Z)

			b = vm.bytecode_len
		
			vm:emit24(0)
		elseif vm.expr_type.type_id >= EVMType.POINTER then
			vm:emitOp(Opcode.JUMP_NULL)

			b = vm.bytecode_len
		
			vm:emit24(0)
		elseif vm.expr_type.type_id == EVMType.FUNC_POINTER then
			vm:emitOp(Opcode.JUMP_FPNULL)

			b = vm.bytecode_len
		
			vm:emit24(0)
		else
			compileError!(string.format(
				"line %d:\ninvalid type for loop condition. expected `int` or pointer, got `%s`",
				vm.line,
				getTypeName(vm.expr_type)
			))
		end
		
		try!(match(')'_u8))

		try!(statement())

		vm:emitOp(Opcode.JUMP)
		vm:emit24(a)

		vm:setLoopEnd(vm.bytecode_len)

		vm.bytecode[b] = ((vm.bytecode_len & 0xFF0000) >> 16)
		vm.bytecode[b + 1] = ((vm.bytecode_len & 0xFF00) >> 8)
		vm.bytecode[b + 2] = ((vm.bytecode_len) & 0xFF)

		vm:popLoop()
	elseif vm.token == Token.RETURN then
		try!(match(Token.RETURN))

		if vm.token ~= ';'_u8 then
			if vm.current_func_id.type_info.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot return a value from function of type `void`", vm.line))
			end

			try!(expression(Token.ASSIGN))
			
			local target_info: TypeInfo = vm.current_func_id.type_info

			if vm.expr_type.type_id == EVMType.VOID then
				compileError!(string.format("line %d:\ncannot return expression of type `void`", vm.line))
			elseif target_info.type_id ~= vm.expr_type.type_id then
				-- can we convert types?
				local can_convert: boolean = false
				
				if target_info.type_id == EVMType.INT and vm.expr_type.type_id == EVMType.FLOAT then
					can_convert = true
					vm:emitOp(Opcode.FTOI)
				elseif target_info.type_id == EVMType.INT and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif target_info.type_id == EVMType.FLOAT and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
					vm:emitOp(Opcode.ITOF)
				elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.INT then
					can_convert = true
				elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = true
				elseif target_info.type_id == EVMType.FUNC_POINTER and vm.expr_type.type_id >= EVMType.POINTER then
					can_convert = (vm.expr_type.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
				elseif target_info.type_id >= EVMType.POINTER and vm.expr_type.type_id == EVMType.FUNC_POINTER then
					can_convert = (target_info.type_id & (EVMType.POINTER - 1) == EVMType.VOID)
				end
				
				if not can_convert then
					compileError!(string.format(
						"line %d:\ncannot return `%s` from function of type `%s`",
						vm.line,
						getTypeName(vm.expr_type),
						getTypeName(target_info)
					))
				end
			elseif target_info.type_id == EVMType.STRUCT then
				if target_info.structref ~= vm.expr_type.structref then
					compileError!(string.format("line %d:\ncannot return `%s` from function of type `%s`", vm.line, vm.expr_type.structref.name, target_info.structref.name))
				end
			elseif target_info.type_id == EVMType.FUNC_POINTER then
				if not matchFuncPointerTypes(target_info.fptr_info, vm.expr_type.fptr_info) then
					compileError!(string.format(
						"line %d:\ncannot return `%s` from function of type `%s`",
						vm.line,
						getTypeName(vm.expr_type),
						getTypeName(target_info)
					))
				end
			end
		elseif vm.current_func_id.type_info.type_id ~= EVMType.VOID then
			compileError!(string.format(
				"line %d:\nfunction of type `%s` must return a value",
				vm.line,
				getTypeName(vm.current_func_id.type_info)
			))
		end

		try!(match(';'_u8))

		vm:emitOp(Opcode.RETURN)
	elseif vm.token == Token.BREAK then
		try!(match(Token.BREAK))

		if #vm.loop_info_stack == 0 then
			compileError!(string.format("line %d:\nbreak statement is not in a loop", vm.line))
		end

		vm:emitOp(Opcode.DEL_L)
		vm:addDelL(vm.bytecode_len)
		vm:emit16(0)
		
		vm:emitOp(Opcode.JUMP)
		vm:addBreak(vm.bytecode_len)
		vm:emit24(0)
		
		try!(match(';'_u8))
	elseif vm.token == Token.CONTINUE then
		try!(match(Token.CONTINUE))

		if #vm.loop_info_stack == 0 then
			compileError!(string.format("line %d:\ncontinue statement is not in a loop", vm.line))
		end

		vm:emitOp(Opcode.DEL_L)
		vm:addDelL(vm.bytecode_len)
		vm:emit16(0)
		
		vm:emitOp(Opcode.JUMP)

		if vm:loopHasStep() then
			vm:addJumpToStep(vm.bytecode_len)
			vm:emit24(0)
		else
			vm:emit24(vm:getLoopStart())
		end

		try!(match(';'_u8))
	elseif vm.token == '{'_u8 then
		local scope_line: uinteger = vm.line

		try!(match('{'_u8))

		vm:pushScope()

		vm:emitOp(Opcode.NEW_L)
		local new_l_index: uinteger = vm.bytecode_len
		vm:emit16(0)
		
		while vm.token ~= '}'_u8 do
			try!(statement())
		end

		try!(match('}'_u8))

		-- cleanup any local variables allocated
		local size: uinteger = vm:getScopeLocalsSize()
		vm.prev_scope_size = size
		
		-- patch new_l size
		if size > 0 then
			if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
				compileError!(string.format("line %d:\nscope local variable allocation limit exceeded by %d word(s)", scope_line, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1)))
			end

			vm.bytecode[new_l_index] = ((size) >> 8)
			vm.bytecode[new_l_index + 1] = ((size) & 0xFF)

			-- cleanup
			vm:emitOp(Opcode.DEL_L)
			vm:emit16(size)

			vm.local_index = vm.local_index - size
		end
		
		vm:popScope()
	elseif vm.token == ';'_u8 then
		-- empty statement
		try!(match(';'_u8))
	else
		-- TODO: don't allow expressions that will leave an unused value on the opstack
		try!(expression(Token.ASSIGN))
		try!(match(';'_u8))
	end
end

local function enumDeclaration(): void
	local i: int32
	while vm.token ~= '}'_u8 do
		if vm.token ~= Token.ID then
			compileError!(string.format(
				"line %d:\nbad enum identifier", vm.line
			))
		end
		try!(next())

		if vm.token == Token.ASSIGN then
			try!(next())
			if vm.token ~= Token.INT_LITERAL then
				compileError!(string.format("line %d:\nbad enum value", vm.line))
			end
			i = vm.token_val
			try!(next())
		end

		vm.current_id.class = Class.CONSTANT
		vm.current_id.type_info = {EVMType.INT}
		vm.current_id.const_val = i
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)
		i = i + 1

		if vm.token == ','_u8 then
			try!(next())
		end
	end
end

local function functionParameters(hook_index: integer): void
	local arg_type: uinteger
	local arg_index: uinteger

	while vm.token ~= ')'_u8 do
		local structref: *Struct = nilptr
		local fptr_info: *FuncPointerInfo = nilptr
		arg_type = EVMType.INT
		
		if vm.token == Token.VOID then
			try!(match(Token.VOID))
			arg_type = EVMType.VOID
		elseif vm.token == Token.INT then
			try!(match(Token.INT))
			arg_type = EVMType.INT
		elseif vm.token == Token.FLOAT then
			try!(match(Token.FLOAT))
			arg_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			structref = vm.struct_vec2
			try!(match(Token.VEC2))
			arg_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			structref = vm.struct_vec3
			try!(match(Token.VEC3))
			arg_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			structref = vm.current_id.type_info.structref
			try!(match(Token.STRUCT_ID))
			arg_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			structref = vm.struct_string
			try!(match(Token.STRING))
			arg_type = EVMType.STRING
		elseif vm.token == Token.VARARGS then
			try!(match(Token.VARARGS))
			vm.current_func_id.is_varargs = true
			vm.current_func_id.varargs_index = arg_index
			break
		else
			compileError!(string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			arg_type = arg_type + EVMType.POINTER
		end

		-- check for function pointer syntax
		if vm.token == '('_u8 then
			try!(match('('_u8))
			try!((
				do
					fptr_info = functionPointerType(structref, arg_type, false)
				end
			))
			structref = nilptr
			arg_type = EVMType.FUNC_POINTER
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			arg_type = arg_type + EVMType.POINTER
		end

		if arg_type == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot declare function parameter of type `void`", vm.line))
		end
		if vm.token ~= Token.ID then
			compileError!(string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end
		if vm.has_id then
			compileError!(string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name))
		end

		try!(match(Token.ID))

		vm.current_id.class = Class.ARG
		vm.current_id.type_info = {arg_type, structref, fptr_info}
		vm.current_id.index = arg_index
		vm:addScopedSymbol(vm.current_id.name, vm.current_id)
		
		if structref and not structref.is_complete then
			compileError!(string.format("line %d:\ncannot declare function parameter of incomplete type", vm.line))
		end

		arg_index = arg_index + sizeOfType(vm.current_id.type_info)

		vm.current_func_id.argdata:push(vm.current_id.type_info)

		if vm.token == ','_u8 then
			try!(match(','_u8))
		end
	end

	if hook_index ~= -1 then
		if hook_index == Hook.UPDATE then
			if #vm.current_func_id.argdata ~= 1 or vm.current_func_id.is_varargs then
				compileError!(string.format("line %d:\ninvalid signature for hook function `update`, expected `void update(float)`", vm.line))
			elseif vm.current_func_id.argdata[1].type_id ~= EVMType.FLOAT or vm.current_func_id.is_varargs then
				compileError!(string.format("line %d:\ninvalid signature for hook function `update`, expected `void update(float)`", vm.line))
			end
		else
			if #vm.current_func_id.argdata ~= 0 or vm.current_func_id.is_varargs then
				compileError!(string.format("line %d:\ninvalid signature for hook function `%s`, expected `void %s()`", vm.line, vm.current_func_id.name, vm.current_func_id.name))
			end
		end
	end
end

local function functionBody(): void
	vm.local_index = 0
	while vm.token ~= '}'_u8 do
		try!(statement())
	end

	--if vm.prev_opcode ~= Opcode.RETURN then
	vm:emitOp(Opcode.RETURN)
end

local function functionDeclaration(hook_index: integer): void
	vm:pushScope() -- function scope
	try!(match('('_u8))
	try!(functionParameters(hook_index))
	try!(match(')'_u8))
	try!(match('{'_u8))

	if vm.current_func_id.is_varargs then
		-- establish starting point for vararg pointer and set vargs flag
		vm:emitOp(Opcode.VARGP)
		vm:emit16(vm.current_func_id.varargs_index)
	end
	
	vm:emitOp(Opcode.NEW_L)
	local new_l_index: uinteger = vm.bytecode_len
	vm:emit16(0)
	
	try!(functionBody())
	try!(match('}'_u8))
	
	-- patch new_l size
	local size: uinteger = vm:getScopeLocalsSize()
	if size > 0 then
		if size > MEMORY_LOCALS_SIZE_ELEMENTS - 1 then
			compileError!(string.format("function `%s` local variable allocation limit exceeded by %d word(s)", vm.current_func_id.name, size - (MEMORY_LOCALS_SIZE_ELEMENTS - 1)))
		end

		vm.bytecode[new_l_index] = ((size) >> 8)
		vm.bytecode[new_l_index + 1] = ((size) & 0xFF)
	end

	vm:popScope()
end

local function structDeclaration(): void
	local struct_id: *Identifier
	local struct: *Struct = new(@Struct)
	local member: *Identifier
	local member_type: uinteger
	local member_index: uinteger
	local member_structref: *Struct
	local member_fptr_info: *FuncPointerInfo = nilptr
	local base_type: uinteger

	struct.is_complete = false
	
	try!(match(Token.STRUCT))

	if vm.token ~= Token.ID then
		compileError!(string.format(
			"line %d:\nexpected token `identifier`, got `%s`",
			vm.line,
			getTokenString(vm.token)
		))
	end
	if vm.has_id then
		compileError!(string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name))
	end

	struct.name = vm.current_id.name
	struct_id = vm.current_id
	struct_id.token = Token.STRUCT_ID
	struct_id.class = Class.STRUCT
	struct_id.type_info = {EVMType.STRUCT, struct}
	vm.struct_ids[struct_id.name] = struct_id

	try!(match(Token.ID))
	try!(match('{'_u8))

	while vm.token ~= '}'_u8 do
		member_structref = nilptr
		base_type = EVMType.INT
		
		if vm.token == Token.VOID then
			try!(match(Token.VOID))
			base_type = EVMType.VOID
		elseif vm.token == Token.INT then
			try!(match(Token.INT))
		elseif vm.token == Token.FLOAT then
			try!(match(Token.FLOAT))
			base_type = EVMType.FLOAT
		elseif vm.token == Token.VEC2 then
			member_structref = vm.struct_vec2
			try!(match(Token.VEC2))
			base_type = EVMType.VEC2
		elseif vm.token == Token.VEC3 then
			member_structref = vm.struct_vec3
			try!(match(Token.VEC3))
			base_type = EVMType.VEC3
		elseif vm.token == Token.STRUCT_ID then
			member_structref = vm.current_id.type_info.structref
			try!(match(Token.STRUCT_ID))
			base_type = EVMType.STRUCT
		elseif vm.token == Token.STRING then
			member_structref = vm.struct_string
			try!(match(Token.STRING))
			base_type = EVMType.STRING
		else
			compileError!(string.format(
				"line %d:\nexpected type identifier, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end

		member_type = base_type

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			member_type = member_type + EVMType.POINTER
		end

		-- check for function pointer syntax
		if vm.token == '('_u8 then
			try!(match('('_u8))
			try!((
				do
					member_fptr_info = functionPointerType(member_structref, member_type, true)
				end
			))
			member_structref = nilptr
			member_type = EVMType.FUNC_POINTER
		end

		while vm.token == Token.MUL do
			try!(match(Token.MUL))
			member_type = member_type + EVMType.POINTER
		end

		if member_type == EVMType.VOID then
			compileError!(string.format("line %d:\ncannot declare struct member of type `void`", vm.line))
		end

		if vm.token ~= Token.ID then
			compileError!(string.format(
				"line %d:\nexpected token `identifier`, got `%s`",
				vm.line,
				getTokenString(vm.token)
			))
		end

		vm.has_id = struct:hasMember(vm.current_id_name)
		if vm.has_id then
			compileError!(string.format("line %d:\nduplicate declaration of struct member `%s`", vm.line, vm.current_id_name))
		end

		try!(match(Token.ID))
		member = new(@Identifier)
		member.name = vm.current_id_name
		member.type_info = {member_type, member_structref, member_fptr_info}
		member.index = member_index

		if member_structref and (member_type < EVMType.POINTER) and (not member_structref.is_complete) then
			compileError!(string.format("line %d:\ncannot declare struct member of incomplete type", vm.line))
		end
		
		member_index = member_index + sizeOfType(member.type_info)
		
		struct:addMember(member)
		
		try!(match(';'_u8))
	end

	struct.is_complete = true

	try!(match('}'_u8))
end

local function globalDeclaration(): void
	local base_type: uinteger
	local var_type: uinteger
	local temp: uinteger
	local structref: *Struct = nilptr
	local fptr_info: *FuncPointerInfo = nilptr

	base_type = EVMType.INT

	if vm.token == Token.ENUM then
		try!(match(Token.ENUM))
		try!(match('{'_u8))
		try!(enumDeclaration())
		try!(match('}'_u8))
		try!(match(';'_u8))
		return
	elseif vm.token == Token.STRUCT then
		try!(structDeclaration())
		try!(match(';'_u8))
		return
	end

	if vm.token == Token.VOID then
		try!(match(Token.VOID))
		base_type = EVMType.VOID
	elseif vm.token == Token.INT then
		try!(match(Token.INT))
		base_type = EVMType.INT
	elseif vm.token == Token.FLOAT then
		try!(match(Token.FLOAT))
		base_type = EVMType.FLOAT
	elseif vm.token == Token.VEC2 then
		structref = vm.struct_vec2
		try!(match(Token.VEC2))
		base_type = EVMType.VEC2
	elseif vm.token == Token.VEC3 then
		structref = vm.struct_vec3
		try!(match(Token.VEC3))
		base_type = EVMType.VEC3
	elseif vm.token == Token.STRUCT_ID then
		structref = vm.current_id.type_info.structref
		try!(match(Token.STRUCT_ID))
		base_type = EVMType.STRUCT
	elseif vm.token == Token.STRING then
		structref = vm.struct_string
		try!(match(Token.STRING))
		base_type = EVMType.STRING
	else
		compileError!(string.format(
			"line %d:\nexpected type identifier, got `%s`",
			vm.line,
			getTokenString(vm.token)
		))
	end
	
	var_type = base_type
	
	while vm.token == Token.MUL do
		try!(match(Token.MUL))
		var_type = var_type + EVMType.POINTER
	end

	-- check for function pointer syntax
	if vm.token == '('_u8 then
		try!(match('('_u8))
		try!((
			do
				fptr_info = functionPointerType(structref, var_type, false)
			end
		))
		structref = nilptr
		var_type = EVMType.FUNC_POINTER
	end

	while vm.token == Token.MUL do
		try!(match(Token.MUL))
		var_type = var_type + EVMType.POINTER
	end

	if vm.token ~= Token.ID then
		compileError!(string.format(
			"line %d:\nexpected token `identifier`, got `%s`",
			vm.line,
			getTokenString(vm.token)
		))
	end
	if vm.has_id then
		compileError!(string.format("line %d:\nduplicate declaration of symbol `%s`", vm.line, vm.current_id.name))
	end

	try!(match(Token.ID))
	vm.current_id.type_info = {var_type, structref, fptr_info}
	vm:addScopedSymbol(vm.current_id.name, vm.current_id)

	if vm.token == '('_u8 then
		vm.current_id.class = Class.FUNCTION
		vm.current_id.index = vm.bytecode_len -- address of function
		vm.funcmap[(@uint32)(vm.bytecode_len)] = true -- add function address to funcmap

		if structref and not structref.is_complete then
			compileError!(string.format("line %d:\ncannot declare function with incomplete return type", vm.line))
		end

		-- register hooks
		local hook_index: integer = -1
		if vm.current_id.name == "init" then
			hook_index = Hook.INIT
		elseif vm.current_id.name == "update" then
			hook_index = Hook.UPDATE
		elseif vm.current_id.name == "draw" then
			hook_index = Hook.DRAW
		end

		if hook_index ~= -1 then
			vm.hook_flags[hook_index] = true
			vm.hook_addresses[hook_index] = vm.current_id.index

			if var_type ~= EVMType.VOID then
				compileError!(string.format("line %d:\nhook function `%s` must have a return type of `void`", vm.line, vm.current_id.name))
			end
		end

		vm.current_func_id = vm.current_id
		try!(functionDeclaration(hook_index))
	else
		if var_type ~= EVMType.VOID then
			vm.current_id.class = Class.GLOBAL
			vm.current_id.index = vm.globals_len

			if structref and not structref.is_complete then
				compileError!(string.format("line %d:\ncannot declare variable of incomplete type", vm.line))
			end

			local type_size: uinteger = sizeOfType(vm.current_id.type_info)

			if vm.token == Token.BRAK then
				vm.current_id.is_array = true
				vm.current_id.type_info.type_id = vm.current_id.type_info.type_id + EVMType.POINTER

				try!(match(Token.BRAK))
				
				local array_size: uinteger

				if vm.token == Token.INT_LITERAL then
					array_size = vm.token_val
					try!(match(Token.INT_LITERAL))
				elseif vm.token == Token.ID then
					if not vm.has_id then
						compileError!(string.format("line %d:\nundefined identifier `%s`", vm.line, vm.current_id.name))
					elseif vm.current_id.class ~= Class.CONSTANT then
						compileError!(string.format("line %d:\nidentifier `%s` used in array declaration is not constant", vm.line, vm.current_id.name))
					end

					array_size = vm.current_id.const_val
					
					try!(match(Token.ID))
				else
					compileError!(string.format(
						"line %d:\nexpected tokens `int literal` or `constant identifier`, got `%s`",
						vm.line,
						getTokenString(vm.token)
					))
				end

				if array_size == 0 then
					compileError!(string.format("line %d:\ncannot declare array of length 0", vm.line))
				end

				array_size = array_size * type_size

				vm.globals_len = vm.globals_len + array_size

				try!(match(']'_u8))
			else
				vm.globals_len = vm.globals_len + type_size
			end

			if vm.globals_len > MEMORY_GLOBALS_SIZE_ELEMENTS then
				compileError!(string.format("line %d:\nglobal variable storage limit exceeded by %d word(s)", vm.line, vm.globals_len - MEMORY_GLOBALS_SIZE_ELEMENTS))
			end

			try!(match(';'_u8))
		else
			compileError!(string.format("line %d:\ncannot declare variable of type `void`", vm.line))
		end
	end
end

local function program(): void
	vm.rom_len = 0
	vm.bytecode_len = 0
	vm.globals_len = 0

	for i = 0, < Hook.COUNT do
		vm.hook_addresses[i] = 0
		vm.hook_flags[i] = false
	end

	vm.line = 1
	vm.src_index = 1
	vm.prev_src_index = 1
	vm:pushScope() -- global scope
	
	try!(next())
	while vm.token ~= 0 do
		try!(globalDeclaration())
	end

	vm:popScope()

	-- check if at least one hook function was declared
	local declared: boolean
	for i = 0, < Hook.COUNT do
		if vm.hook_flags[i] then
			declared = true
			break
		end
	end

	if not declared then
		compileError!(string.format("no hook functions defined\ndefine `void init()`, `void update(float delta_time)`, or `void draw()`"))
	end
end

function EVM:compile(): boolean
	compile_err = false

	self.funcmap:clear() -- funcmap is a special case and should remain populated until next compile
	program()
	self:resetCompiler()

	return not compile_err
end
