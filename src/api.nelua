require("definitions")
require("input")
require("gpu")
require("soundchip")
require("util")

function EVM:getArgI(i: uint16): int32 <forwarddecl> end
function EVM:getArgU(i: uint16): uint32 <forwarddecl> end
function EVM:getArgF(i: uint16): float32 <forwarddecl> end
function EVM:getArgV2(i: uint16): rl.vector2 <forwarddecl> end
function EVM:getArgV3(i: uint16): rl.vector3 <forwarddecl> end
function EVM:getArgStr(i: uint16): EVMString <forwarddecl> end
function EVM:getArgMat(i: uint16): rl.matrix <forwarddecl> end

function EVM:pushI(val: int32): void <forwarddecl> end
function EVM:pushU(val: uint32): void <forwarddecl> end
function EVM:pushF(val: float32): void <forwarddecl> end
function EVM:pushV2(val: rl.vector2): void <forwarddecl> end
function EVM:pushV3(val: rl.vector3): void <forwarddecl> end
function EVM:pushStr(val: EVMString): void <forwarddecl> end
function EVM:pushMat(val: rl.matrix): void <forwarddecl> end

function EVM:getMem8(addr: uint32): uint8 <forwarddecl> end
function EVM:setMem8(addr: uint32, val: uint8): boolean <forwarddecl> end
function EVM:getMem32(addr: uint32): uint32 <forwarddecl> end
function EVM:setMem32(addr: uint32, val: uint32): boolean <forwarddecl> end
function EVM:loadMemCard(new_id: string): boolean <forwarddecl> end

function EVM:getMemColPoint(addr: uint32, point: *ColPoint): boolean <forwarddecl> end
function EVM:getMemColAABB(addr: uint32, aabb: *ColAABB): boolean <forwarddecl> end
function EVM:getMemColSphere(addr: uint32, sphere: *ColSphere): boolean <forwarddecl> end
function EVM:getMemColCylinder(addr: uint32, cylinder: *ColCylinder): boolean <forwarddecl> end
function EVM:getMemColTriangle(addr: uint32, triangle: *ColTriangle): boolean <forwarddecl> end

function EVM:heapAlloc(size: uint32): uint32 <forwarddecl> end
function EVM:heapRealloc(size: uint32, ptr: uint32): uint32 <forwarddecl> end
function EVM:heapFree(ptr: uint32): void <forwarddecl> end

local CollisionFunction: type = @function(*EVM, uint32, uint32): (boolean, uint32)

-- COLLISION DETECTION FUNCTIONS:

--[[ TODO: rewrite this!
	local function apiCheckAABBPoint(vm: *EVM): boolean
	-- signature:
	-- int checkAABBPoint(box b, vec3 p);

	local b_position: rl.vector3 = vm:getArgV3(0)
	local b_width: float32 = vm:getArgF(3)
	local b_height: float32 = vm:getArgF(4)
	local b_depth: float32 = vm:getArgF(5)
	local p: rl.vector3 = vm:getArgV3(6)

	local half_width: float32 = b_width / 2
	local half_height: float32 = b_height / 2
	local half_depth: float32 = b_depth / 2
	local min_x: float32 = b_position.x - half_width
	local max_x: float32 = b_position.x + half_width
	local min_y: float32 = b_position.y - half_height 
	local max_y: float32 = b_position.y + half_height 
	local min_z: float32 = b_position.z - half_depth
	local max_z: float32 = b_position.z + half_depth

	if p.x < min_x or p.x > max_x or
		p.y < min_y or p.y > max_y or
		p.z < min_z or p.z > max_z then
		vm:pushI(0)
	else
		vm:pushI(1)
	end

	return true
end]]

local function checkPointPoint(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	local a: ColPoint
	local b: ColPoint
	if not vm:getMemColPoint(a_addr, &a) then return false, 0 end
	if not vm:getMemColPoint(b_addr, &b) then return false, 0 end

	if a.position.x == b.position.x and
		a.position.y == b.position.y and
		a.position.z == b.position.z then
		return true, 1
	else
		return true, 0
	end
end

local function checkPointAABB(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkPointSphere(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkPointCylinder(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkPointTriangle(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkAABBPoint(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkPointAABB(vm, b_addr, a_addr)
end

local function checkAABBAABB(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	local a: ColAABB
	local b: ColAABB
	if not vm:getMemColAABB(a_addr, &a) then return false, 0 end
	if not vm:getMemColAABB(b_addr, &b) then return false, 0 end

	local half_a_width: float32 = a.width / 2
	local half_a_height: float32 = a.height / 2
	local half_a_depth: float32 = a.depth / 2
	local min_a: rl.vector3 = {
		a.position.x - half_a_width,
		a.position.y - half_a_height,
		a.position.z - half_a_depth
	}
	local max_a: rl.vector3 = {
		a.position.x + half_a_width,
		a.position.y + half_a_height,
		a.position.z + half_a_depth
	}

	local half_b_width: float32 = b.width / 2
	local half_b_height: float32 = b.height / 2
	local half_b_depth: float32 = b.depth / 2
	local min_b: rl.vector3 = {
		b.position.x - half_b_width,
		b.position.y - half_b_height,
		b.position.z - half_b_depth
	}
	local max_b: rl.vector3 = {
		b.position.x + half_b_width,
		b.position.y + half_b_height,
		b.position.z + half_b_depth
	}

	if (min_a.x <= max_b.x) and
		(max_a.x >= min_b.x) and
		(min_a.y <= max_b.y) and
		(max_a.y >= min_b.y) and
		(min_a.z <= max_b.z) and
		(max_a.z >= min_b.z) then
		return true, 1
	else
		return true, 0
	end
end

local function checkAABBSphere(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkAABBCylinder(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkAABBTriangle(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkSpherePoint(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkPointSphere(vm, b_addr, a_addr)
end

local function checkSphereAABB(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkAABBSphere(vm, b_addr, a_addr)
end

local function checkSphereSphere(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkSphereCylinder(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkSphereTriangle(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkCylinderPoint(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkPointCylinder(vm, b_addr, a_addr)
end

local function checkCylinderAABB(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkAABBCylinder(vm, b_addr, a_addr)
end

local function checkCylinderSphere(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkSphereCylinder(vm, b_addr, a_addr)
end

local function checkCylinderCylinder(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkCylinderTriangle(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local function checkTrianglePoint(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkPointTriangle(vm, b_addr, a_addr)
end

local function checkTriangleAABB(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkAABBTriangle(vm, b_addr, a_addr)
end

local function checkTriangleSphere(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkSphereTriangle(vm, b_addr, a_addr)
end

local function checkTriangleCylinder(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return checkCylinderTriangle(vm, b_addr, a_addr)
end

local function checkTriangleTriangle(vm: *EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	-- TODO: implement
	return true, 0
end

local ColType = @enum {
	POINT = 0,
	AABB,
	SPHERE,
	CYLINDER,
	TRIANGLE,
	COUNT
}

local collision_type_names: []string = {
	"colpoint",
	"colaabb",
	"colsphere",
	"colcylinder",
	"coltriangle"
}

local collision_functions: [ColType.COUNT][ColType.COUNT]CollisionFunction = {
	-- point             AABB               sphere               cylinder               triangle
	{checkPointPoint   , checkPointAABB   , checkPointSphere   , checkPointCylinder   , checkPointTriangle},    -- point
	{checkAABBPoint    , checkAABBAABB    , checkAABBSphere    , checkAABBCylinder    , checkAABBTriangle},     -- AABB
	{checkSpherePoint  , checkSphereAABB  , checkSphereSphere  , checkSphereCylinder  , checkSphereTriangle},   -- sphere
	{checkCylinderPoint, checkCylinderAABB, checkCylinderSphere, checkCylinderCylinder, checkCylinderTriangle}, -- cylinder
	{checkTrianglePoint, checkTriangleAABB, checkTriangleSphere, checkTriangleCylinder, checkTriangleTriangle}, -- triangle
}

-- API HELPER FUNCTIONS:

-- getMem8() helper function for apiPrint2D()
local function getMem8(vm: *EVM, addr: uint32, c: *uint8): boolean
	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid byte read address 0x%08X", addr)
		return false
	end

	$c = vm:getMem8(addr)

	return true
end

-- getMem32() helper function for apiPrint2D()
local function getMem32(vm: *EVM, addr: uint32, v: *uint32): boolean
	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid word read address 0x%08X", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("misaligned word read address 0x%08X", addr)
		return false
	end

	$v = vm:getMem32(addr)

	return true
end

-- vargv() helper function.
-- gets vargv() for the *api* function
local function vargv(vm: *EVM, offset: uint32): uint32
	vm.cf.vargc = vm.cf.vargc - offset
	
	-- get adress vargp currently points to
	local addr: uint32 = MEMORY_ARGS_START_ADDR + (vm.cf.vargp * 4)

	-- offset vararg pointer
	vm.cf.vargp = vm.cf.vargp + offset

	return addr
end

local function v3Normalize(v: rl.vector3): rl.vector3
	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	return v
end

local function v3Cross(a: rl.vector3, b: rl.vector3): rl.vector3
	return {
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	}
end

-- API FUNCTIONS:

local function apiAlloc(vm: *EVM): boolean
	-- signature:
	-- void* alloc(int size);

	local size: uint32 = vm:getArgU(0)

	vm:pushU(vm:heapAlloc(size))

	return true
end

local function apiAmbientColor(vm: *EVM): boolean
	-- signature:
	-- void ambientColor(int color);

	local col: uint32 = vm:getArgU(0)

	vm.gpu:ambientColor(col)

	util.pokeU(&vm.gpu.render_state.ambient_color_r, col)

	return true
end

local function apiAmbientFactor(vm: *EVM): boolean
	-- signature:
	-- void ambientFactor(float factor);

	local factor: float32 = vm:getArgF(0)

	if factor < 0.0 or factor > 100.0 then
		vm.error = "attempt to set invalid ambient factor"
		return false
	end

	vm.gpu:ambientFactor(factor)

	util.pokeF(&vm.gpu.render_state.ambient_factor0, factor)

	return true
end

local function apiBeginMesh(vm: *EVM): boolean
	-- signature:
	-- void beginMesh(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("attempt to set invalid primitive mode `%d`", mode)
		return false
	end

	vm.gpu:beginMesh(mode)
	
	return true
end

local function apiBlendFactors(vm: *EVM): boolean
	-- signature:
	-- void blendFactors(int src, int dest, int eq);

	local src: uint32 = vm:getArgU(0)
	local dest: uint32 = vm:getArgU(1)
	local eq: uint32 = vm:getArgU(2)

	if src > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend source factor `%d`", src)
		return false
	end

	if dest > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend destination factor `%d`", dest)
		return false
	end

	if eq > GPU_MAX then
		vm.error = string.format("attempt to set invalid blend equation `%d`", eq)
		return false
	end

	vm.gpu:blendFactors(src, dest, eq)

	-- update render state
	vm.gpu.render_state.rgb_factors = (@uint8)((src << 4) | dest)
	vm.gpu.render_state.alpha_factors = (@uint8)((src << 4) | dest)
	vm.gpu.render_state.blend_equations = (@uint8)((eq << 4) | eq)

	return true
end

local function apiBlendFactorsEx(vm: *EVM): boolean
	-- signature:
	-- void blendFactorsEx(int src_rgb, int dest_rgb, int src_alpha, int dest_alpha, int eq_rgb, int eq_alpha);

	local src_rgb: uint32 = vm:getArgU(0)
	local dest_rgb: uint32 = vm:getArgU(1)
	local src_alpha: uint32 = vm:getArgU(2)
	local dest_alpha: uint32 = vm:getArgU(3)
	local eq_rgb: uint32 = vm:getArgU(4)
	local eq_alpha: uint32 = vm:getArgU(5)

	if src_rgb > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend source RGB factor `%d`", src_rgb)
		return false
	end

	if dest_rgb > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend destination RGB factor `%d`", dest_rgb)
		return false
	end

	if src_alpha > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend source alpha factor `%d`", src_alpha)
		return false
	end

	if dest_alpha > GPU_ONE_MINUS_CONSTANT_ALPHA then
		vm.error = string.format("attempt to set invalid blend destination alpha factor `%d`", dest_alpha)
		return false
	end

	if eq_rgb > GPU_MAX then
		vm.error = string.format("attempt to set invalid blend RGB equation `%d`", eq_rgb)
		return false
	end

	if eq_alpha > GPU_MAX then
		vm.error = string.format("attempt to set invalid blend alpha equation `%d`", eq_alpha)
		return false
	end

	vm.gpu:blendFactorsEx(src_rgb, dest_rgb, src_alpha, dest_alpha, eq_rgb, eq_alpha)

	-- update render state
	vm.gpu.render_state.rgb_factors = (@uint8)((src_rgb << 4) | dest_rgb)
	vm.gpu.render_state.alpha_factors = (@uint8)((src_alpha << 4) | dest_alpha)
	vm.gpu.render_state.blend_equations = (@uint8)((eq_rgb << 4) | eq_alpha)

	return true
end

local function apiBlendMode(vm: *EVM): boolean
	-- signature:
	-- void blendMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > rl.blendMode.CUSTOM_SEPARATE then
		vm.error = string.format("attempt to set invalid blend mode `%d`", mode)
		return false
	end

	vm.gpu:blendMode(mode)

	vm.gpu.render_state.flags_00sttbbb = (vm.gpu.render_state.flags_00sttbbb & ~GPU_BLEND_MODE_MASK) | mode

	return true
end

local function apiCam3DForward(vm: *EVM): boolean
	-- signature:
	-- vec3 cam3DForward(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: *EVMCam3D = &vm.gpu.cameras3D[id]

	local v: rl.vector3 = v3Normalize({
		util.peekF(&cam.target_x0) - util.peekF(&cam.position_x0),
		util.peekF(&cam.target_y0) - util.peekF(&cam.position_y0),
		util.peekF(&cam.target_z0) - util.peekF(&cam.position_z0)})

	vm:pushV3(v)

	return true
end

local function apiCam3DRight(vm: *EVM): boolean
	-- signature:
	-- vec3 cam3DRight(int id);

	-- get camera
	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: *EVMCam3D = &vm.gpu.cameras3D[id]

	-- calculate forward vector
	local forward: rl.vector3 = v3Normalize({
		util.peekF(&cam.target_x0) - util.peekF(&cam.position_x0),
		util.peekF(&cam.target_y0) - util.peekF(&cam.position_y0),
		util.peekF(&cam.target_z0) - util.peekF(&cam.position_z0)})

	-- get normalized up vector
    local up: rl.vector3 = v3Normalize({
		util.peekF(&cam.up_x0),
		util.peekF(&cam.up_y0),
		util.peekF(&cam.up_z0)})

	-- calculate cross of forward and up
	vm:pushV3({
		(forward.y * up.z) - (forward.z * up.y),
		(forward.z * up.x) - (forward.x * up.z),
		(forward.x * up.y) - (forward.y * up.x)})

	return true
end

local function apiCamera2D(vm: *EVM): boolean
	-- signature:
	-- void camera2D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera2D(id)

	vm.gpu.render_state.flags_tmccs0fl = (vm.gpu.render_state.flags_tmccs0fl & ~GPU_DEPTH_TEST_BIT)

	return true
end

local function apiCamera3D(vm: *EVM): boolean
	-- signature:
	-- void camera3D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera3D(id)

	vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl | GPU_DEPTH_TEST_BIT

	return true
end

local function apiCeil(vm: *EVM): boolean
	-- signature:
	-- float ceil(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.ceil(v))

	return true
end

local function apiClear(vm: *EVM): boolean
	-- signature:
	-- void clear(int flags);

	local flags: uint32 = vm:getArgU(0)

	vm.gpu:clear(flags)

	return true
end

local function apiClearColor(vm: *EVM): boolean
	-- signature:
	-- void clearColor(int col);

	local col: uint32 = vm:getArgU(0)

	vm.gpu:clearColor(col)

	util.pokeU(&vm.gpu.render_state.clear_color_r, col)

	return true
end

local function apiClearDepth(vm: *EVM): boolean
	-- signature:
	-- void clearDepth(float depth);

	local depth: uint32 = vm:getArgF(0)

	vm.gpu:clearDepth(depth)

	util.pokeF(&vm.gpu.render_state.clear_depth0, depth)

	return true
end

local function apiClearStencil(vm: *EVM): boolean
	-- signature:
	-- void clearStencil(int stencil);

	local stencil: int32 = vm:getArgI(0)

	vm.gpu:clearStencil(stencil)

	vm.gpu.render_state.clear_stencil = (@uint8)(stencil & 0xFF)

	return true
end

local function apiCollide(vm: *EVM): boolean
	-- signature:
	-- int collide(void* a, void* b);

	local a_addr: uint32 = vm:getArgU(0)
	local b_addr: uint32 = vm:getArgU(1)
	local a_type: uint32
	local b_type: uint32

	if not getMem32(vm, a_addr, &a_type) then
		return false
	end

	if not getMem32(vm, b_addr, &b_type) then
		return false
	end

	if a_type >= ColType.COUNT or b_type >= ColType.COUNT then
		vm.error = "attempt to call collide() on invalid collision shape type(s)"
		return false
	end

	local cfunc: CollisionFunction = collision_functions[a_type][b_type]
	if cfunc == nilptr then
		vm.error = string.format(
			"no collision function for types `%s` and `%s`",
			collision_type_names[a_type],
			collision_type_names[b_type]
		)
		return false
	end

	local success: boolean
	local collision: int32
	success, collision = cfunc(vm, a_addr, b_addr)

	if success then
		vm:pushI(collision)
		return true
	else
		return false
	end
end

local function apiColorMask(vm: *EVM): boolean
	-- signature:
	-- void colorMask(int mask);

	local mask: uint8 = (@uint8)(vm:getArgU(0) & GPU_COLOR_MASK_ALL)

	vm.gpu:colorMask(mask)

	vm.gpu.render_state.flags_00ppcccc = (vm.gpu.render_state.flags_00ppcccc & ~GPU_COLOR_MASK_MASK) | mask

	return true
end

local function apiCos(vm: *EVM): boolean
	-- signature:
	-- float cos(float x);
	
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.cos(v))

	return true
end

local function apiCullMode(vm: *EVM): boolean
	-- signature:
	-- void cullMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("attempt to set invalid cull mode `%d`", mode)
		return false
	end

	vm.gpu:cullMode(mode)

	vm.gpu.render_state.flags_tmccs0fl = (vm.gpu.render_state.flags_tmccs0fl & ~GPU_CULL_MODE_MASK) | (@uint8)(mode << 4)

	return true
end

local function apiDeg(vm: *EVM): boolean
	-- signature:
	-- float deg(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.deg(v))

	return true
end

local function apiDepthFunc(vm: *EVM): boolean
	-- signature:
	-- void depthFunc(int func);
	
	local func: uint32 = vm:getArgU(0)

	if func > GPU_NEVER then
		vm.error = string.format("attempt to set invalid depth function `%d`", func)
		return false
	end

	vm.gpu:depthFunc(func)

	vm.gpu.render_state.depth_function = (@uint8)(func)

	return true
end

local function apiDepthMask(vm: *EVM): boolean
	-- signature:
	-- void depthMask(int enable);
	
	local enable: uint32 = vm:getArgU(0)

	if enable ~= 0 then
		vm.gpu:depthMask(true)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl | GPU_DEPTH_MASK_BIT
	else
		vm.gpu:depthMask(false)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl & ~GPU_DEPTH_MASK_BIT
	end

	return true
end

local function apiDepthTest(vm: *EVM): boolean
	-- signature:
	-- void depthTest(int enable);
	
	local enable: uint32 = vm:getArgU(0)

	if enable ~= 0 then
		vm.gpu:depthTest(true)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl | GPU_DEPTH_TEST_BIT
	else
		vm.gpu:depthTest(false)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl & ~GPU_DEPTH_TEST_BIT
	end

	return true
end

local function apiDrawObj(vm: *EVM): boolean
	-- signature:
	-- void drawObj(int id);

	local id: uint32 = vm:getArgU(0)

	if id > 511 then
		vm.error = string.format("attempt to load invalid OBJMAP entry `%d`", id)
		return false
	end

	vm.gpu:drawObj(id)

	return true
end

local function apiDrawObjEx(vm: *EVM): boolean
	-- signature:
	-- void drawObjEx(int mode, int start, int n);

	local mode: uint32 = vm:getArgU(0)
	local start: uint32 = vm:getArgU(1)
	local n: uint32 = vm:getArgU(2)

	vm.gpu:drawObjEx(mode, start, n)

	return true
end

local function apiEndMesh(vm: *EVM): boolean
	-- signature:
	-- void endMesh();

	vm.gpu:endMesh()
	
	return true
end

local function apiFloor(vm: *EVM): boolean
	-- signature:
	-- float floor(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.floor(v))

	return true
end

local function apiFogColor(vm: *EVM): boolean
	-- signature:
	-- void fogColor(float color);

	local col: uint32 = vm:getArgU(0)
	
	vm.gpu:fogColor(col)

	util.pokeU(&vm.gpu.render_state.fog_color_r, col)

	return true
end

local function apiFogEnd(vm: *EVM): boolean
	-- signature:
	-- void fogEnd(float end);
	
	local fend: float32 = math.clamp(vm:getArgF(0), 0.0, 1000.0)
	
	vm.gpu:fogEnd(fend)

	util.pokeF(&vm.gpu.render_state.fog_end0, fend)

	return true
end

local function apiFogMode(vm: *EVM): boolean
	-- signature:
	-- void fogMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode ~= 0 then
		vm.gpu:fogMode(true)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl | GPU_FOG_BIT
	else
		vm.gpu:fogMode(false)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl & ~GPU_FOG_BIT
	end

	return true
end

local function apiFogStart(vm: *EVM): boolean
	-- signature:
	-- void fogStart(float start);

	local start: float32 = math.clamp(vm:getArgF(0), 0.0, 1000.0)
	
	vm.gpu:fogStart(start)

	util.pokeF(&vm.gpu.render_state.fog_start0, start)
	
	return true
end

local function apiFract(vm: *EVM): boolean
	-- signature:
	-- float fract(float x);

	local x: float32 = vm:getArgF(0)

	vm:pushF(math.fract(x))

	return true
end

local function apiFree(vm: *EVM): boolean
	-- signature:
	-- void free(void* block);

	local block: uint32 = vm:getArgU(0)

	vm:heapFree(block)

	return true
end

local function apiFrustum(vm: *EVM): boolean
	-- signature:
	-- void frustum(float left, float right, float bottom, float top, float near, float far);

	local left: float32 = vm:getArgF(0)
	local right: float32 = vm:getArgF(1)
	local bottom: float32 = vm:getArgF(2)
	local top: float32 = vm:getArgF(3)
	local near: float32 = vm:getArgF(4)
	local far: float32 = vm:getArgF(5)

	if left == right or top == bottom or near == far then
		vm.error = "invalid frustum parameters"
		return false
	end

	rlgl.frustum(left, right, bottom, top, near, far)

	return true
end

local function apiGetCam2D(vm: *EVM): boolean
	-- signature:
	-- cam2d* getCam2D(int index);

	local index: uint32 = vm:getArgU(0)

	vm:pushU(MEMORY_SYSMEM_START_ADDR + MEMORY_CAMERAS2D_INDEX + (index * (MEMORY_CAMERAS2D_SIZE /// GPU_CAMERAS_COUNT)))

	return true
end

local function apiGetCam3D(vm: *EVM): boolean
	-- signature:
	-- void getCam3D(int index);

	local index: uint32 = vm:getArgU(0)

	vm:pushU(MEMORY_SYSMEM_START_ADDR + MEMORY_CAMERAS3D_INDEX + (index * (MEMORY_CAMERAS3D_SIZE /// GPU_CAMERAS_COUNT)))

	return true
end

local function apiGetLight(vm: *EVM): boolean
	-- signature:
	-- void getLight(int index);

	local index: uint32 = vm:getArgU(0)

	vm:pushU(MEMORY_SYSMEM_START_ADDR + MEMORY_LIGHTS_INDEX + (index * (MEMORY_LIGHTS_SIZE /// GPU_LIGHTS_COUNT)))

	return true
end

local function apiGetModelViewMatrix(vm: *EVM): boolean
	-- signature:
	-- matrix getModelViewMatrix();

	vm:pushMat(rlgl.getMatrixModelview())

	return true
end

local function apiGetMouseDelta(vm: *EVM): boolean
	vm:pushV2({
		(@float32)(input.mouse_delta_x),
		(@float32)(input.mouse_delta_y)
	})
	
	return true
end

local function apiGetMouseDrag(vm: *EVM): boolean
	local b: uint32 = vm:getArgU(0)

	if b > 2 then
		b = 2
	end

	switch b do
		case 0 then
			vm:pushV2({
				(@float32)(input.left_drag_x),
				(@float32)(input.left_drag_y)
			})
		case 1 then
			vm:pushV2({
				(@float32)(input.right_drag_x),
				(@float32)(input.right_drag_y)
			})
		case 2 then
			vm:pushV2({
				(@float32)(input.middle_drag_x),
				(@float32)(input.middle_drag_y)
			})
	end

	return true
end

local function apiGetMouseLock(vm: *EVM): boolean
	vm:pushU(rl.isCursorHidden() and 1 or 0)

	return true
end

local function apiGetMousePosition(vm: *EVM): boolean
	vm:pushV2({
		(@float32)(input.mouse_x),
		(@float32)(input.mouse_y)
	})

	return true
end

local function apiGetMouseWheel(vm: *EVM): boolean
	vm:pushI(input.mouse_wheel_y)

	return true
end

local function apiGetProjectionMatrix(vm: *EVM): boolean
	-- signature:
	-- matrix getProjectionMatrix();

	vm:pushMat(rlgl.getMatrixProjection())

	return true
end

local function apiGetRaycastNormal(vm: *EVM): boolean
	-- signature:
	-- vec3 getRaycastNormal();

	vm:pushV3({0.0, 0.0, 0.0})

	return true
end

local function apiGetRaycastPoint(vm: *EVM): boolean
	-- signature:
	-- vec3 getRaycastPoint();

	vm:pushV3({0.0, 0.0, 0.0})

	return true
end

local function apiGetTopMatrix(vm: *EVM): boolean
	-- signature:
	-- matrix getTopMatrix();

	vm:pushMat(rlgl.getMatrixTransform())

	return true
end

local function apiGetTrackBPM(vm: *EVM): boolean
	-- signature:
	-- int getTrackBPM(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))

	vm:pushU(vm.soundchip:getTrackBPM(track))
	
	return true
end

local function apiGetTrackPan(vm: *EVM): boolean
	-- signature:
	-- int getTrackPan(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))

	vm:pushI(vm.soundchip:getTrackPan(track))
	
	return true
end

local function apiGetTrackVolume(vm: *EVM): boolean
	-- signature:
	-- int getTrackVolume(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))

	vm:pushU(vm.soundchip:getTrackVolume(track))
	
	return true
end

local function apiHeld(vm: *EVM): boolean
	-- signature:
	-- int held(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, input.PLAYER_COUNT - 1)
	b = (p * input.Button.COUNT) + b

	local code: cint = input.button_map[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyDown(code) and 1 or 0)
	end
	
	return true
end

local function apiIdentity(vm: *EVM): boolean
	-- signature:
	-- void identity();

	rlgl.loadIdentity()
	
	return true
end

local function apiInitMemCard(vm: *EVM): boolean
	-- signature:
	-- void initMemCard(string id);

	local buffer: [17]uint8
	local id_str: EVMString = vm:getArgStr(0)

	-- validate and copy id_str
	if (id_str.len == 0 or id_str.len > 16) or (id_str.data > MEMORY_MAX_ADDR) then
		vm.error = "invalid id string passed to initMemCard()"
		return false
	end

	for i: uint32 = 0, < id_str.len do
		local read_addr: uint32 = id_str.data + i
		if read_addr > MEMORY_MAX_ADDR then
			vm.error = string.format("invalid byte read address 0x%08X", read_addr)
			return false
		end

		local c: uint8 = vm:getMem8(read_addr)
		if (c >= 'a'_u8 and c <= 'z'_u8) or (c >= 'A'_u8 and c <= 'Z'_u8) or (c >= '0'_u8 and c <= '9'_u8) or c == '_'_u8 then
			buffer[i] = c
		else
			vm.error = "invalid id string passed to initMemCard()"
			return false
		end
	end
	buffer[id_str.len] = '\0'_u8
	local new_id: string = {&buffer[0], id_str.len}
	new_id = string.copy(new_id)

	return vm:loadMemCard(new_id)
end

local function apiLightingMode(vm: *EVM): boolean
	-- signature:
	-- void lightingMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	-- note: lightingMode() updates the GPU render state
	vm.gpu:lightingMode(mode ~= 0)

	return true
end

local function apiLoadObjBank(vm: *EVM): boolean
	-- signature:
	-- void loadObjBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 3 then
		vm.error = string.format("attempt to load invalid object bank `%d`", bank)
		return false
	end

	vm.gpu:loadObjBank(bank)

	return true
end

local function apiLoadSeqBank(vm: *EVM): boolean
	-- signature:
	-- void loadSeqBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 7 then
		vm.error = string.format("attempt to load invalid sequencer bank `%d`", bank)
		return false
	end

	vm.soundchip:loadSeqBank(bank)

	return true
end

local function apiLoadTexBank(vm: *EVM): boolean
	-- signature:
	-- void loadTexBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 3 then
		vm.error = string.format("attempt to load invalid texture bank `%d`", bank)
		return false
	end

	vm.gpu:loadTexBank(bank)

	return true
end

local function apiLoadWavBank(vm: *EVM): boolean
	-- signature:
	-- void loadWavBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 1 then
		vm.error = string.format("attempt to load invalid wave bank `%d`", bank)
		return false
	end

	vm.soundchip:loadWavBank(bank)

	return true
end

local function apiLookAt(vm: *EVM): boolean
	-- signature:
	-- void lookAt(vec3 eye, vec3 target, vec3 up);

	local eye: rl.vector3 = vm:getArgV3(0)
	local target: rl.vector3 = vm:getArgV3(3)
	local up: rl.vector3 = vm:getArgV3(6)

	local mat_view: rl.matrix = rl.matrix.lookAt(eye, target, up)
	local asfloat16: rl.float16 = rl.matrix.toFloatV(mat_view)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	return true
end

local function apiMatrixAdd(vm: *EVM): boolean
	-- signature:
	-- matrix matrixAdd(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.add(a, b))

	return true
end

local function apiMatrixIdentity(vm: *EVM): boolean
	-- signature:
	-- matrix matrixIdentity();

	vm:pushMat(rl.matrix.identity())

	return true
end

local function apiMatrixInvert(vm: *EVM): boolean
	-- signature:
	-- matrix matrixInvert(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	vm:pushMat(rl.matrix.invert(m))

	return true
end

local function apiMatrixLookAt(vm: *EVM): boolean
	-- signature:
	-- matrix matrixLookAt(vce3 eye, vec3 target, vec3 up);

	local eye: rl.vector3 = vm:getArgV3(0)
	local target: rl.vector3 = vm:getArgV3(3)
	local up: rl.vector3 = vm:getArgV3(6)

	vm:pushMat(rl.matrix.lookAt(eye, target, up))

	return true
end

local function apiMatrixMode(vm: *EVM): boolean
	-- signature:
	-- void matrixMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > GPU_MODELVIEW then
		vm.error = string.format("attempt to set invalid matrix mode `%d`", mode)
		return false
	end

	vm.gpu:matrixMode(mode)

	return true
end

local function apiMatrixMultiply(vm: *EVM): boolean
	-- signature:
	-- matrix matrixMultiply(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.multiply(a, b))

	return true
end

local function apiMatrixRotate(vm: *EVM): boolean
	-- signature:
	-- matrix matrixRotate(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	vm:pushMat(rl.matrix.multiply(rl.matrix.rotateZYX(v), m))

	return true
end

local function apiMatrixScale(vm: *EVM): boolean
	-- signature:
	-- matrix matrixScale(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	local sm: rl.matrix = {
		v.x, 0.0, 0.0, 0.0,
		0.0, v.y, 0.0, 0.0,
		0.0, 0.0, v.z, 0.0,
		0.0, 0.0, 0.0, 1.0
	}

	vm:pushMat(rl.matrix.multiply(sm, m))

	return true
end

local function apiMatrixSubtract(vm: *EVM): boolean
	-- signature:
	-- matrix matrixSubtract(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.subtract(a, b))

	return true
end

local function apiMatrixTranslate(vm: *EVM): boolean
	-- signature:
	-- matrix matrixTranslate(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	local tm: rl.matrix = {
		1.0, 0.0, 0.0, v.x,
		0.0, 1.0, 0.0, v.y,
		0.0, 0.0, 1.0, v.z,
		0.0, 0.0, 0.0, 1.0
	}

	vm:pushMat(rl.matrix.multiply(tm, m))

	return true
end

local function apiMatrixTranspose(vm: *EVM): boolean
	-- signature:
	-- matrix matrixTranspose(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	vm:pushMat(rl.matrix.transpose(m))

	return true
end

local function apiMaxf(vm: *EVM): boolean
	-- signature:
	-- float maxf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a > b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMaxi(vm: *EVM): boolean
	-- signature:
	-- int maxi(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMemcpy(vm: *EVM): boolean
	-- signature:
	-- void memcpy(void* src, void* dest, int nbytes);

	local src: uint32 = vm:getArgU(0)
	local dest: uint32 = vm:getArgU(1)
	local nbytes: uint32 = vm:getArgU(2)

	if src > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memcpy src address 0x%08X", src)
		return false
	end

	if src + (nbytes - 1) > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memcpy src end address 0x%08X", src + (nbytes - 1))
		return false
	end

	if dest > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memcpy dest address 0x%08X", dest)
		return false
	end

	if dest + (nbytes - 1) > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memcpy dest end address 0x%08X", dest + (nbytes - 1))
		return false
	end

	if src == dest then
		return true
	elseif src < dest then
		-- copy from the end
		src = src + (nbytes - 1)
		dest = dest + (nbytes - 1)

		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("cannot write byte to ROM address 0x%08X", dest)
				return false
			end

			src = src - 1
			dest = dest - 1
		end
	else
		-- copy from the beginning
		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("cannot write byte to ROM address 0x%08X", dest)
				return false
			end

			src = src + 1
			dest = dest + 1
		end
	end

	return true
end

local function apiMemset(vm: *EVM): boolean
	-- signature:
	-- void memset(void* dest, int nbytes, int value);

	local dest: uint32 = vm:getArgU(0)
	local nbytes: uint32 = vm:getArgU(1)
	local value: uint8 = vm:getArgU(2) & 0xFF

	if dest > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memset dest address 0x%08X", dest)
		return false
	end

	if dest + (nbytes - 1) > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid memset dest end address 0x%08X", dest + (nbytes - 1))
		return false
	end

	for i = 0, < nbytes do
		if not vm:setMem8(dest, value) then
			vm.error = string.format("cannot write byte to ROM address 0x%08X", dest)
			return false
		end

		dest = dest + 1
	end

	return true
end

local function apiMeshColor(vm: *EVM): boolean
	-- signature:
	-- void meshColor(int col);

	local col: uint32 = vm:getArgU(0)
	
	vm.gpu:vertColor(col)
	
	return true
end

local function apiMeshNormal(vm: *EVM): boolean
	-- signature:
	-- void meshNormal(vec3 normal);

	local v: rl.vector3 = vm:getArgV3(0)
	
	vm.gpu:vertNormal(v)
	
	return true
end

local function apiMeshUV(vm: *EVM): boolean
	-- signature:
	-- void meshUV(vec2 uv);

	local v: rl.vector2 = vm:getArgV2(0)
	
	vm.gpu:vertUV(v)
	
	return true
end

local function apiMeshVertex(vm: *EVM): boolean
	-- signature:
	-- void meshVertex(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	vm.gpu:vertex(v)
	
	return true
end

local function apiMeshVertex2D(vm: *EVM): boolean
	-- signature:
	-- void meshVertex2D(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm.gpu:vertex2D(v)
	
	return true
end

local function apiMidf(vm: *EVM): boolean
	-- signature:
	-- float midf(float a, float b, float c);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)
	local c: float32 = vm:getArgF(2)
	
	vm:pushF(util.midF(a, b, c))

	return true
end

local function apiMidi(vm: *EVM): boolean
	-- signature:
	-- int midi(int a, int b, int c);

	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	local c: int32 = vm:getArgI(2)
	
	vm:pushI(util.midI(a, b, c))

	return true
end

local function apiMinf(vm: *EVM): boolean
	-- signature:
	-- float minf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a < b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMini(vm: *EVM): boolean
	-- signature:
	-- int mini(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMouseDragging(vm: *EVM): boolean
	local b: uint32 = vm:getArgU(0)

	if b > 2 then
		b = 2
	end

	switch b do
		case 0 then
			vm:pushU(input.left_dragging and 1 or 0)
		case 1 then
			vm:pushU(input.right_dragging and 1 or 0)
		case 2 then
			vm:pushU(input.middle_dragging and 1 or 0)
	end

	return true
end

local function apiMouseHeld(vm: *EVM): boolean
	local b: uint32 = vm:getArgU(0)

	if b > 2 then
		b = 2
	end

	switch b do
		case 0 then
			vm:pushU(input.left_click_held and 1 or 0)
		case 1 then
			vm:pushU(input.right_click_held and 1 or 0)
		case 2 then
			vm:pushU(input.middle_click_held and 1 or 0)
	end

	return true
end

local function apiMousePressed(vm: *EVM): boolean
	local b: uint32 = vm:getArgU(0)

	if b > 2 then
		b = 2
	end

	switch b do
		case 0 then
			vm:pushU(input.left_clicked and 1 or 0)
		case 1 then
			vm:pushU(input.right_clicked and 1 or 0)
		case 2 then
			vm:pushU(input.middle_clicked and 1 or 0)
	end

	return true
end

local function apiMouseReleased(vm: *EVM): boolean
	local b: uint32 = vm:getArgU(0)

	if b > 2 then
		b = 2
	end

	switch b do
		case 0 then
			vm:pushU(input.left_click_released and 1 or 0)
		case 1 then
			vm:pushU(input.right_click_released and 1 or 0)
		case 2 then
			vm:pushU(input.middle_click_released and 1 or 0)
	end

	return true
end

local function apiMultiplyTopMatrix(vm: *EVM): boolean
	-- signature:
	-- void multiplyTopMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	local asfloat16: rl.float16 = rl.matrix.toFloatV(m)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	return true
end

local function apiMuteTrack(vm: *EVM): boolean
	-- signature:
	-- void muteTrack(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	
	vm.soundchip:muteTrack(track)

	return true
end

local function apiMuteTracks(vm: *EVM): boolean
	-- signature:
	-- void muteTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:muteTrack(i)
		end
	end

	return true
end

local function apiOrtho(vm: *EVM): boolean
	-- signature:
	-- void ortho(float left, float right, float bottom, float top, float near, float far);
	
	local left: float32 = vm:getArgF(0)
	local right: float32 = vm:getArgF(1)
	local bottom: float32 = vm:getArgF(2)
	local top: float32 = vm:getArgF(3)
	local near: float32 = vm:getArgF(4)
	local far: float32 = vm:getArgF(5)

	if left == right or top == bottom or near == far then
		vm.error = "invalid ortho parameters"
		return false
	end

	rlgl.ortho(left, right, bottom, top, near, far)

	return true
end

local function apiPauseTrack(vm: *EVM): boolean
	-- signature:
	-- void pauseTrack(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local mask: uint8 = 0x80 >> track

	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags & ~mask

	return true
end

local function apiPauseTracks(vm: *EVM): boolean
	-- signature:
	-- void pauseTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags & ~((@uint8)(mask))

	return true
end

local function apiPeek32(vm: *EVM): boolean
	-- signature:
	-- int peek32(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid word read address 0x%08X", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("misaligned word read address 0x%08X", addr)
		return false
	end

	vm:pushU(vm:getMem32(addr))

	return true
end

local function apiPeek8(vm: *EVM): boolean
	-- signature:
	-- int peek8(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid byte read address 0x%08X", addr)
		return false
	end

	vm:pushU(vm:getMem8(addr))

	return true
end

local function apiPlayPattern(vm: *EVM): boolean
	-- signature:
	-- void playPattern(int track, int pattern);

	local track: uint32 = vm:getArgU(0)
	local pattern: uint32 = vm:getArgU(1)

	vm.soundchip:playPattern((@uint8)(track), (@uint8)(pattern))

	return true
end

local function apiPlaySong(vm: *EVM): boolean
	-- signature:
	-- void playSong(int row);

	local row: uint32 = vm:getArgU(0)

	vm.soundchip:playSongRow((@uint8)(row))

	return true
end

local function apiPlayTrack(vm: *EVM): boolean
	-- signature:
	-- void playTrack(int track, int song_row);

	local track: uint32 = vm:getArgU(0)
	local row: uint32 = vm:getArgU(1)

	vm.soundchip:playTrack((@uint8)(track), (@uint8)(row))

	return true
end

local function apiPlayWav(vm: *EVM): boolean
	-- signature:
	-- void playWav(int track, int id, int note, float volume, int loop_mode);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local id: uint32 = vm:getArgU(1)
	local note: uint8 = (@uint8)(vm:getArgU(2))
	local volume: float32 = vm:getArgF(3)
	local loop_mode: float32 = vm:getArgU(4)

	if id > 511 then
		vm.error = string.format("attempt to load invalid WAVMAP entry `%d`", id)
		return false
	end

	volume = util.midF(0.0, volume, 100.0)

	vm.soundchip:playWav(track, id, note, volume, loop_mode)

	return true
end

local function apiPlayWavEx(vm: *EVM): boolean
	-- signature:
	--[[
		void playWavEx(
			int track,
			int sample_start,
			int sample_end,
			int loop_start,
			int loop_end,
			int note,
			float volume,
			int loop_mode);
	]]

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local sample_start: uint32 = vm:getArgU(1)
	local sample_end: uint32 = vm:getArgU(2)
	local loop_start: uint32 = vm:getArgU(3)
	local loop_end: uint32 = vm:getArgU(4)
	local note: uint8 = (@uint8)(vm:getArgU(5))
	local volume: float32 = vm:getArgF(6)
	local loop_mode: uint32 = vm:getArgU(7)

	volume = util.midF(0.0, volume, 100.0)

	vm.soundchip:playWavEx(
		track,
		sample_start,
		sample_end,
		loop_start,
		loop_end,
		note,
		volume,
		loop_mode
	)

	return true
end

local function apiPoke32(vm: *EVM): boolean
	-- signature:
	-- void poke32(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint32 = vm:getArgU(1)

	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid word write address 0x%08X", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("misaligned word write address 0x%08X", addr)
		return false
	end

	if not vm:setMem32(addr, val) then
		vm.error = string.format("cannot write word to ROM address 0x%08X", addr)
		return false
	end

	return true
end

local function apiPoke8(vm: *EVM): boolean
	-- signature:
	-- void poke8(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint8 = (@uint8)(vm:getArgU(1) & 0xFF)

	if addr > MEMORY_MAX_ADDR then
		vm.error = string.format("invalid byte write address 0x%08X", addr)
		return false
	end

	if not vm:setMem8(addr, val) then
		vm.error = string.format("cannot write byte to ROM address 0x%08X", addr)
		return false
	end

	return true
end

local function apiPolygonMode(vm: *EVM): boolean
	-- signature:
	-- void polygonMode(int mode);
	
	local mode: uint32 = vm:getArgU(0)

	if mode > GPU_FILL then
		-- invalid mode
		return false
	end

	vm.gpu:polygonMode(mode)

	vm.gpu.render_state.flags_00ppcccc = (vm.gpu.render_state.flags_00ppcccc & ~GPU_POLYGON_MODE_MASK) | (@uint8)(mode << 4)

	return true
end

local function apiPopMatrix(vm: *EVM): boolean
	-- signature:
	-- void popMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count == 0 then
			vm.error = "projection matrix stack underflow"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count - 1
	else
		if vm.gpu.view_matrix_count == 0 then
			vm.error = "view matrix stack underflow"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count - 1
	end

	rlgl.popMatrix()
	
	return true
end

local function apiPowf(vm: *EVM): boolean
	-- signature:
	-- float powf(float a, float b);
	
	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	vm:pushF(a^b)

	return true
end

local function apiPressed(vm: *EVM): boolean
	-- signature:
	-- int pressed(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, input.PLAYER_COUNT - 1)
	b = (p * input.Button.COUNT) + b

	local code: cint = input.button_map[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyPressed(code) and 1 or 0)
	end
	
	return true
end

local function apiPrint2D(vm: *EVM): boolean
	-- signature:
	-- void print2D(int x, int y, int color, string fmt, ...);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local col: uint32 = vm:getArgU(2)
	local fmt: EVMString = vm:getArgStr(3)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return true
	end

	local cur_x: int32 = x
	local start_addr: uint32 = fmt.data
	local arg_addr: uint32
	local addr: uint32
	local arg_val0: IntFloat
	local arg_val1: IntFloat
	local arg_val2: IntFloat
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	-- setup varargs
	vm.cf.vargp = vm.ap + 5
	vm.cf.vargc = vm.cf.argc - 5
	vm.cf.vargf = true

	local i: uinteger = 0
	while i < fmt.len do
		local c: uint8

		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return true
		end

		addr = start_addr + i

		if not getMem8(vm, addr, &c) then return false end
		
		if c == '%'_u8 then
			if not getMem8(vm, addr + 1, &c) then return false end

			switch c do
				case 'i'_u8, 'd'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = string.format("insufficient vararg bytes for format specifier `%%%c`", c)
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.i)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'u'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "insufficient vararg bytes for format specifier `%i`"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'x'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "insufficient vararg bytes for format specifier `%x`"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08x", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'X'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "insufficient vararg bytes for format specifier `%X`"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08X", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'f'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "insufficient vararg bytes for format specifier `%f`"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%.2f", arg_val0.f)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'v'_u8 then
					if not getMem8(vm, addr + 2, &c) then return false end

					switch c do
						case '2'_u8 then
							if vm.cf.vargc < 2 then
								vm.error = "insufficient vararg bytes for format specifier `%v2`"
								return false
							end
		
							arg_addr = vargv(vm, 2)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f)", arg_val0.f, arg_val1.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						case '3'_u8 then
							if vm.cf.vargc < 3 then
								vm.error = "insufficient vararg bytes for format specifier `%v3`"
								return false
							end
		
							arg_addr = vargv(vm, 3)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
							if not getMem32(vm, arg_addr + 8, &arg_val2.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f, %.2f)", arg_val0.f, arg_val1.f, arg_val2.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						else
							vm.error = string.format("invalid format specifier `%%v%c`", c)
							return false
					end
				case '%'_u8 then
					vm.gpu:drawChar2D(c, &cur_x, y, ray_col)
				else
					vm.error = string.format("invalid format specifier `%%%c`", c)
					return false
			end
		elseif c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			vm.gpu:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end

	return true
end

local function apiPushMatrix(vm: *EVM): boolean
	-- signature:
	-- void pushMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count >= 24 then
			vm.error = "projection matrix stack overflow"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count + 1
	else
		if vm.gpu.view_matrix_count >= 24 then
			vm.error = "view matrix stack overflow"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count + 1
	end
	
	rlgl.pushMatrix()
	
	return true
end

local function apiRad(vm: *EVM): boolean
	-- signature:
	-- float rad(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.rad(v))

	return true
end

local function apiRandf(vm: *EVM): boolean
	-- signature:
	-- float randf(float min, float max);

	local min: float32 = vm:getArgF(0)
	local max: float32 = vm:getArgF(1)

	if max < min then
		min, max = max, min
	end

	local x: float32 = math.random() -- gets a float in [0, 1)

	vm:pushF(min + x * (max - min))

	return true
end

local function apiRandfEx(vm: *EVM): boolean
	-- signature:
	-- float randfEx();

	vm:pushF(math.random())

	return true
end

local function apiRandi(vm: *EVM): boolean
	-- signature:
	-- int randi(int min, int max);

	local min: int32 = vm:getArgI(0)
	local max: int32 = vm:getArgI(1)

	if max < min then
		min, max = max, min
	end

	vm:pushI(math.random(min, max))

	return true
end

local function apiRandiEx(vm: *EVM): boolean
	-- signature:
	-- int randiEx();

	vm:pushI(math.random(0)) -- get int will all random bits

	return true
end

local function apiRandomize(vm: *EVM): boolean
	-- signature:
	-- void randomize();

	math.randomseed()

	return true
end

local function apiRandomizeEx(vm: *EVM): boolean
	-- signature:
	-- void randomizeEx(int seed);

	local seed: uint32 = vm:getArgU(0)

	math.randomseed(seed)

	return true
end

local function apiRaycast(vm: *EVM): boolean
	-- signature:
	-- int raycast(vec3 position, vec3 direction, float distance, void* colobj);

	vm:pushU(0)

	return true
end

local function apiRealloc(vm: *EVM): boolean
	-- signature:
	-- void* realloc(void* block, int size);

	local block: uint32 = vm:getArgU(0)
	local size: uint32 = vm:getArgU(1)

	vm:pushU(vm:heapRealloc(block, size))

	return true
end

local function apiReleased(vm: *EVM): boolean
	-- signature:
	-- int released(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, input.PLAYER_COUNT - 1)
	b = (p * input.Button.COUNT) + b

	local code: cint = input.button_map[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyReleased(code) and 1 or 0)
	end
	
	return true
end

local function apiRepeated(vm: *EVM): boolean
	-- signature:
	-- int repeated(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, input.PLAYER_COUNT - 1)
	b = (p * input.Button.COUNT) + b

	local code: cint = input.button_map[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(input.pressedRepeat(code) and 1 or 0)
	end
	
	return true
end

local function apiResumeTrack(vm: *EVM): boolean
	-- signature:
	-- void resumeTrack(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local mask: uint8 = 0x80 >> track
	
	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags | mask

	return true
end

local function apiResumeTracks(vm: *EVM): boolean
	-- signature:
	-- void resumeTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags | (@uint8)(mask)

	return true
end

local function apiRotate(vm: *EVM): boolean
	-- signature:
	-- void rotate(vec3 rot);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.rotatef(v.z, 0, 0, 1)
	rlgl.rotatef(v.y, 0, 1, 0)
	rlgl.rotatef(v.x, 1, 0, 0)
	
	return true
end

local function apiRound(vm: *EVM): boolean
	-- signature:
	-- float round(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.round(v))

	return true
end

local function apiScale(vm: *EVM): boolean
	-- signature:
	-- void scale(vec3 sca);
	
	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.scalef(v.x, v.y, v.z)
	
	return true
end

local function apiScissor(vm: *EVM): boolean
	-- signature:
	-- void scissor(int x, int y, int w, int h);
	
	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local w: int32 = vm:getArgI(2)
	local h: int32 = vm:getArgI(3)
	
	vm.gpu:scissor(x, y, w, h)

	util.pokeI(&vm.gpu.render_state.scissor_x0, x)
	util.pokeI(&vm.gpu.render_state.scissor_y0, y)
	util.pokeI(&vm.gpu.render_state.scissor_width0, w)
	util.pokeI(&vm.gpu.render_state.scissor_height0, h)
	
	return true
end

local function apiScissorMode(vm: *EVM): boolean
	-- signature:
	-- void scissorMode(int enabled);
	
	local enabled: uint32 = vm:getArgU(0)
	
	if enabled ~= 0 then
		vm.gpu:scissorMode(true)
		vm.gpu.render_state.flags_00sttbbb = vm.gpu.render_state.flags_00sttbbb | GPU_SCISSOR_BIT
	else
		vm.gpu:scissorMode(false)
		vm.gpu.render_state.flags_00sttbbb = vm.gpu.render_state.flags_00sttbbb & ~GPU_SCISSOR_BIT
	end
	
	return true
end

local function apiSetModelViewMatrix(vm: *EVM): boolean
	-- signature:
	-- void setModelViewMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	rlgl.setMatrixModelview(m)

	return true
end

local function apiSetMouseLock(vm: *EVM): boolean
	local lock: uint32 = vm:getArgU(0)

	if lock == 0 then
		rl.enableCursor()
	else
		rl.disableCursor()
	end

	return true
end

local function apiSetProjectionMatrix(vm: *EVM): boolean
	-- signature:
	-- void setProjectionMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	rlgl.setMatrixProjection(m)

	return true
end

local function apiSetTrackBPM(vm: *EVM): boolean
	-- signature:
	-- void setTrackBPM(int track, int bpm);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local bpm: uint8 = (@uint8)(vm:getArgU(1))

	vm.soundchip:setTrackBPM(track, bpm)

	return true
end

local function apiSetTrackPan(vm: *EVM): boolean
	-- signature:
	-- void setTrackPan(int track, int pan);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local pan: int32 = vm:getArgI(1)

	if pan > 100 then
		pan = 100
	elseif pan < -100 then
		pan = -100
	end

	vm.soundchip:setTrackPan(track, pan)

	return true
end

local function apiSetTrackVolume(vm: *EVM): boolean
	-- signature:
	-- void setTrackVolume(int track, int volume);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local volume: uint8 = (@uint8)(vm:getArgU(1))

	vm.soundchip:setTrackVolume(track, volume)

	return true
end

local function apiSignf(vm: *EVM): boolean
	-- signature:
	-- float signf(float x);

	local x: float32 = vm:getArgF(0)

	vm:pushF(math.sign(x))

	return true
end

local function apiSigni(vm: *EVM): boolean
	-- signature:
	-- int signi(int x);

	local x: int32 = vm:getArgI(0)

	vm:pushI(math.sign(x))

	return true
end

local function apiSin(vm: *EVM): boolean
	-- signature:
	-- float sin(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.sin(v))

	return true
end

local function apiSprite2D(vm: *EVM): boolean
	-- signature:
	-- void sprite2D(int srcx, int srcy, int srcw, int srch, int destx, int desy);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(srcw), (@float32)(srch) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiSprite2DEx(vm: *EVM): boolean
	-- signature:
	-- void sprite2DEx(int srcx, int srcy, int srcw, int srch, int destx, int desy, int destw, int desth);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)
	local destw: int32 = vm:getArgI(6)
	local desth: int32 = vm:getArgI(7)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiStencilFunc(vm: *EVM): boolean
	-- signature:
	-- void stencilFunc(int face, int func, int ref, int mask)

	local face: uint32 = vm:getArgU(0)
	local func: uint32 = vm:getArgU(1)
	local ref: int32 = vm:getArgI(2)
	local mask: uint32 = vm:getArgU(3)

	if face > GPU_FRONT_AND_BACK then
		vm.error = string.format("attempt to set stencil function for invalid face `%d`", face)
		return false
	end

	if func > GPU_NEVER then
		vm.error = string.format("attempt to set invalid stencil function `%d`", func)
		return false
	end

	vm.gpu:stencilFunc(face, func, ref, mask)

	switch face do
		case GPU_FRONT then
			vm.gpu.render_state.stencil_functions = (vm.gpu.render_state.stencil_functions & 0b00001111) | (@uint8)(func << 4)
			vm.gpu.render_state.stencil_ref_front = (@uint8)(ref)
			vm.gpu.render_state.stencil_func_mask_front = (@uint8)(mask)
		case GPU_BACK then
			vm.gpu.render_state.stencil_functions = (vm.gpu.render_state.stencil_functions & 0b11110000) | (@uint8)(func)
			vm.gpu.render_state.stencil_ref_back = (@uint8)(ref)
			vm.gpu.render_state.stencil_func_mask_back = (@uint8)(mask)
		case GPU_FRONT_AND_BACK then
			vm.gpu.render_state.stencil_functions = (@uint8)(func << 4) | (@uint8)(func)
			vm.gpu.render_state.stencil_ref_front = (@uint8)(ref)
			vm.gpu.render_state.stencil_func_mask_front = (@uint8)(mask)
			vm.gpu.render_state.stencil_ref_back = (@uint8)(ref)
			vm.gpu.render_state.stencil_func_mask_back = (@uint8)(mask)
	end

	return true
end

local function apiStencilMask(vm: *EVM): boolean
	-- signature:
	-- void stencilMask(int face, int mask)

	local face: uint32 = vm:getArgU(0)
	local mask: uint32 = vm:getArgU(1)

	if face > GPU_FRONT_AND_BACK then
		vm.error = string.format("attempt to set stencil mask for invalid face `%d`", face)
		return false
	end

	vm.gpu:stencilMask(face, mask)

	switch face do
		case GPU_FRONT then
			vm.gpu.render_state.stencil_mask_front = (@uint8)(mask)
		case GPU_BACK then
			vm.gpu.render_state.stencil_mask_back = (@uint8)(mask)
		case GPU_FRONT_AND_BACK then
			vm.gpu.render_state.stencil_mask_front = (@uint8)(mask)
			vm.gpu.render_state.stencil_mask_back = (@uint8)(mask)
	end

	return true
end

local function apiStencilMode(vm: *EVM): boolean
	-- signature:
	-- void stencilMode(int mode)

	local mode: uint32 = vm:getArgU(0)

	if mode ~= 0 then
		vm.gpu:stencilMode(true)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl | GPU_STENCIL_BIT
	else
		vm.gpu:stencilMode(false)
		vm.gpu.render_state.flags_tmccs0fl = vm.gpu.render_state.flags_tmccs0fl & ~GPU_STENCIL_BIT
	end

	return true
end

local function apiStencilOp(vm: *EVM): boolean
	-- signature:
	-- void stencilOp(int face, int sfail, int dpfail, int dppass)

	local face: uint32 = vm:getArgU(0)
	local sfail: uint32 = vm:getArgU(1)
	local dpfail: uint32 = vm:getArgU(2)
	local dppass: uint32 = vm:getArgU(3)

	if face > GPU_FRONT_AND_BACK then
		vm.error = string.format("attempt to set stencil operation for invalid face `%d`", face)
		return false
	end

	if sfail > GPU_INVERT then
		vm.error = string.format("attempt to set invalid stencil sfail operation `%d`", sfail)
		return false
	end

	if dpfail > GPU_INVERT then
		vm.error = string.format("attempt to set invalid stencil dpfail operation `%d`", dpfail)
		return false
	end

	if dppass > GPU_INVERT then
		vm.error = string.format("attempt to set invalid stencil dppass operation `%d`", dppass)
		return false
	end

	vm.gpu:stencilOp(face, sfail, dpfail, dppass)

	switch face do
		case GPU_FRONT then
			vm.gpu.render_state.stencil_sfails = (vm.gpu.render_state.stencil_sfails & 0b00001111) | (uint8)(sfail << 4)
			vm.gpu.render_state.stencil_dpfails = (vm.gpu.render_state.stencil_dpfails & 0b00001111) | (uint8)(dpfail << 4)
			vm.gpu.render_state.stencil_dppasses = (vm.gpu.render_state.stencil_dppasses & 0b00001111) | (uint8)(dppass << 4)
		case GPU_BACK then
			vm.gpu.render_state.stencil_sfails = (vm.gpu.render_state.stencil_sfails & 0b11110000) | (uint8)(sfail)
			vm.gpu.render_state.stencil_dpfails = (vm.gpu.render_state.stencil_dpfails & 0b11110000) | (uint8)(dpfail)
			vm.gpu.render_state.stencil_dppasses = (vm.gpu.render_state.stencil_dppasses & 0b11110000) | (uint8)(dppass)
		case GPU_FRONT_AND_BACK then
			vm.gpu.render_state.stencil_sfails = (uint8)(sfail << 4) | (uint8)(sfail)
			vm.gpu.render_state.stencil_dpfails = (uint8)(dpfail << 4) | (uint8)(dpfail)
			vm.gpu.render_state.stencil_dppasses = (uint8)(dppass << 4) | (uint8)(dppass)
	end

	return true
end

local function apiStopTrack(vm: *EVM): boolean
	-- signature:
	-- void stopTrack(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	
	vm.soundchip:stopTrack(track)

	return true
end

local function apiStopTracks(vm: *EVM): boolean
	-- signature:
	-- void stopTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:stopTrack(i)
		end
	end

	return true
end

local function apiStrcat(vm: *EVM): boolean
	-- signature:
	-- string strcat(string a, string b);

	local a: EVMString = vm:getArgStr(0)
	local b: EVMString = vm:getArgStr(2)

	-- verify strings
	if (a.len == 0) or (a.data > MEMORY_MAX_ADDR) or
		(b.len == 0) or (b.data > MEMORY_MAX_ADDR) then
		vm.error = "attempt to concatenate invalid string(s)"
		return false
	end

	local new_len: uint32 = a.len + b.len
	local new_block: uint32 = vm:heapAlloc(new_len)
	if new_block == MEMORY_NULL then
		return MEMORY_NULL
	end

	-- copy a to new block
	for i = 0, < a.len do
		local byte: uint8 = vm:getMem8(a.data + i)
		if not vm:setMem8(new_block + i, byte) then
			vm.error = string.format("invalid byte write address 0x%08X", i)
			return false
		end
	end

	-- copy b to new block
	for i = 0, < b.len do
		local byte: uint8 = vm:getMem8(b.data + i)
		if not vm:setMem8(new_block + a.len + i, byte) then
			vm.error = string.format("invalid byte write address 0x%08X", i)
			return false
		end
	end

	vm:pushStr({new_len, new_block})

	return true
end

local function apiStrdup(vm: *EVM): boolean
	-- signature:
	-- string strdup(string s);

	local s: EVMString = vm:getArgStr(0)

	-- verify string
	if (s.len == 0) or (s.data > MEMORY_MAX_ADDR) then
		vm.error = "attempt to duplicate invalid string"
		return false
	end

	-- alloc() new block
	local new_block: uint32 = vm:heapAlloc(s.len)
	if new_block == MEMORY_NULL then
		return MEMORY_NULL
	end

	-- copy string to new block
	for i = 0, < s.len do
		local byte: uint8 = vm:getMem8(s.data + i)
		if not vm:setMem8(new_block + i, byte) then
			vm.error = string.format("invalid byte write address 0x%08X", i)
			return false
		end
	end

	vm:pushStr({s.len, new_block})

	return true
end

local function apiStrfmt(vm: *EVM): boolean
	-- signature:
	-- string strfmt(string fmt, ...);

	local fmt: EVMString = vm:getArgStr(0)

	-- ...

	vm:pushStr({0, MEMORY_NULL})

	return true
end

local function apiTexture(vm: *EVM): boolean
	-- signature:
	-- void texture(int x, int y, int w, int h);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local w: int32 = vm:getArgI(2)
	local h: int32 = vm:getArgI(3)

	w = math.clamp(w, 1, 256)
	h = math.clamp(h, 1, 256)
	x = math.clamp(x, 0, 1024 - w)
	y = math.clamp(y, 0, 1024 - h)

	vm.gpu:texture(x, y, w, h)

	util.pokeI(&vm.gpu.render_state.texture_x0, x)
	util.pokeI(&vm.gpu.render_state.texture_y0, y)
	vm.gpu.render_state.texture_width = (uint8)(w - 1)
	vm.gpu.render_state.texture_height = (uint8)(h - 1)

	return true
end

local function apiTextureMode(vm: *EVM): boolean
	-- signature:
	-- void textureMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("attempt to set invalid texture mode `%d`", mode)
		return false
	end

	vm.gpu:textureMode(mode)

	vm.gpu.render_state.flags_00sttbbb = (vm.gpu.render_state.flags_00sttbbb & ~GPU_TEXTURE_MODE_MASK) | (uint8)(mode << 3)

	return true
end

local function apiTime(vm: *EVM): boolean
	-- signature:
	-- float time();

	vm:pushF((@float32)(rl.getTime() - vm.init_time))
	
	return true
end

local function apiTranslate(vm: *EVM): boolean
	-- signature:
	-- void translate(vec3 pos);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.translatef(v.x, v.y, v.z)
	
	return true
end

local function apiUnmuteTrack(vm: *EVM): boolean
	-- signature:
	-- void unmuteTrack(int track);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	
	vm.soundchip:unmuteTrack(track)

	return true
end

local function apiUnmuteTracks(vm: *EVM): boolean
	-- signature:
	-- void unmuteTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:unmuteTrack(i)
		end
	end

	return true
end

local function apiVargc(vm: *EVM): boolean
	-- signature:
	-- int vargc();

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("(DEBUG): cannot call vargc() with empty callstack")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("cannot call vargc() from non-vararg function")
		return false
	end

	vm:pushU(frame.vargc * 4) -- return number of vararg bytes to allow use of sizeof()

	return true
end

local function apiVargv(vm: *EVM): boolean
	-- signature:
	-- void* vargv(int offset);

	local offset: uint32 = vm:getArgU(0) /// 4 -- offset is given in bytes to allow easy use of sizeof()

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("(DEBUG): cannot call vargv() with empty callstack")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("cannot call vargv() from non-vararg function")
		return false
	end

	if frame.vargc == 0 then
		vm.error = string.format("vargv() called after end of varargs")
		return false
	end

	if offset > frame.vargc then
		vm.error = string.format("vararg count exceeded by %d word(s)", offset - frame.vargc)
		return false
	end

	frame.vargc = frame.vargc - offset
	
	-- return adress vargp currently points to
	vm:pushU(MEMORY_ARGS_START_ADDR + (frame.vargp * 4))

	-- offset vararg pointer
	frame.vargp = frame.vargp + offset

	return true
end

local function apiVec2Angle(vm: *EVM): boolean
	-- signature:
	-- float vec2Angle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.deg(math.atan2(b.y - a.y, b.x - a.x)))

	return true
end

local function apiVec2Cross(vm: *EVM): boolean
	-- signature:
	-- float vec2Cross(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.y - a.y * b.x)

	return true
end

local function apiVec2Direction(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Direction(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local direction: rl.vector2 = b - a;

	local l: float32 = direction.x * direction.x + direction.y * direction.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
	end

	vm:pushV2(direction)

	return true
end

local function apiVec2Distance(vm: *EVM): boolean
	-- signature:
	-- float vec2Distance(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)))
	
	return true
end

local function apiVec2DistanceSq(vm: *EVM): boolean
	-- signature:
	-- float vec2DistanceSq(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	
	vm:pushF((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
	
	return true
end

local function apiVec2Dot(vm: *EVM): boolean
	-- signature:
	-- float vec2Dot(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.x + a.y * b.y)

	return true
end

local function apiVec2Invert(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Invert(vec2 v);
	
	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushV2(rl.vector2.invert(v))

	return true
end

local function apiVec2Length(vm: *EVM): boolean
	-- signature:
	-- float vec2Length(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(math.sqrt(v.x * v.x + v.y * v.y))

	return true
end

local function apiVec2LengthSq(vm: *EVM): boolean
	-- signature:
	-- float vec2LengthSq(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(v.x * v.x + v.y * v.y)

	return true
end

local function apiVec2Lerp(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Lerp(vec2 a, vec2 b, float amount);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local amount: float32 = vm:getArgF(4)

	vm:pushV2(rl.vector2.lerp(a, b, amount))

	return true
end

local function apiVec2MoveToward(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2MoveToward(vec2 a, vec2 b, float delta);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local delta: float32 = vm:getArgF(4)

	local dest: rl.vector2 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV2(b)
	else
		local temp: rl.vector2 = {
			dest.x / length * delta,
			dest.y / length * delta
		}
		vm:pushV2(a + temp)
	end

	return true
end

local function apiVec2Normalize(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Normalize(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	local l: float32 = v.x * v.x + v.y * v.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
	end

	vm:pushV2(v)

	return true
end

local function apiVec2Reflect(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Reflect(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	
	vm:pushV2(rl.vector2.reflect(a, b))
	
	return true
end

local function apiVec2Rotate(vm: *EVM): boolean
	-- signature:
	-- vec2 vec2Rotate(vec2 v, float angle);

	local v: rl.vector2 = vm:getArgV2(0)
	local angle: float32 = vm:getArgF(2)
	
	vm:pushV2(rl.vector2.rotate(v, angle))

	return true
end

local function apiVec3Angle(vm: *EVM): boolean
	-- signature:
	-- float vec3Angle(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(math.deg(rl.vector3.angle(a, b)))

	return true
end

local function apiVec3Cross(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Cross(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushV3(v3Cross(a, b))
	
	return true
end

local function apiVec3Direction(vm: *EVM): boolean
	-- signature:
	-- vec2 vec3Direction(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local direction: rl.vector3 = b - a;

	local x: float32 = direction.x * direction.x
	local y: float32 = direction.y * direction.y
	local z: float32 = direction.z * direction.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
		direction.z = direction.z / l
	end

	vm:pushV3(direction)

	return true
end

local function apiVec3Distance(vm: *EVM): boolean
	-- signature:
	-- float vec3Distance(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3DistanceSq(vm: *EVM): boolean
	-- signature:
	-- float vec3DistanceSq(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Dot(vm: *EVM): boolean
	-- signature:
	-- float vec3Dot(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(a.x * b.x + a.y * b.y + a.z * b.z)
	
	return true
end

local function apiVec3Invert(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Invert(vec3 a);

	local v: rl.vector3 = vm:getArgV3(0)

	vm:pushV3(rl.vector3.invert(v))

	return true
end

local function apiVec3Length(vm: *EVM): boolean
	-- signature:
	-- float vec3Length(vec3 v);
	
	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3LengthSq(vm: *EVM): boolean
	-- signature:
	-- float vec3LengthSq(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Lerp(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Lerp(vec3 a, vec3 b, float amount);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local amount: float32 = vm:getArgF(6)
	
	vm:pushV3(rl.vector3.lerp(a, b, amount))

	return true
end

local function apiVec3MoveToward(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3MoveToward(vec3 a, vec3 b, float delta);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local delta: float32 = vm:getArgF(6)

	local dest: rl.vector3 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV3(b)
	else
		local temp: rl.vector3 = {
			dest.x / length * delta,
			dest.y / length * delta,
			dest.z / length * delta
		}
		vm:pushV3(a + temp)
	end

	return true
end

local function apiVec3Normalize(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Normalize(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	vm:pushV3(v3Normalize(v))
	
	return true
end

local function apiVec3Reflect(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Reflect(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushV3(rl.vector3.reflect(a, b))

	return true
end

local function apiVec3Rotate(vm: *EVM): boolean
	-- signature:
	-- vec3 vec3Rotate(vec3 v, vec3 axis, float angle);

	local v: rl.vector3 = vm:getArgV3(0)
	local axis: rl.vector3 = vm:getArgV3(3)
	local angle: float32 = vm:getArgF(6)
	
	vm:pushV3(rl.vector3.rotateByAxisAngle(v, axis, angle))

	return true
end

local function apiVec3ToScreen(vm: *EVM): boolean
	-- signature:
	-- vec2 vec3ToScreen(vec pos, int camera_id);

	--local pos: rl.vector3 = vm:getArgV3(0)
	--local camera_id: uinteger = math.clamp(vm:getArgU(3), 0, GPU_CAMERAS_COUNT - 1)

	--vm:pushV2(rl.getWorldToScreenEx(pos, vm.gpu.cameras[camera_id], vm.gpu.viewport_w, vm.gpu.viewport_h))
	vm:pushV2({0.0, 0.0})

	return true
end

local function apiViewport(vm: *EVM): boolean
	-- signature:
	-- void viewport(int x, int y, int w, int h);

	local x: cint = (@cint)(vm:getArgI(0))
	local y: cint = (@cint)(vm:getArgI(1))
	local w: cint = (@cint)(vm:getArgI(2))
	local h: cint = (@cint)(vm:getArgI(3))

	vm.gpu:viewport(x, y, w, h, false)

	util.pokeI(&vm.gpu.render_state.viewport_x0, x)
	util.pokeI(&vm.gpu.render_state.viewport_y0, y)
	util.pokeI(&vm.gpu.render_state.viewport_width0, w)
	util.pokeI(&vm.gpu.render_state.viewport_height0, h)

	return true
end

local function apiWrapf(vm: *EVM): boolean
	-- signature:
	-- float wrapf(float x, float min, float max);

	local x: float32 = vm:getArgF(0)
	local min: float32 = vm:getArgF(1)
	local max: float32 = vm:getArgF(2)
	
	vm:pushF(util.wrapF(x, min, max))
	
	return true
end

local function apiWrapi(vm: *EVM): boolean
	-- signature:
	-- int wrapi(int x, int min, int max);

	local x: int32 = vm:getArgI(0)
	local min: int32 = vm:getArgI(1)
	local max: int32 = vm:getArgI(2)

    vm:pushI(util.wrapI(x, min, max))
	
	return true
end

-- API REGISTRATION FUNCTIONS:

function EVM:registerBuiltins(): void
	-- define vec2 struct
	local sid: *Struct = new(@Struct)
	local vec2_x: *Identifier = new(@Identifier)
	local vec2_y: *Identifier = new(@Identifier)
	sid.name = "vec2"
	$vec2_x = {name="x", index=0, type_info={EVMType.FLOAT}}
	$vec2_y = {name="y", index=1, type_info={EVMType.FLOAT}}
	sid:addMember(vec2_x)
	sid:addMember(vec2_y)
	sid.is_complete = true
	self.struct_vec2 = sid

	-- define vec3 struct
	sid = new(@Struct)
	local vec3_x: *Identifier = new(@Identifier)
	local vec3_y: *Identifier = new(@Identifier)
	local vec3_z: *Identifier = new(@Identifier)
	sid.name = "vec3"
	$vec3_x = {name="x", index=0, type_info={EVMType.FLOAT}}
	$vec3_y = {name="y", index=1, type_info={EVMType.FLOAT}}
	$vec3_z = {name="z", index=2, type_info={EVMType.FLOAT}}
	sid:addMember(vec3_x)
	sid:addMember(vec3_y)
	sid:addMember(vec3_z)
	sid.is_complete = true
	self.struct_vec3 = sid

	--[[ define matrix struct, translatable to raylib's matrix type
		matrix:
			m0: float32, m4: float32, m8: float32, m12: float32,  first row
			m1: float32, m5: float32, m9: float32, m13: float32,  second row
			m2: float32, m6: float32, m10: float32, m14: float32, third row
			m3: float32, m7: float32, m11: float32, m15: float32  fourth row
	]]
	local matrix_struct: *Struct = new(@Struct)
	local matrix_m0: *Identifier = new(@Identifier)
	local matrix_m4: *Identifier = new(@Identifier)
	local matrix_m8: *Identifier = new(@Identifier)
	local matrix_m12: *Identifier = new(@Identifier)
	local matrix_m1: *Identifier = new(@Identifier)
	local matrix_m5: *Identifier = new(@Identifier)
	local matrix_m9: *Identifier = new(@Identifier)
	local matrix_m13: *Identifier = new(@Identifier)
	local matrix_m2: *Identifier = new(@Identifier)
	local matrix_m6: *Identifier = new(@Identifier)
	local matrix_m10: *Identifier = new(@Identifier)
	local matrix_m14: *Identifier = new(@Identifier)
	local matrix_m3: *Identifier = new(@Identifier)
	local matrix_m7: *Identifier = new(@Identifier)
	local matrix_m11: *Identifier = new(@Identifier)
	local matrix_m15: *Identifier = new(@Identifier)
	matrix_struct.name = "matrix"
	$matrix_m0  = {name="m0" , index=0 , type_info={EVMType.FLOAT}}
	$matrix_m4  = {name="m4" , index=1 , type_info={EVMType.FLOAT}}
	$matrix_m8  = {name="m8" , index=2 , type_info={EVMType.FLOAT}}
	$matrix_m12 = {name="m12", index=3 , type_info={EVMType.FLOAT}}
	$matrix_m1  = {name="m1" , index=4 , type_info={EVMType.FLOAT}}
	$matrix_m5  = {name="m5" , index=5 , type_info={EVMType.FLOAT}}
	$matrix_m9  = {name="m9" , index=6 , type_info={EVMType.FLOAT}}
	$matrix_m13 = {name="m13", index=7 , type_info={EVMType.FLOAT}}
	$matrix_m2  = {name="m2" , index=8 , type_info={EVMType.FLOAT}}
	$matrix_m6  = {name="m6" , index=9 , type_info={EVMType.FLOAT}}
	$matrix_m10 = {name="m10", index=10, type_info={EVMType.FLOAT}}
	$matrix_m14 = {name="m14", index=11, type_info={EVMType.FLOAT}}
	$matrix_m3  = {name="m3" , index=12, type_info={EVMType.FLOAT}}
	$matrix_m7  = {name="m7" , index=13, type_info={EVMType.FLOAT}}
	$matrix_m11 = {name="m11", index=14, type_info={EVMType.FLOAT}}
	$matrix_m15 = {name="m15", index=16, type_info={EVMType.FLOAT}}
	matrix_struct:addMember(matrix_m0)
	matrix_struct:addMember(matrix_m4)
	matrix_struct:addMember(matrix_m8)
	matrix_struct:addMember(matrix_m12)
	matrix_struct:addMember(matrix_m1)
	matrix_struct:addMember(matrix_m5)
	matrix_struct:addMember(matrix_m9)
	matrix_struct:addMember(matrix_m13)
	matrix_struct:addMember(matrix_m2)
	matrix_struct:addMember(matrix_m6)
	matrix_struct:addMember(matrix_m10)
	matrix_struct:addMember(matrix_m14)
	matrix_struct:addMember(matrix_m3)
	matrix_struct:addMember(matrix_m7)
	matrix_struct:addMember(matrix_m11)
	matrix_struct:addMember(matrix_m15)
	matrix_struct.is_complete = true

	-- define string struct
	sid = new(@Struct)
	local string_length: *Identifier = new(@Identifier)
	local string_data: *Identifier = new(@Identifier)
	sid.name = "string"
	$string_length = {name="length", index=0, type_info={EVMType.INT}}
	$string_data = {name="data", index=1, type_info={EVMType.VOID + EVMType.POINTER}}
	sid:addMember(string_length)
	sid:addMember(string_data)
	sid.is_complete = true
	self.struct_string = sid

	-- define vertex struct
	local vertex_struct: *Struct = new(@Struct)
	local vertex_position: *Identifier = new(@Identifier)
	local vertex_normal: *Identifier = new(@Identifier)
	local vertex_uv: *Identifier = new(@Identifier)
	local vertex_color: *Identifier = new(@Identifier)
	vertex_struct.name = "vertex"
	$vertex_position = {name="position", index=0, type_info={EVMType.VEC3, self.struct_vec3}}
	$vertex_normal = {name="normal", index=3, type_info={EVMType.VEC3, self.struct_vec3}}
	$vertex_uv = {name="uv", index=6, type_info={EVMType.VEC2, self.struct_vec2}}
	$vertex_color = {name="color", index=8, type_info={EVMType.INT}}
	vertex_struct:addMember(vertex_position)
	vertex_struct:addMember(vertex_normal)
	vertex_struct:addMember(vertex_uv)
	vertex_struct:addMember(vertex_color)
	vertex_struct.is_complete = true

	-- define cam2d struct
	local cam2d_struct: *Struct = new(@Struct)
	local cam2d_offset: *Identifier = new(@Identifier)
	local cam2d_target: *Identifier = new(@Identifier)
	local cam2d_rotation: *Identifier = new(@Identifier)
	local cam2d_zoom: *Identifier = new(@Identifier)
	cam2d_struct.name = "cam2d"
	$cam2d_offset = {name="offset", index=0, type_info={EVMType.VEC2, self.struct_vec2}}
	$cam2d_target = {name="target", index=2, type_info={EVMType.VEC2, self.struct_vec2}}
	$cam2d_rotation = {name="rotation", index=4, type_info={EVMType.FLOAT}}
	$cam2d_zoom = {name="zoom", index=5, type_info={EVMType.FLOAT}}
	cam2d_struct:addMember(cam2d_offset)
	cam2d_struct:addMember(cam2d_target)
	cam2d_struct:addMember(cam2d_rotation)
	cam2d_struct:addMember(cam2d_zoom)
	cam2d_struct.is_complete = true

	-- define cam3d struct
	local cam3d_struct: *Struct = new(@Struct)
	local cam3d_position: *Identifier = new(@Identifier)
	local cam3d_target: *Identifier = new(@Identifier)
	local cam3d_up: *Identifier = new(@Identifier)
	local cam3d_fov: *Identifier = new(@Identifier)
	local cam3d_projection: *Identifier = new(@Identifier)
	cam3d_struct.name = "cam3d"
	$cam3d_position = {name="position", index=0, type_info={EVMType.VEC3, self.struct_vec3}}
	$cam3d_target = {name="target", index=3, type_info={EVMType.VEC3, self.struct_vec3}}
	$cam3d_up = {name="up", index=6, type_info={EVMType.VEC3, self.struct_vec3}}
	$cam3d_fov = {name="fov", index=9, type_info={EVMType.FLOAT}}
	$cam3d_projection = {name="projection", index=10, type_info={EVMType.INT}}
	cam3d_struct:addMember(cam3d_position)
	cam3d_struct:addMember(cam3d_target)
	cam3d_struct:addMember(cam3d_up)
	cam3d_struct:addMember(cam3d_fov)
	cam3d_struct:addMember(cam3d_projection)
	cam3d_struct.is_complete = true

	-- define light struct
	local light_struct: *Struct = new(@Struct)
	local light_enabled: *Identifier = new(@Identifier)
	local light_type: *Identifier = new(@Identifier)
	local light_radius: *Identifier = new(@Identifier)
	local light_color: *Identifier = new(@Identifier)
	local light_position: *Identifier = new(@Identifier)
	local light_direction: *Identifier = new(@Identifier)
	light_struct.name = "light"
	$light_enabled = {name="enabled", index=0, type_info={EVMType.INT}}
	$light_type = {name="type", index=1, type_info={EVMType.INT}}
	$light_radius = {name="radius", index=2, type_info={EVMType.FLOAT}}
	$light_color = {name="color", index=3, type_info={EVMType.INT}}
	$light_position = {name="position", index=4, type_info={EVMType.VEC3, self.struct_vec3}}
	$light_direction = {name="direction", index=7, type_info={EVMType.VEC3, self.struct_vec3}}
	light_struct:addMember(light_enabled)
	light_struct:addMember(light_type)
	light_struct:addMember(light_radius)
	light_struct:addMember(light_color)
	light_struct:addMember(light_position)
	light_struct:addMember(light_direction)
	light_struct.is_complete = true

	-- define colpoint struct
	local colpoint_struct: *Struct = new(@Struct)
	local colpoint_type: *Identifier = new(@Identifier)
	local colpoint_position: *Identifier = new(@Identifier)
	colpoint_struct.name = "colpoint"
	$colpoint_type = {name="type", index=0, type_info={EVMType.INT}}
	$colpoint_position = {name="position", index=1, type_info={EVMType.VEC3, self.struct_vec3}}
	colpoint_struct:addMember(colpoint_type)
	colpoint_struct:addMember(colpoint_position)
	colpoint_struct.is_complete = true

	-- define colaabb struct
	local colaabb_struct: *Struct = new(@Struct)
	local colaabb_type: *Identifier = new(@Identifier)
	local colaabb_position: *Identifier = new(@Identifier)
	local colaabb_width: *Identifier = new(@Identifier)
	local colaabb_height: *Identifier = new(@Identifier)
	local colaabb_depth: *Identifier = new(@Identifier)
	colaabb_struct.name = "colaabb"
	$colaabb_type = {name="type", index=0, type_info={EVMType.INT}}
	$colaabb_position = {name="position", index=1, type_info={EVMType.VEC3, self.struct_vec3}}
	$colaabb_width = {name="width", index=4, type_info={EVMType.FLOAT}}
	$colaabb_height = {name="height", index=5, type_info={EVMType.FLOAT}}
	$colaabb_depth = {name="depth", index=6, type_info={EVMType.FLOAT}}
	colaabb_struct:addMember(colaabb_type)
	colaabb_struct:addMember(colaabb_position)
	colaabb_struct:addMember(colaabb_width)
	colaabb_struct:addMember(colaabb_height)
	colaabb_struct:addMember(colaabb_depth)
	colaabb_struct.is_complete = true

	-- define colsphere struct
	local colsphere_struct: *Struct = new(@Struct)
	local colsphere_type: *Identifier = new(@Identifier)
	local colsphere_position: *Identifier = new(@Identifier)
	local colsphere_radius: *Identifier = new(@Identifier)
	colsphere_struct.name = "colsphere"
	$colsphere_type = {name="type", index=0, type_info={EVMType.INT}}
	$colsphere_position = {name="position", index=1, type_info={EVMType.VEC3, self.struct_vec3}}
	$colsphere_radius = {name="radius", index=4, type_info={EVMType.FLOAT}}
	colsphere_struct:addMember(colsphere_type)
	colsphere_struct:addMember(colsphere_position)
	colsphere_struct:addMember(colsphere_radius)
	colsphere_struct.is_complete = true

	-- define colcylinder struct
	local colcylinder_struct: *Struct = new(@Struct)
	local colcylinder_type: *Identifier = new(@Identifier)
	local colcylinder_position: *Identifier = new(@Identifier)
	local colcylinder_height: *Identifier = new(@Identifier)
	local colcylinder_radius: *Identifier = new(@Identifier)
	colcylinder_struct.name = "colcylinder"
	$colcylinder_type = {name="type", index=0, type_info={EVMType.INT}}
	$colcylinder_position = {name="position", index=1, type_info={EVMType.VEC3, self.struct_vec3}}
	$colcylinder_height = {name="height", index=4, type_info={EVMType.FLOAT}}
	$colcylinder_radius = {name="radius", index=5, type_info={EVMType.FLOAT}}
	colcylinder_struct:addMember(colcylinder_type)
	colcylinder_struct:addMember(colcylinder_position)
	colcylinder_struct:addMember(colcylinder_height)
	colcylinder_struct:addMember(colcylinder_radius)
	colcylinder_struct.is_complete = true

	-- define coltriangle struct
	local coltriangle_struct: *Struct = new(@Struct)
	local coltriangle_type: *Identifier = new(@Identifier)
	local coltriangle_point1: *Identifier = new(@Identifier)
	local coltriangle_point2: *Identifier = new(@Identifier)
	local coltriangle_point3: *Identifier = new(@Identifier)
	coltriangle_struct.name = "coltriangle"
	$coltriangle_type = {name="type", index=0, type_info={EVMType.INT}}
	$coltriangle_point1 = {name="point1", index=1, type_info={EVMType.VEC3, self.struct_vec3}}
	$coltriangle_point2 = {name="point2", index=4, type_info={EVMType.VEC3, self.struct_vec3}}
	$coltriangle_point3 = {name="point3", index=7, type_info={EVMType.VEC3, self.struct_vec3}}
	coltriangle_struct:addMember(coltriangle_type)
	coltriangle_struct:addMember(coltriangle_point1)
	coltriangle_struct:addMember(coltriangle_point2)
	coltriangle_struct:addMember(coltriangle_point3)
	coltriangle_struct.is_complete = true

	local builtin_structs: []Identifier = {
		{name="matrix",      type_info={EVMType.STRUCT, matrix_struct}},
		{name="vertex",      type_info={EVMType.STRUCT, vertex_struct}},
		{name="cam2d",       type_info={EVMType.STRUCT, cam2d_struct}},
		{name="cam3d",       type_info={EVMType.STRUCT, cam3d_struct}},
		{name="light",       type_info={EVMType.STRUCT, light_struct}},
		{name="colpoint",    type_info={EVMType.STRUCT, colpoint_struct}},
		{name="colaabb",     type_info={EVMType.STRUCT, colaabb_struct}},
		{name="colsphere",   type_info={EVMType.STRUCT, colsphere_struct}},
		{name="colcylinder", type_info={EVMType.STRUCT, colcylinder_struct}},
		{name="coltriangle", type_info={EVMType.STRUCT, coltriangle_struct}}
	}
	
	local keyword_ids: []Identifier = {
		{name="void",     token=Token.VOID},
		{name="int",      token=Token.INT},
		{name="float",    token=Token.FLOAT},
		{name="vec2",     token=Token.VEC2},
		{name="vec3",     token=Token.VEC3},
		{name="string",   token=Token.STRING},
		{name="enum",     token=Token.ENUM},
		{name="struct",   token=Token.STRUCT},
		{name="if",       token=Token.IF},
		{name="else",     token=Token.ELSE},
		{name="return",   token=Token.RETURN},
		{name="break",    token=Token.BREAK},
		{name="continue", token=Token.CONTINUE},
		{name="sizeof",   token=Token.SIZEOF},
		{name="for",      token=Token.FOR},
		{name="while",    token=Token.WHILE}
	}

	local constant_ids: []Identifier = {
		{name="true", type_info={EVMType.INT}, const_val=1},
		{name="false", type_info={EVMType.INT}, const_val=0},
		{name="null", type_info={EVMType.VOID + EVMType.POINTER}, const_val=MEMORY_NULL},
		{name="SCREEN_WIDTH", type_info={EVMType.INT}, const_val=GPU_VSCREEN_W},
		{name="SCREEN_HEIGHT", type_info={EVMType.INT}, const_val=GPU_VSCREEN_H},
		{name="FONT_WIDTH", type_info={EVMType.INT}, const_val=6},
		{name="FONT_HEIGHT", type_info={EVMType.INT}, const_val=9},
		{name="MESH_LINES", type_info={EVMType.INT}, const_val=GPU_LINES},
		{name="MESH_TRIANGLES", type_info={EVMType.INT}, const_val=GPU_TRIANGLES},
		{name="MESH_QUADS", type_info={EVMType.INT}, const_val=GPU_QUADS},
		{name="MAT_PROJECTION", type_info={EVMType.INT}, const_val=GPU_PROJECTION},
		{name="MAT_MODELVIEW", type_info={EVMType.INT}, const_val=GPU_MODELVIEW},
		{name="CLEAR_NONE", type_info={EVMType.INT}, const_val=0},
		{name="CLEAR_COLOR", type_info={EVMType.INT}, const_val=GPU_CLEAR_COLOR},
		{name="CLEAR_DEPTH", type_info={EVMType.INT}, const_val=GPU_CLEAR_DEPTH},
		{name="CLEAR_STENCIL", type_info={EVMType.INT}, const_val=GPU_CLEAR_STENCIL},
		{name="CLEAR_ALL", type_info={EVMType.INT}, const_val=GPU_CLEAR_ALL},
		{name="COLOR_NONE", type_info={EVMType.INT}, const_val=0},
		{name="COLOR_R", type_info={EVMType.INT}, const_val=GPU_COLOR_MASK_R},
		{name="COLOR_G", type_info={EVMType.INT}, const_val=GPU_COLOR_MASK_G},
		{name="COLOR_B", type_info={EVMType.INT}, const_val=GPU_COLOR_MASK_B},
		{name="COLOR_A", type_info={EVMType.INT}, const_val=GPU_COLOR_MASK_A},
		{name="COLOR_ALL", type_info={EVMType.INT}, const_val=GPU_COLOR_MASK_ALL},
		{name="TEXTURE_WRAP", type_info={EVMType.INT}, const_val=0},
		{name="TEXTURE_CLAMP", type_info={EVMType.INT}, const_val=1},
		{name="TEXTURE_NONE", type_info={EVMType.INT}, const_val=2},
		{name="CULL_BACK", type_info={EVMType.INT}, const_val=0},
		{name="CULL_FRONT", type_info={EVMType.INT}, const_val=1},
		{name="CULL_NONE", type_info={EVMType.INT}, const_val=2},
		{name="BLEND_ALPHA", type_info={EVMType.INT}, const_val=0},
		{name="BLEND_ADD", type_info={EVMType.INT}, const_val=1},
		{name="BLEND_MULTIPLY", type_info={EVMType.INT}, const_val=2},
		{name="BLEND_ADD_ALT", type_info={EVMType.INT}, const_val=3},
		{name="BLEND_SUBTRACT", type_info={EVMType.INT}, const_val=4},
		{name="BLEND_PREMULTIPLY", type_info={EVMType.INT}, const_val=5},
		{name="BLEND_CUSTOM", type_info={EVMType.INT}, const_val=6},
		{name="BLEND_CUSTOM_EX", type_info={EVMType.INT}, const_val=7},
		{name="CAM_PERSPECTIVE", type_info={EVMType.INT}, const_val=0},
		{name="CAM_ORTHOGRAPHIC", type_info={EVMType.INT}, const_val=1},
		{name="LIGHT_POINT", type_info={EVMType.INT}, const_val=0},
		{name="LIGHT_DIRECTIONAL", type_info={EVMType.INT}, const_val=1},
		{name="FACE_FRONT", type_info={EVMType.INT}, const_val=GPU_FRONT},
		{name="FACE_BACK", type_info={EVMType.INT}, const_val=GPU_BACK},
		{name="FACE_BOTH", type_info={EVMType.INT}, const_val=GPU_FRONT_AND_BACK},
		{name="POLY_POINT", type_info={EVMType.INT}, const_val=GPU_POINT},
		{name="POLY_LINE", type_info={EVMType.INT}, const_val=GPU_LINE},
		{name="POLY_FILL", type_info={EVMType.INT}, const_val=GPU_FILL},
		{name="FUNC_LESS", type_info={EVMType.INT}, const_val=GPU_LESS},
		{name="FUNC_LEQUAL", type_info={EVMType.INT}, const_val=GPU_LEQUAL},
		{name="FUNC_GREATER", type_info={EVMType.INT}, const_val=GPU_GREATER},
		{name="FUNC_GEQUAL", type_info={EVMType.INT}, const_val=GPU_GEQUAL},
		{name="FUNC_EQUAL", type_info={EVMType.INT}, const_val=GPU_EQUAL},
		{name="FUNC_NOTEQUAL", type_info={EVMType.INT}, const_val=GPU_NOTEQUAL},
		{name="FUNC_ALWAYS", type_info={EVMType.INT}, const_val=GPU_ALWAYS},
		{name="FUNC_NEVER", type_info={EVMType.INT}, const_val=GPU_NEVER},
		{name="FACTOR_ZERO", type_info={EVMType.INT}, const_val=GPU_BLEND_ZERO},
		{name="FACTOR_ONE", type_info={EVMType.INT}, const_val=GPU_BLEND_ONE},
		{name="FACTOR_SRC_RGB", type_info={EVMType.INT}, const_val=GPU_SRC_COLOR},
		{name="FACTOR_ONE_MINUS_SRC_RGB", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_SRC_COLOR},
		{name="FACTOR_DST_RGB", type_info={EVMType.INT}, const_val=GPU_DST_COLOR},
		{name="FACTOR_ONE_MINUS_DST_RGB", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_DST_COLOR},
		{name="FACTOR_SRC_ALPHA", type_info={EVMType.INT}, const_val=GPU_SRC_ALPHA},
		{name="FACTOR_ONE_MINUS_SRC_ALPHA", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_SRC_ALPHA},
		{name="FACTOR_DST_ALPHA", type_info={EVMType.INT}, const_val=GPU_DST_ALPHA},
		{name="FACTOR_ONE_MINUS_DST_ALPHA", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_DST_ALPHA},
		{name="FACTOR_CONSTANT_RGB", type_info={EVMType.INT}, const_val=GPU_CONSTANT_COLOR},
		{name="FACTOR_ONE_MINUS_CONSTANT_RGB", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_CONSTANT_COLOR},
		{name="FACTOR_CONSTANT_ALPHA", type_info={EVMType.INT}, const_val=GPU_CONSTANT_ALPHA},
		{name="FACTOR_ONE_MINUS_CONSTANT_ALPHA", type_info={EVMType.INT}, const_val=GPU_ONE_MINUS_CONSTANT_ALPHA},
		{name="FACTOR_SRC_ALPHA_SATURATE", type_info={EVMType.INT}, const_val=GPU_SRC_ALPHA_SATURATE},
		{name="EQ_ADD", type_info={EVMType.INT}, const_val=GPU_ADD},
		{name="EQ_SUBTRACT", type_info={EVMType.INT}, const_val=GPU_SUBTRACT},
		{name="EQ_SUBTRACT_REVERSE", type_info={EVMType.INT}, const_val=GPU_REVERSE_SUBTRACT},
		{name="EQ_MIN", type_info={EVMType.INT}, const_val=GPU_MIN},
		{name="EQ_MAX", type_info={EVMType.INT}, const_val=GPU_MAX},
		{name="STENCIL_KEEP", type_info={EVMType.INT}, const_val=GPU_KEEP},
		{name="STENCIL_REPLACE", type_info={EVMType.INT}, const_val=GPU_REPLACE},
		{name="STENCIL_INC", type_info={EVMType.INT}, const_val=GPU_INCR},
		{name="STENCIL_INC_WRAP", type_info={EVMType.INT}, const_val=GPU_INCR_WRAP},
		{name="STENCIL_DEC", type_info={EVMType.INT}, const_val=GPU_DECR},
		{name="STENCIL_DEC_WRAP", type_info={EVMType.INT}, const_val=GPU_DECR_WRAP},
		{name="STENCIL_ZERO", type_info={EVMType.INT}, const_val=GPU_STENCIL_ZERO},
		{name="STENCIL_INVERT", type_info={EVMType.INT}, const_val=GPU_INVERT},
		{name="LOOP_OFF", type_info={EVMType.INT}, const_val=0},
		{name="LOOP_FORWARD", type_info={EVMType.INT}, const_val=1},
		{name="LOOP_PINGPONG", type_info={EVMType.INT}, const_val=2},
		{name="LOOP_RANGE", type_info={EVMType.INT}, const_val=3},
		{name="BTN_UP", type_info={EVMType.INT}, const_val=input.Button.UP},
		{name="BTN_DOWN", type_info={EVMType.INT}, const_val=input.Button.DOWN},
		{name="BTN_LEFT", type_info={EVMType.INT}, const_val=input.Button.LEFT},
		{name="BTN_RIGHT", type_info={EVMType.INT}, const_val=input.Button.RIGHT},
		{name="BTN_TRIANGLE", type_info={EVMType.INT}, const_val=input.Button.TRIANGLE},
		{name="BTN_CROSS", type_info={EVMType.INT}, const_val=input.Button.CROSS},
		{name="BTN_SQUARE", type_info={EVMType.INT}, const_val=input.Button.SQUARE},
		{name="BTN_CIRCLE", type_info={EVMType.INT}, const_val=input.Button.CIRCLE},
		{name="BTN_L1", type_info={EVMType.INT}, const_val=input.Button.L1},
		{name="BTN_L2", type_info={EVMType.INT}, const_val=input.Button.L2},
		{name="BTN_R1", type_info={EVMType.INT}, const_val=input.Button.R1},
		{name="BTN_R2", type_info={EVMType.INT}, const_val=input.Button.R2},
		{name="BTN_SELECT", type_info={EVMType.INT}, const_val=input.Button.SELECT},
		{name="BTN_START", type_info={EVMType.INT}, const_val=input.Button.START},
		{name="BTN_MOUSE_LEFT", type_info={EVMType.INT}, const_val=0},
		{name="BTN_MOUSE_RIGHT", type_info={EVMType.INT}, const_val=1},
		{name="BTN_MOUSE_MIDDLE", type_info={EVMType.INT}, const_val=2},
		{name="MEMORY_HEAP", type_info={EVMType.INT}, const_val=0},
		{name="MEMORY_TEXMEM", type_info={EVMType.INT}, const_val=MEMORY_TEXMEM_START_ADDR},
		{name="MEMORY_OBJMEM", type_info={EVMType.INT}, const_val=MEMORY_OBJMEM_START_ADDR},
		{name="MEMORY_AOBMEM", type_info={EVMType.INT}, const_val=MEMORY_AOBMEM_START_ADDR},
		{name="MEMORY_SYSMEM", type_info={EVMType.INT}, const_val=MEMORY_SYSMEM_START_ADDR},
		{name="MEMORY_OBJMAP", type_info={EVMType.INT}, const_val=MEMORY_SYSMEM_START_ADDR + 84},
		{name="MEMORY_WAVMAP", type_info={EVMType.INT}, const_val=MEMORY_SYSMEM_START_ADDR + 84 + MEMORY_OBJMAP_SIZE},
		{name="MEMORY_WAVMEM", type_info={EVMType.INT}, const_val=MEMORY_WAVMEM_START_ADDR},
		{name="MEMORY_SEQMEM", type_info={EVMType.INT}, const_val=MEMORY_SEQMEM_START_ADDR},
		{name="MEMORY_TEXBANK0", type_info={EVMType.INT}, const_val=MEMORY_TEXBANK_START_ADDR},
		{name="MEMORY_TEXBANK1", type_info={EVMType.INT}, const_val=MEMORY_TEXBANK_START_ADDR + MEMORY_TEXMEM_SIZE_BYTES},
		{name="MEMORY_TEXBANK2", type_info={EVMType.INT}, const_val=MEMORY_TEXBANK_START_ADDR + (MEMORY_TEXMEM_SIZE_BYTES * 2)},
		{name="MEMORY_TEXBANK3", type_info={EVMType.INT}, const_val=MEMORY_TEXBANK_START_ADDR + (MEMORY_TEXMEM_SIZE_BYTES * 3)},
		{name="MEMORY_OBJBANK0", type_info={EVMType.INT}, const_val=MEMORY_OBJBANK_START_ADDR},
		{name="MEMORY_OBJBANK1", type_info={EVMType.INT}, const_val=MEMORY_OBJBANK_START_ADDR + MEMORY_OBJMEM_SIZE_BYTES},
		{name="MEMORY_OBJBANK2", type_info={EVMType.INT}, const_val=MEMORY_OBJBANK_START_ADDR + (MEMORY_OBJMEM_SIZE_BYTES * 2)},
		{name="MEMORY_OBJBANK3", type_info={EVMType.INT}, const_val=MEMORY_OBJBANK_START_ADDR + (MEMORY_OBJMEM_SIZE_BYTES * 3)},
		{name="MEMORY_OMPBANK0", type_info={EVMType.INT}, const_val=MEMORY_OMPBANK_START_ADDR},
		{name="MEMORY_OMPBANK1", type_info={EVMType.INT}, const_val=MEMORY_OMPBANK_START_ADDR + MEMORY_OBJMAP_SIZE},
		{name="MEMORY_OMPBANK2", type_info={EVMType.INT}, const_val=MEMORY_OMPBANK_START_ADDR + (MEMORY_OBJMAP_SIZE * 2)},
		{name="MEMORY_OMPBANK3", type_info={EVMType.INT}, const_val=MEMORY_OMPBANK_START_ADDR + (MEMORY_OBJMAP_SIZE * 3)},
		{name="MEMORY_WMPBANK0", type_info={EVMType.INT}, const_val=MEMORY_WMPBANK_START_ADDR},
		{name="MEMORY_WMPBANK1", type_info={EVMType.INT}, const_val=MEMORY_WMPBANK_START_ADDR + MEMORY_WAVMAP_SIZE},
		{name="MEMORY_WAVBANK0", type_info={EVMType.INT}, const_val=MEMORY_WAVBANK_START_ADDR},
		{name="MEMORY_WAVBANK1", type_info={EVMType.INT}, const_val=MEMORY_WAVBANK_START_ADDR + MEMORY_WAVMEM_SIZE_BYTES},
		{name="MEMORY_SEQBANK0", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR},
		{name="MEMORY_SEQBANK1", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + MEMORY_SEQMEM_SIZE_BYTES},
		{name="MEMORY_SEQBANK2", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 2)},
		{name="MEMORY_SEQBANK3", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 3)},
		{name="MEMORY_SEQBANK4", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 4)},
		{name="MEMORY_SEQBANK5", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 5)},
		{name="MEMORY_SEQBANK6", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 6)},
		{name="MEMORY_SEQBANK7", type_info={EVMType.INT}, const_val=MEMORY_SEQBANK_START_ADDR + (MEMORY_SEQMEM_SIZE_BYTES * 7)},
		{name="MEMORY_ROM", type_info={EVMType.INT}, const_val=MEMORY_ROM_START_ADDR},
		{name="MEMORY_MEMCARD", type_info={EVMType.INT}, const_val=MEMORY_MEMCARD_START_ADDR}
	}

	local constructor_ids: []Identifier = {
		{name="vec2Zero", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_ZERO},
		{name="vec2One", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_ONE},
		{name="vec2Up", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_UP},
		{name="vec2Down", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_DOWN},
		{name="vec2Left", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_LEFT},
		{name="vec2Right", type_info={EVMType.VEC2, self.struct_vec2}, const_val=Opcode.PUSH_VEC2_RIGHT},
		{name="vec3Zero", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_ZERO},
		{name="vec3One", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_ONE},
		{name="vec3Up", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_UP},
		{name="vec3Down", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_DOWN},
		{name="vec3Left", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_LEFT},
		{name="vec3Right", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_RIGHT},
		{name="vec3Forward", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_FORWARD},
		{name="vec3Back", type_info={EVMType.VEC3, self.struct_vec3}, const_val=Opcode.PUSH_VEC3_BACK}
	}

	self.keywords:reserve(#keyword_ids)
	for i = 0, < #keyword_ids do
		local id: *Identifier = new(@Identifier)
		$id = keyword_ids[i]
		id.class = Class.KEYWORD
		self.keywords[id.name] = id
	end

	self.constants:reserve(#constant_ids)
	for i = 0, < #constant_ids do
		local id: *Identifier = new(@Identifier)
		$id = constant_ids[i]
		id.token = Token.ID
		id.class = Class.CONSTANT
		self.constants[id.name] = id
	end

	-- vector construction functions are special cases,
	-- they are translated directly to opcodes
	for i = 0, < #constructor_ids do
		local id: *Identifier = new(@Identifier)
		$id = constructor_ids[i]
		id.token = Token.ID
		id.class = Class.API
		self.api_ids[id.name] = id
	end

	self.builtin_struct_ids:reserve(#builtin_structs)
	for i = 0, < #builtin_structs do
		local id: *Identifier = new(@Identifier)
		$id = builtin_structs[i]
		id.token = Token.STRUCT_ID
		id.class = Class.STRUCT
		self.builtin_struct_ids[id.name] = id
	end
end

function EVM:registerAPI(): void
	-- get references to predefined struct types
	local matrix_struct: *Struct = self.builtin_struct_ids["matrix"].type_info.structref
	local cam2d_struct: *Struct = self.builtin_struct_ids["cam2d"].type_info.structref
	local cam3d_struct: *Struct = self.builtin_struct_ids["cam3d"].type_info.structref
	local light_struct: *Struct = self.builtin_struct_ids["light"].type_info.structref

	local api_ids: []Identifier = {
		{
			name="alloc",
			type_info={EVMType.VOID + EVMType.POINTER},
			argdata={{EVMType.INT}},
			func=apiAlloc
		},
        {
			name="ambientColor",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiAmbientColor
		},
        {
			name="ambientFactor",
			type_info={EVMType.VOID},
			argdata={{EVMType.FLOAT}},
			func=apiAmbientFactor
		},
        {
			name="beginMesh",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiBeginMesh
		},
        {
			name="blendFactors",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiBlendFactors
		},
		{
			name="blendFactorsEx",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiBlendFactorsEx
		},
        {
			name="blendMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiBlendMode
		},
        {
			name="cam3DForward",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={{EVMType.INT}},
			func=apiCam3DForward
		},
        {
			name="cam3DRight",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={{EVMType.INT}},
			func=apiCam3DRight
		},
        {
			name="camera2D",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiCamera2D
		},
        {
			name="camera3D",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiCamera3D
		},
        {
			name="ceil",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiCeil
		},
        {
			name="clear",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiClear
		},
        {
			name="clearColor",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiClearColor
		},
        {
			name="clearDepth",
			type_info={EVMType.VOID},
			argdata={{EVMType.FLOAT}},
			func=apiClearDepth
		},
        {
			name="clearStencil",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiClearStencil
		},
		{
			name="collide",
			type_info={EVMType.INT},
			argdata={
				{EVMType.VOID + EVMType.POINTER},
				{EVMType.VOID + EVMType.POINTER}
			},
			func=apiCollide
		},
        {
			name="colorMask",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiColorMask
		},
        {
			name="cos",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiCos
		},
        {
			name="cullMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiCullMode
		},
        {
			name="deg",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiDeg
		},
        {
			name="depthFunc",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiDepthFunc
		},
        {
			name="depthMask",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiDepthMask
		},
		{
			name="depthTest",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiDepthTest
		},
        {
			name="drawObj",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT}
			},
			func=apiDrawObj
		},
		{
			name="drawObjEx",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiDrawObjEx
		},
        {
			name="endMesh",
			type_info={EVMType.VOID},
			func=apiEndMesh
		},
        {
			name="floor",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiFloor
		},
        {
			name="fogColor",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiFogColor
		},
        {
			name="fogEnd",
			type_info={EVMType.VOID},
			argdata={{EVMType.FLOAT}},
			func=apiFogEnd
		},
        {
			name="fogMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiFogMode
		},
        {
			name="fogStart",
			type_info={EVMType.VOID},
			argdata={{EVMType.FLOAT}},
			func=apiFogStart
		},
        {
			name="fract",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiFract
		},
		{
			name="free",
			type_info={EVMType.VOID},
			argdata={{EVMType.VOID + EVMType.POINTER}},
			func=apiFree
		},
        {
			name="frustum",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiFrustum
		},
        {
			name="getCam2D",
			type_info={EVMType.STRUCT + EVMType.POINTER, cam2d_struct},
			argdata={{EVMType.INT}},
			func=apiGetCam2D
		},
        {
			name="getCam3D",
			type_info={EVMType.STRUCT + EVMType.POINTER, cam3d_struct},
			argdata={{EVMType.INT}},
			func=apiGetCam3D
		},
        {
			name="getLight",
			type_info={EVMType.STRUCT + EVMType.POINTER, light_struct},
			argdata={{EVMType.INT}},
			func=apiGetLight
		},
        {
			name="getModelViewMatrix",
			type_info={EVMType.STRUCT, matrix_struct},
			func=apiGetModelViewMatrix
		},
        {
			name="getMouseDelta",
			type_info={EVMType.VEC2, self.struct_vec2},
			func=apiGetMouseDelta
		},
		{
			name="getMouseDrag",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={{EVMType.INT}},
			func=apiGetMouseDrag
		},
        {
			name="getMouseLock",
			type_info={EVMType.INT},
			func=apiGetMouseLock
		},
        {
			name="getMousePosition",
			type_info={EVMType.VEC2, self.struct_vec2},
			func=apiGetMousePosition
		},
        {
			name="getMouseWheel",
			type_info={EVMType.INT},
			func=apiGetMouseWheel
		},
        {
			name="getProjectionMatrix",
			type_info={EVMType.STRUCT, matrix_struct},
			func=apiGetProjectionMatrix
		},
        {
			name="getRaycastNormal",
			type_info={EVMType.VEC3, self.struct_vec3},
			func=apiGetRaycastNormal
		},
		{
			name="getRaycastPoint",
			type_info={EVMType.VEC3, self.struct_vec3},
			func=apiGetRaycastPoint
		},
        {
			name="getTopMatrix",
			type_info={EVMType.STRUCT, matrix_struct},
			func=apiGetTopMatrix
		},
        {
			name="getTrackBPM",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiGetTrackBPM
		},
        {
			name="getTrackPan",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiGetTrackPan
		},
        {
			name="getTrackVolume",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiGetTrackVolume
		},
        {
			name="held",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiHeld
		},
        {
			name="identity",
			type_info={EVMType.VOID},
			func=apiIdentity
		},
        {
			name="initMemCard",
			type_info={EVMType.VOID},
			argdata={{EVMType.STRING, self.struct_string}},
			func=apiInitMemCard
		},
        {
			name="lightingMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiLightingMode
		},
        {
			name="loadObjBank",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiLoadObjBank
		},
		{
			name="loadSeqBank",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiLoadSeqBank
		},
		{
			name="loadTexBank",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiLoadTexBank
		},
		{
			name="loadWavBank",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiLoadWavBank
		},
		{
			name="lookAt",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiLookAt
		},
        {
			name="matrixAdd",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixAdd
		},
        {
			name="matrixIdentity",
			type_info={EVMType.STRUCT, matrix_struct},
			func=apiMatrixIdentity
		},
        {
			name="matrixInvert",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={{EVMType.STRUCT, matrix_struct}},
			func=apiMatrixInvert
		},
		{
			name="matrixLookAt",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixLookAt
		},
        {
			name="matrixMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiMatrixMode
		},
        {
			name="matrixMultiply",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixMultiply
		},
        {
			name="matrixRotate",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixRotate
		},
		{
			name="matrixScale",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixScale
		},
        {
			name="matrixSubtract",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixSubtract
		},
		{
			name="matrixTranslate",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={
				{EVMType.STRUCT, matrix_struct},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixTranslate
		},
		{
			name="matrixTranspose",
			type_info={EVMType.STRUCT, matrix_struct},
			argdata={{EVMType.STRUCT, matrix_struct}},
			func=apiMatrixTranspose
		},
		{
			name="maxf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiMaxf
		},
		{
			name="maxi",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiMaxi
		},
		{
			name="memcpy",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.VOID + EVMType.POINTER},
				{EVMType.VOID + EVMType.POINTER},
				{EVMType.INT}
			},
			func=apiMemcpy
		},
		{
			name="memset",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.VOID + EVMType.POINTER},
				{EVMType.VOID + EVMType.INT},
				{EVMType.INT}
			},
			func=apiMemset
		},
		{
			name="meshColor",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiMeshColor
		},
		{
			name="meshNormal",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiMeshNormal
		},
		{
			name="meshUV",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiMeshUV
		},
		{
			name="meshVertex",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiMeshVertex
		},
		{
			name="meshVertex2D",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiMeshVertex2D
		},
		{
			name="midf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiMidf
		},
		{
			name="midi",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiMidi
		},
		{
			name="minf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiMinf
		},
		{
			name="mini",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiMini
		},
		{
			name="mouseDragging",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiMouseDragging
		},
		{
			name="mouseHeld",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiMouseHeld
		},
		{
			name="mousePressed",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiMousePressed
		},
		{
			name="mouseReleased",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiMouseReleased
		},
		{
			name="multiplyTopMatrix",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiMultiplyTopMatrix
		},
		{
			name="muteTrack",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiMuteTrack
		},
		{
			name="muteTracks",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiMuteTracks
		},
		{
			name="ortho",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiOrtho
		},
		{
			name="pauseTrack",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiPauseTrack
		},
		{
			name="pauseTracks",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiPauseTracks
		},
		{
			name="peek32",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiPeek32
		},
		{
			name="peek8",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiPeek8
		},
		{
			name="playPattern",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiPlayPattern
		},
		{
			name="playSong",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiPlaySong
		},
		{
			name="playTrack",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiPlayTrack
		},
		{
			name="playWav",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.FLOAT},
				{EVMType.INT}
			},
			func=apiPlayWav
		},
		{
			name="playWavEx",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.FLOAT},
				{EVMType.INT}
			},
			func=apiPlayWavEx
		},
		{
			name="poke32",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiPoke32
		},
		{
			name="poke8",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiPoke8
		},
		{
			name="polygonMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiPolygonMode
		},
		{
			name="popMatrix",
			type_info={EVMType.VOID},
			func=apiPopMatrix
		},
		{
			name="powf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiPowf
		},
		{
			name="pressed",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiPressed
		},
		{
			name="print2D",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.STRING, self.struct_string}
			},
			is_varargs=true,
			varargs_index=4,
			func=apiPrint2D
		},
		{
			name="pushMatrix",
			type_info={EVMType.VOID},
			func=apiPushMatrix
		},
		{
			name="rad",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiRad
		},
		{
			name="randf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiRandf
		},
		{
			name="randfEx",
			type_info={EVMType.FLOAT},
			func=apiRandfEx
		},
		{
			name="randi",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiRandi
		},
		{
			name="randiEx",
			type_info={EVMType.INT},
			func=apiRandiEx
		},
		{
			name="randomize",
			type_info={EVMType.VOID},
			func=apiRandomize
		},
		{
			name="randomizeEx",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiRandomizeEx
		},
		{
			name="raycast",
			type_info={EVMType.INT},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.FLOAT},
				{EVMType.VOID + EVMType.POINTER}
			},
			func=apiRaycast
		},
		{
			name="realloc",
			type_info={EVMType.VOID + EVMType.POINTER},
			argdata={
				{EVMType.VOID + EVMType.POINTER},
				{EVMType.INT},
			},
			func=apiRealloc
		},
		{
			name="released",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiReleased
		},
		{
			name="repeated",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiRepeated
		},
		{
			name="resumeTrack",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiResumeTrack
		},
		{
			name="resumeTracks",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiResumeTracks
		},
		{
			name="rotate",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiRotate
		},
		{
			name="round",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiRound
		},
		{
			name="scale",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiScale
		},
		{
			name="scissor",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiScissor
		},
		{
			name="scissorMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiScissorMode
		},
		{
			name="setModelViewMatrix",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiSetModelViewMatrix
		},
		{
			name="setMouseLock",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiSetMouseLock
		},
		{
			name="setProjectionMatrix",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.STRUCT, matrix_struct}
			},
			func=apiSetProjectionMatrix
		},
		{
			name="setTrackBPM",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiSetTrackBPM
		},
		{
			name="setTrackPan",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiSetTrackPan
		},
		{
			name="setTrackVolume",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiSetTrackVolume
		},
		{
			name="signf",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiSignf
		},
		{
			name="signi",
			type_info={EVMType.INT},
			argdata={{EVMType.INT}},
			func=apiSigni
		},
		{
			name="sin",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.FLOAT}},
			func=apiSin
		},
		{
			name="sprite2D",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiSprite2D
		},
		{
			name="sprite2DEx",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiSprite2DEx
		},
		{
			name="stencilFunc",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiStencilFunc
		},
		{
			name="stencilMask",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiStencilMask
		},
		{
			name="stencilMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiStencilMode
		},
		{
			name="stencilOp",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiStencilOp
		},
		{
			name="stopTrack",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiStopTrack
		},
		{
			name="stopTracks",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiStopTracks
		},
		{
			name="strcat",
			type_info={EVMType.STRING, self.struct_string},
			argdata={
				{EVMType.STRING, self.struct_string},
				{EVMType.STRING, self.struct_string}
			},
			func=apiStrcat
		},
		{
			name="strdup",
			type_info={EVMType.STRING, self.struct_string},
			argdata={{EVMType.STRING, self.struct_string}},
			func=apiStrdup
		},
		{
			name="texture",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiTexture
		},
		{
			name="textureMode",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiTextureMode
		},
		{
			name="time",
			type_info={EVMType.FLOAT},
			func=apiTime
		},
		{
			name="translate",
			type_info={EVMType.VOID},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiTranslate
		},
		{
			name="unmuteTrack",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiUnmuteTrack
		},
		{
			name="unmuteTracks",
			type_info={EVMType.VOID},
			argdata={{EVMType.INT}},
			func=apiUnmuteTracks
		},
		{
			name="vargc",
			type_info={EVMType.INT},
			func=apiVargc
		},
		{
			name="vargv",
			type_info={EVMType.VOID + EVMType.POINTER},
			argdata={{EVMType.INT}},
			func=apiVargv
		},
		{
			name="vec2Angle",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Angle
		},
		{
			name="vec2Cross",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Cross
		},
		{
			name="vec2Direction",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Direction
		},
		{
			name="vec2Distance",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Distance
		},
		{
			name="vec2DistanceSq",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2DistanceSq
		},
		{
			name="vec2Dot",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Dot
		},
		{
			name="vec2Invert",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Invert
		},
		{
			name="vec2Length",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Length
		},
		{
			name="vec2LengthSq",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiVec2LengthSq
		},
		{
			name="vec2Lerp",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.FLOAT}
			},
			func=apiVec2Lerp
		},
		{
			name="vec2MoveToward",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.FLOAT}
			},
			func=apiVec2MoveToward
		},
		{
			name="vec2Normalize",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={{EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Normalize
		},
		{
			name="vec2Reflect",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Reflect
		},
		{
			name="vec2Rotate",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC2, self.struct_vec2},
				{EVMType.FLOAT}
			},
			func=apiVec2Rotate
		},
		{
			name="vec3Angle",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Angle
		},
		{
			name="vec3Cross",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Cross
		},
		{
			name="vec3Direction",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Direction
		},
		{
			name="vec3Distance",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Distance
		},
		{
			name="vec3DistanceSq",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3DistanceSq
		},
		{
			name="vec3Dot",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Dot
		},
		{
			name="vec3Invert",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Invert
		},
		{
			name="vec3Length",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Length
		},
		{
			name="vec3LengthSq",
			type_info={EVMType.FLOAT},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiVec3LengthSq
		},
		{
			name="vec3Lerp",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.FLOAT}
			},
			func=apiVec3Lerp
		},
		{
			name="vec3MoveToward",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.FLOAT}
			},
			func=apiVec3MoveToward
		},
		{
			name="vec3Normalize",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={{EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Normalize
		},
		{
			name="vec3Reflect",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Reflect
		},
		{
			name="vec3Rotate",
			type_info={EVMType.VEC3, self.struct_vec3},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.FLOAT}
			},
			func=apiVec3Rotate
		},
		{
			name="vec3ToScreen",
			type_info={EVMType.VEC2, self.struct_vec2},
			argdata={
				{EVMType.VEC3, self.struct_vec3},
				{EVMType.INT}
			},
			func=apiVec3ToScreen
		},
		{
			name="viewport",
			type_info={EVMType.VOID},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiViewport
		},
		{
			name="wrapf",
			type_info={EVMType.FLOAT},
			argdata={
				{EVMType.FLOAT},
				{EVMType.FLOAT},
				{EVMType.FLOAT}
			},
			func=apiWrapf
		},
		{
			name="wrapi",
			type_info={EVMType.INT},
			argdata={
				{EVMType.INT},
				{EVMType.INT},
				{EVMType.INT}
			},
			func=apiWrapi
		}
    }

	self.api_ids:reserve(#api_ids)
	for i = 0, < #api_ids do
		local id: *Identifier = new(@Identifier)
		$id = api_ids[i]
		id.token = Token.ID
		id.class = Class.API
		id.index = i
		self.api_ids[id.name] = id
		self.api_funcs[i] = id.func
	end
end
