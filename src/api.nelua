require("e3d")

function e3d.EVM:getArgI(i: uint16): int32 <forwarddecl> end
function e3d.EVM:getArgU(i: uint16): uint32 <forwarddecl> end
function e3d.EVM:getArgF(i: uint16): float32 <forwarddecl> end
function e3d.EVM:getArgV2(i: uint16): rl.vector2 <forwarddecl> end
function e3d.EVM:getArgV3(i: uint16): rl.vector3 <forwarddecl> end
function e3d.EVM:getArgStr(i: uint16): e3d.EVMString <forwarddecl> end
function e3d.EVM:pushI(val: int32): void <forwarddecl> end
function e3d.EVM:pushU(val: uint32): void <forwarddecl> end
function e3d.EVM:pushF(val: float32): void <forwarddecl> end
function e3d.EVM:pushV2(val: rl.vector2): void <forwarddecl> end
function e3d.EVM:pushV3(val: rl.vector3): void <forwarddecl> end
function e3d.EVM:pushStr(val: e3d.EVMString): void <forwarddecl> end

function e3d.EVM:getMem8(addr: uint32): uint8 <forwarddecl> end
function e3d.EVM:setMem8(addr: uint32, val: uint8): boolean <forwarddecl> end
function e3d.EVM:getMem32(addr: uint32): uint32 <forwarddecl> end
function e3d.EVM:setMem32(addr: uint32, val: uint32): boolean <forwarddecl> end

--[[
	API FUNCTIONS TO IMPLEMENT:
	
	// math
	bool feq(float a, float b);
	// ... ?
	
	// basic graphics
	void print3d(vec3 pos, string fmt, ...);
	
	// advanced graphics
	// ortho(), etc.?
	void normal(vec3 norm);
	
	// lighting
	void lightmode(int mode);
	void light(???);
	void ambient(???);
	
	// memory
	void* alloc(int size);
	void* alloc(int size);
	void* realloc(void* ptr, int size);
	void free(void* ptr);
	string strdup(string str);
	string strcat(string a, string b);
	string strfmt(string fmt, ...);
	
	// i/o
	// ...
]]

-- DEBUG API FUNCTIONS (TODO: remove)

local function apiHalt(vm: *e3d.EVM): boolean
	vm.error = "- PROGRAM HALTED -\n"
	return false
end

-- API FUNCTIONS:

-- getMem8() helper function for apiPrint2D()
local function getMem8(vm: *e3d.EVM, addr: uint32, c: *uint8): boolean
	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
		return false
	end

	$c = vm:getMem8(addr)

	return true
end

-- getMem32() helper function for apiPrint2D()
local function getMem32(vm: *e3d.EVM, addr: uint32, v: *uint32): boolean
	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", addr)
		return false
	end

	$v = vm:getMem32(addr)

	return true
end

-- vargv() helper function.
-- gets vargv() for the *api* function
local function vargv(vm: *e3d.EVM, offset: uint32): uint32
	vm.cf.vargc = vm.cf.vargc - offset
	
	-- get adress vargp currently points to
	local addr: uint32 = e3d.ARGS_START_ADDR + ((vm.ap + vm.cf.vargp) * 4)

	-- offset vararg pointer
	vm.cf.vargp = vm.cf.vargp + offset

	return addr
end

local function apiPrint2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void print2D(int x, int y, int color, string fmt, ...);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local col: uint32 = vm:getArgU(2)
	local fmt: e3d.EVMString = vm:getArgStr(3)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return true
	end

	local cur_x: int32 = x
	local start_addr: uint32 = fmt.data
	local arg_addr: uint32
	local addr: uint32
	local arg_val0: e3d.EVMValue
	local arg_val1: e3d.EVMValue
	local arg_val2: e3d.EVMValue
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	-- setup varargs
	vm.cf.vargp = vm.ap + 5
	vm.cf.vargc = vm.cf.argc - 5
	vm.cf.vargf = true

	local i: uinteger = 0
	while i < fmt.len do
		local c: uint8

		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return true
		end

		addr = start_addr + i

		if not getMem8(vm, addr, &c) then return false end
		
		if c == '%'_u8 then
			if not getMem8(vm, addr + 1, &c) then return false end

			switch c do
				case 'i'_u8, 'd'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = string.format("RUNTIME ERROR: insufficient vararg bytes for format specifier `%%%c`\n", c)
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.i)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'u'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%i`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'x'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%x`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08x", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'X'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%X`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08X", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'f'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%f`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%.2f", arg_val0.f)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'v'_u8 then
					if not getMem8(vm, addr + 2, &c) then return false end

					switch c do
						case '2'_u8 then
							if vm.cf.vargc < 2 then
								vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%v2`\n"
								return false
							end
		
							arg_addr = vargv(vm, 2)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f)", arg_val0.f, arg_val1.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						case '3'_u8 then
							if vm.cf.vargc < 3 then
								vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%v3`\n"
								return false
							end
		
							arg_addr = vargv(vm, 3)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
							if not getMem32(vm, arg_addr + 8, &arg_val2.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f, %.2f)", arg_val0.f, arg_val1.f, arg_val2.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						else
							vm.error = string.format("RUNTIME ERROR: invalid format specifier `%%v%c`\n", c)
							return false
					end
				else
					vm.error = string.format("RUNTIME ERROR: invalid format specifier `%%%c`\n", c)
					return false
			end
		elseif c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			vm.gpu:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end

	return true
end

local function apiVargc(vm: *e3d.EVM): boolean
	-- signature:
	-- int vargc();

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("RUNTIME ERROR (DEBUG): cannot call vargc() with empty callstack\n")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *e3d.CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("RUNTIME ERROR: cannot call vargc() from non-vararg function\n")
		return false
	end

	vm:pushU(frame.vargc * 4) -- return number of vararg bytes to allow use of sizeof()

	return true
end

local function apiVargv(vm: *e3d.EVM): boolean
	-- signature:
	-- void* vargv(int offset);

	local offset: uint32 = vm:getArgU(0) /// 4 -- offset is given in bytes to allow easy use of sizeof()

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("RUNTIME ERROR (DEBUG): cannot call vargv() with empty callstack\n")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *e3d.CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("RUNTIME ERROR: cannot call vargv() from non-vararg function\n")
		return false
	end

	if frame.vargc == 0 then
		vm.error = string.format("RUNTIME ERROR: vargv() called after end of varargs\n")
		return false
	end

	if offset > frame.vargc then
		vm.error = string.format("RUNTIME ERROR: vararg count exceeded by %d word(s)\n", offset - frame.vargc)
		return false
	end

	frame.vargc = frame.vargc - offset
	
	-- get ap of the function we called from
	local ap: uinteger = (vm.asp - vm.cf.argc) - frame.argc
	
	-- return adress vargp currently points to
	vm:pushU(e3d.ARGS_START_ADDR + ((ap + frame.vargp) * 4))

	-- offset vararg pointer
	frame.vargp = frame.vargp + offset

	return true
end

local function apiPressed(vm: *e3d.EVM): boolean
	local b: uint32 = vm:getArgU(0)
	local p: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyPressed(code) and 1 or 0)
	end
	
	return true
end

local function apiReleased(vm: *e3d.EVM): boolean
	local b: uint32 = vm:getArgU(0)
	local p: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyReleased(code) and 1 or 0)
	end
	
	return true
end

local function apiHeld(vm: *e3d.EVM): boolean
	local b: uint32 = vm:getArgU(0)
	local p: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyDown(code) and 1 or 0)
	end
	
	return true
end

local function apiMini(vm: *e3d.EVM): boolean
	-- signature:
	-- int mini(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMaxi(vm: *e3d.EVM): boolean
	-- signature:
	-- int maxi(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMidi(vm: *e3d.EVM): boolean
	-- signature:
	-- int midi(int a, int b, int c);

	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	local c: int32 = vm:getArgI(2)

	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	if c < b then
		local t: int32 = c
		c = b
		b = t
	end
	if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	
	vm:pushI(b)

	return true
end

local function apiWrapi(vm: *e3d.EVM): boolean
	-- signature:
	-- int wrapi(int x, int min, int max);

	local x: int32 = vm:getArgI(0)
	local min: int32 = vm:getArgI(1)
	local max: int32 = vm:getArgI(2)
	
	if min == max then
        vm:pushI(min)
		return true
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    vm:pushI(min + ((temp + ((x - min) %%% temp)) %%% temp))
	
	return true
end

local function apiMinf(vm: *e3d.EVM): boolean
	-- signature:
	-- int minf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a < b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMaxf(vm: *e3d.EVM): boolean
	-- signature:
	-- int maxf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a > b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMidf(vm: *e3d.EVM): boolean
	-- signature:
	-- int midf(float a, float b, float c);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)
	local c: float32 = vm:getArgF(2)

	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	if c < b then
	    local t: float32 = c
	    c = b
	    b = t
	end
	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	
	vm:pushF(b)

	return true
end

local function apiWrapf(vm: *e3d.EVM): boolean
	-- signature:
	-- float wrapf(float x, float min, float max);

	local x: float32 = vm:getArgF(0)
	local min: float32 = vm:getArgF(1)
	local max: float32 = vm:getArgF(2)
	
	if min == max then
        vm:pushF(min)
		return true
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    vm:pushF(min + ((temp + ((x - min) %%% temp)) %%% temp))
	
	return true
end

local function apiSigni(vm: *e3d.EVM): boolean
	local x: int32 = vm:getArgI(0)

	vm:pushI(math.sign(x))

	return true
end

local function apisignf(vm: *e3d.EVM): boolean
	local x: float32 = vm:getArgF(0)

	vm:pushF(math.sign(x))

	return true
end

local function apiFract(vm: *e3d.EVM): boolean
	local x: float32 = vm:getArgF(0)

	vm:pushF(math.fract(x))

	return true
end

local function apiDeg(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.deg(v))

	return true
end

local function apiRad(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.rad(v))

	return true
end

local function apiSin(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.sin(v))

	return true
end

local function apiCos(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.cos(v))

	return true
end

local function apiFloor(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.floor(v))

	return true
end

local function apiCeil(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.ceil(v))

	return true
end

local function apiRound(vm: *e3d.EVM): boolean
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.round(v))

	return true
end

local function apiRandomize(vm: *e3d.EVM): boolean
	math.randomseed()

	return true
end

local function apiRandomizeEx(vm: *e3d.EVM): boolean
	local seed: uint32 = vm:getArgU(0)

	math.randomseed(seed)

	return true
end

local function apiRandi(vm: *e3d.EVM): boolean
	local min: int32 = vm:getArgI(0)
	local max: int32 = vm:getArgI(1)

	if max < min then
		min, max = max, min
	end

	vm:pushI(math.random(min, max))

	return true
end

local function apiRandiEx(vm: *e3d.EVM): boolean
	vm:pushI(math.random(0)) -- get int will all random bits

	return true
end

local function apiRandf(vm: *e3d.EVM): boolean
	local min: float32 = vm:getArgF(0)
	local max: float32 = vm:getArgF(1)

	if max < min then
		min, max = max, min
	end

	local x: float32 = math.random() -- gets a float in [0, 1)

	vm:pushF(min + x * (max - min))

	return true
end

local function apiRandfEx(vm: *e3d.EVM): boolean
	vm:pushF(math.random())

	return true
end

local function apiTime(vm: *e3d.EVM): boolean
	vm:pushF((@float32)(rl.getTime() - vm.init_time))
	
	return true
end

local function apiVec2Len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Len(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(math.sqrt(v.x * v.x + v.y * v.y))

	return true
end

local function apiVec2LenSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LenSq(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(v.x * v.x + v.y * v.y)

	return true
end

local function apiVec2Norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Norm(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	local l: float32 = v.x * v.x + v.y * v.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
	end

	vm:pushV2(v)

	return true
end

local function apiVec2Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Dot(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.x + a.y * b.y)

	return true
end

local function apiVec2Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Cross(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.y - a.y * b.x)

	return true
end

local function apiVec2Dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Dist(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)))
	
	return true
end

local function apiVec2DistSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2DistSq(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	
	vm:pushF((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
	
	return true
end

local function apiVec2Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Direction(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local direction: rl.vector2 = b - a;

	local l: float32 = direction.x * direction.x + direction.y * direction.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
	end

	vm:pushV2(direction)

	return true
end

local function apiVec2Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Angle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.atan2(b.y - a.y, b.x - a.x))

	return true
end

local function apiVec2LineAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LineAngle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(rl.vector2LineAngle(a, b))

	return true
end

local function apiVec2Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Lerp(vec2 a, vec2 b, float amount);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local amount: float32 = vm:getArgF(4)

	a:lerp(b, amount)

	vm:pushV2(a)

	return true
end

local function apiVec2Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Reflect(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	a:reflect(b)
	
	vm:pushV2(a)
	
	return true
end

local function apiVec2Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Rotate(vec2 v, float angle);

	local v: rl.vector2 = vm:getArgV2(0)
	local angle: float32 = vm:getArgF(2)

	v:rotate(angle)
	
	vm:pushV2(v)

	return true
end

local function apiVec2MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2MoveToward(vec2 a, vec2 b, float delta);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local delta: float32 = vm:getArgF(4)

	local dest: rl.vector2 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV2(b)
	else
		local temp: rl.vector2 = {
			dest.x / length * delta,
			dest.y / length * delta
		}
		vm:pushV2(a + temp)
	end

	return true
end

local function apiVec2Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Invert(vec2 v);
	
	local v: rl.vector2 = vm:getArgV2(0)

	v:invert()

	vm:pushV2(v)

	return true
end

local function apiVec3Len(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Len(vec3 v);
	
	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3LenSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3LenSq(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Norm(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Norm(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	vm:pushV3(v)
	
	return true
end

local function apiVec3Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Dot(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(a.x * b.x + a.y * b.y + a.z * b.z)
	
	return true
end

local function apiVec3Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Cross(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	local v: rl.vector3 = {
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	}

	vm:pushV3(v)
	
	return true
end

local function apiVec3Dist(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Dist(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3DistSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3DistSq(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec3Direction(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local direction: rl.vector3 = b - a;

	local x: float32 = direction.x * direction.x
	local y: float32 = direction.y * direction.y
	local z: float32 = direction.z * direction.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
		direction.z = direction.z / l
	end

	vm:pushV3(direction)

	return true
end

local function apiVec3Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Angle(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(a:angle(b))

	return true
end
local function apiVec3Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Lerp(vec3 a, vec3 b, float amount);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local amount: float32 = vm:getArgF(6)

	a:lerp(b, amount)
	
	vm:pushV3(a)

	return true
end
local function apiVec3Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Reflect(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	a:reflect(b)
	
	vm:pushV3(a)

	return true
end
local function apiVec3Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Rotate(vec3 v, vec3 axis, float angle);

	local v: rl.vector3 = vm:getArgV3(0)
	local axis: rl.vector3 = vm:getArgV3(3)
	local angle: float32 = vm:getArgF(6)

	v:rotateByAxisAngle(axis, angle)
	
	vm:pushV3(v)

	return true
end
local function apiVec3MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3MoveToward(vec3 a, vec3 b, float delta);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local delta: float32 = vm:getArgF(6)

	local dest: rl.vector3 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV3(b)
	else
		local temp: rl.vector3 = {
			dest.x / length * delta,
			dest.y / length * delta,
			dest.z / length * delta
		}
		vm:pushV3(a + temp)
	end

	return true
end
local function apiVec3Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Invert(vec3 a);

	local v: rl.vector3 = vm:getArgV3(0)

	v:invert()
	
	vm:pushV3(v)

	return true
end

local function apiCamera2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera2D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera2D(id)

	return true
end

local function apiGetCam2DOrigin(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 getCam2DOrigin(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV2(vm.gpu.cameras2D[id].offset)

	return true
end

local function apiSetCam2DOrigin(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DOrigin(int id, vec2 origin);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local origin: rl.vector2 = vm:getArgV2(1)

	vm.gpu.cameras2D[id].offset = origin

	return true
end

local function apiGetCam2DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 getCam2DTarget(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV2(vm.gpu.cameras2D[id].target)

	return true
end

local function apiSetCam2DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DTarget(int id, vec2 target);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local target: rl.vector2 = vm:getArgV2(1)

	vm.gpu.cameras2D[id].target = target

	return true
end

local function apiGetCam2DAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam2DAngle(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras2D[id].rotation)

	return true
end

local function apiSetCam2DAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DAngle(int id, float angle);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local angle: float32 = vm:getArgF(1)

	vm.gpu.cameras2D[id].rotation = angle

	return true
end

local function apiGetCam2DZoom(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam2DZoom(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras2D[id].zoom)

	return true
end

local function apiSetCam2DZoom(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DZoom(int id, float zoom);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local zoom: float32 = vm:getArgF(1)

	vm.gpu.cameras2D[id].zoom = zoom

	return true
end

local function apiCamera3D(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera3D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera3D(id)

	return true
end

local function apiGetCam3DPos(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DPos(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].position)

	return true
end

local function apiSetCam3DPos(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DPos(int id, vec3 pos);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local pos: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].position = pos

	return true
end

local function apiGetCam3DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DTarget(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].target)

	return true
end

local function apiSetCam3DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DTarget(int id, vec3 target);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local target: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].target = target

	return true
end

local function apiGetCam3DUp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DUp(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].up)

	return true
end

local function apiSetCam3DUp(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DUp(int id, vec3 up);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local up: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].up = up

	return true
end

local function apiGetCam3DFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam3DFOV(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras[id].fovy)

	return true
end

local function apiSetCam3DFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DFOV(int id, float fov);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local fov: float32 = vm:getArgF(1)

	vm.gpu.cameras[id].fovy = fov

	return true
end

local function apiGetCam3DProj(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCam3DProj(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushI((@int32)(vm.gpu.cameras[id].projection))

	return true
end

local function apiSetCam3DProj(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DProj(int id, int mode);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local proj: float32 = vm:getArgI(1)

	vm.gpu.cameras[id].projection = (@cint)(math.clamp(proj, 0, 1))

	return true
end

local function v3Norm(v: rl.vector3): rl.vector3
	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	return v
end

local function apiGetCam3DRight(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DRight(int id);

	-- get camera
	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	-- calculate forward vector
	local forward: rl.vector3 = v3Norm({
			cam.target.x - cam.position.x,
			cam.target.y - cam.position.y,
			cam.target.z - cam.position.z
		}
	)

	-- get normalized up vector
    local up: rl.vector3 = v3Norm(cam.up)

	-- calculate cross of forward and up
	vm:pushV3({
			(forward.y * up.z) - (forward.z * up.y),
			(forward.z * up.x) - (forward.x * up.z),
			(forward.x * up.y) - (forward.y * up.x)
		}
	)

	return true
end

local function apiGetCam3DForward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DForward(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	vm:pushV3(
		v3Norm({
				cam.target.x - cam.position.x,
				cam.target.y - cam.position.y,
				cam.target.z - cam.position.z
			}
		)
	)

	return true
end

local function apiGetTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getTextureMode();

	vm:pushI((@int32)(vm.gpu.tex_mode))

	return true
end

local function apiSetTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setTextureMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid texture mode `%d`", mode)
		return false
	end

	vm.gpu.tex_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.tex_mode_loc, &vm.gpu.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function apiGetCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCullMode();

	vm:pushI((@int32)(vm.gpu.cull_mode))

	return true
end

local function apiSetCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCullMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	rlgl.drawRenderBatchActive()

	switch mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		case 2 then
			rlgl.disableBackfaceCulling()
		else
			vm.error = string.format("RUNTIME ERROR: attempt to set invalid cull mode `%d`", mode)
			return false
	end

	vm.gpu.cull_mode = mode

	return true
end

local function apiGetWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getWireMode();

	vm:pushI(vm.gpu.wire_mode and 1 or 0)

	return true
end

local function apiSetWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setWireMode(int mode);
	
	local enable: boolean = vm:getArgU(0) ~= 0
	
	rlgl.drawRenderBatchActive()
	
	if enable then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	vm.gpu.wire_mode = enable

	return true
end

local function apiGetFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogMode();

	vm:pushI((@int32)(vm.gpu.fog_mode))

	return true
end

local function apiSetFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode ~= 0 then
		mode = 1
	end

	vm.gpu.fog_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_mode_loc, &vm.gpu.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function apiGetFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogStart();

	vm:pushF(vm.gpu.fog_start)

	return true
end

local function apiSetFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogStart(float start);

	local start: float32 = vm:getArgF(0)

	start = math.clamp(start, 0.0, 1000.0)
	
	vm.gpu.fog_start = start
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_start_loc, &vm.gpu.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	
	return true
end

local function apiGetFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogEnd();

	vm:pushF(vm.gpu.fog_end)

	return true
end

local function apiSetFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogEnd(float end);
	
	local fend: float32 = vm:getArgF(0)
	
	fend = math.clamp(fend, 0.0, 1000.0)
	
	vm.gpu.fog_end = fend
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_end_loc, &vm.gpu.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)

	return true
end

local function apiGetFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogColor();
	
	local ray_col: rl.color = rl.colorFromNormalized(vm.gpu.fog_color)

	local r: uint32 = (@uint32)(ray_col.r)
	local g: uint32 = (@uint32)(ray_col.g)
	local b: uint32 = (@uint32)(ray_col.b)
	local a: uint32 = (@uint32)(ray_col.a)
	
	vm:pushU((r << 24) | (g << 16) | (b << 8) | a)

	return true
end

local function apiSetFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogColor(float color);

	local col: uint32 = vm:getArgU(0)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	vm.gpu.fog_color = rl.colorNormalize(ray_col)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_color_loc, &vm.gpu.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)

	return true
end

local function apiTexture(vm: *e3d.EVM): boolean
	-- signature:
	-- void texture(int x, int y, int w, int h);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local w: int32 = vm:getArgI(2)
	local h: int32 = vm:getArgI(3)

	w = math.clamp(w, 1, 256)
	h = math.clamp(h, 1, 256)
	x = math.clamp(x, 0, 1024 - w)
	y = math.clamp(y, 0, 1024 - h)

	vm.gpu:texture(x, y, w, h)

	return true
end

local function apiClear(vm: *e3d.EVM): boolean
	-- signature:
	-- void clear(int col);

	local col: uint32 = vm:getArgU(0)

	vm.gpu:clear(col)

	return true
end

local function apiViewport(vm: *e3d.EVM): boolean
	-- signature:
	-- void viewport(int x, int y, int w, int h);

	local x: cint = (@cint)(vm:getArgI(0))
	local y: cint = (@cint)(vm:getArgI(1))
	local w: cint = (@cint)(vm:getArgI(2))
	local h: cint = (@cint)(vm:getArgI(3))

	w = math.clamp(w, 1, GPU_VSCREEN_W)
	h = math.clamp(h, 1, GPU_VSCREEN_H)
	x = math.clamp(x, 0, GPU_VSCREEN_W - w)
	y = math.clamp(y, 0, GPU_VSCREEN_H - h)

	y = GPU_VSCREEN_H - (y + h) -- flip y

	vm.gpu.viewport_w = w
	vm.gpu.viewport_h = h

	rlgl.viewport(x, y, w, h)
	rlgl.scissor(x, y, w, h)

	return true
end

local function apiSprite2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2D(int srcx, int srcy, int srcw, int srch, int destx, int desy);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(srcw), (@float32)(srch) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiSprite2DEx(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2DEx(int srcx, int srcy, int srcw, int srch, int destx, int desy, int destw, int desth);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)
	local destw: int32 = vm:getArgI(6)
	local desth: int32 = vm:getArgI(7)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiBeginMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void beginMesh(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid primitive mode `%d`", mode)
		return false
	end

	vm.gpu:beginMesh(mode)
	
	return true
end

local function apiEndMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void endMesh();

	vm.gpu:endMesh()
	
	return true
end

local function apiVertex(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	vm.gpu:vertex(v)
	
	return true
end

local function apiVertex2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertex2D(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm.gpu:vertex2D(v)
	
	return true
end

local function apiVertUV(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertUV(vec2 uv);

	local v: rl.vector2 = vm:getArgV2(0)
	
	vm.gpu:vertUV(v)
	
	return true
end

local function apiVertColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void vertColor(int col);

	local col: uint32 = vm:getArgU(0)
	
	vm.gpu:vertColor(col)
	
	return true
end

-- void normal(vec3 norm);

local function apiMatrixMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void matrixMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > GPU_MODELVIEW then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid primitive mode `%d`", mode)
		return false
	end

	vm.gpu:matrixMode(mode)

	return true
end

local function apiPushMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void pushMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count >= 24 then
			vm.error = "RUNTIME ERROR: projection matrix stack overflow\n"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count + 1
	else
		if vm.gpu.view_matrix_count >= 24 then
			vm.error = "RUNTIME ERROR: view matrix stack overflow\n"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count + 1
	end
	
	rlgl.pushMatrix()
	
	return true
end

local function apiPopMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void popMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count == 0 then
			vm.error = "RUNTIME ERROR: projection matrix stack underflow\n"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count - 1
	else
		if vm.gpu.view_matrix_count == 0 then
			vm.error = "RUNTIME ERROR: view matrix stack underflow\n"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count - 1
	end

	rlgl.popMatrix()
	
	return true
end

local function apiIdentity(vm: *e3d.EVM): boolean
	-- signature:
	-- void identity();

	rlgl.loadIdentity()
	
	return true
end

local function apiTranslate(vm: *e3d.EVM): boolean
	-- signature:
	-- void translate(vec3 pos);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.translatef(v.x, v.y, v.z)
	
	return true
end

local function apiRotate(vm: *e3d.EVM): boolean
	-- signature:
	-- void rotate(vec3 rot);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.rotatef(v.z, 0, 0, 1)
	rlgl.rotatef(v.y, 0, 1, 0)
	rlgl.rotatef(v.x, 1, 0, 0)
	
	return true
end

local function apiScale(vm: *e3d.EVM): boolean
	-- signature:
	-- void scale(vec3 sca);
	
	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.scalef(v.x, v.y, v.z)
	
	return true
end

local function apiPeek8(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek8(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
		return false
	end

	vm:pushU(vm:getMem8(addr))

	return true
end

local function apiPoke8(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke8(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint8 = (@uint8)(vm:getArgU(1) & 0xFF)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte write address 0x%08X\n", addr)
		return false
	end

	if not vm:setMem8(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

local function apiPeek32(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek32(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", addr)
		return false
	end

	vm:pushU(vm:getMem32(addr))

	return true
end

local function apiPoke32(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke32(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint32 = vm:getArgU(1)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word write address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word write address 0x%08X\n", addr)
		return false
	end

	if not vm:setMem32(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write word to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

local function apiMemcpy(vm: *e3d.EVM): boolean
	-- signature:
	-- void memcpy(void* src, void* dest, int nbytes);

	local src: uint32 = vm:getArgU(0)
	local dest: uint32 = vm:getArgU(1)
	local nbytes: uint32 = vm:getArgU(2)

	if src > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy src address 0x%08X\n", src)
		return false
	end

	if src + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy src end address 0x%08X\n", src + (nbytes - 1))
		return false
	end

	if dest > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy dest address 0x%08X\n", dest)
		return false
	end

	if dest + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy dest end address 0x%08X\n", dest + (nbytes - 1))
		return false
	end

	if src == dest then
		return true
	elseif src < dest then
		-- copy from the end
		src = src + (nbytes - 1)
		dest = dest + (nbytes - 1)

		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
				return false
			end

			src = src - 1
			dest = dest - 1
		end
	else
		-- copy from the beginning
		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
				return false
			end

			src = src + 1
			dest = dest + 1
		end
	end

	return true
end

local function apiMemset(vm: *e3d.EVM): boolean
	-- signature:
	-- void memset(void* dest, int nbytes, int value);

	local dest: uint32 = vm:getArgU(0)
	local nbytes: uint32 = vm:getArgU(1)
	local value: uint8 = vm:getArgU(2) & 0xFF

	if dest > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memset dest address 0x%08X\n", dest)
		return false
	end

	if dest + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memset dest end address 0x%08X\n", dest + (nbytes - 1))
		return false
	end

	for i = 0, < nbytes do
		if not vm:setMem8(dest, value) then
			vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
			return false
		end

		dest = dest + 1
	end

	return true;
end

function e3d.EVM:registerBuiltins(): void
	local keyword_ids: []e3d.Identifier = {
		{name="void",     token=e3d.Token.VOID},
		{name="int",      token=e3d.Token.INT},
		{name="float",    token=e3d.Token.FLOAT},
		{name="vec2",     token=e3d.Token.VEC2},
		{name="vec3",     token=e3d.Token.VEC3},
		{name="string",   token=e3d.Token.STRING},
		{name="enum",     token=e3d.Token.ENUM},
		{name="struct",   token=e3d.Token.STRUCT},
		{name="if",       token=e3d.Token.IF},
		{name="else",     token=e3d.Token.ELSE},
		{name="return",   token=e3d.Token.RETURN},
		{name="break",    token=e3d.Token.BREAK},
		{name="continue", token=e3d.Token.CONTINUE},
		{name="sizeof",   token=e3d.Token.SIZEOF},
		{name="for",      token=e3d.Token.FOR},
		{name="while",    token=e3d.Token.WHILE}
	}

	local constant_ids: []e3d.Identifier = {
		{name="true",  type_info={e3d.EVMType.INT},                        const_val=1},
		{name="false", type_info={e3d.EVMType.INT},                        const_val=0},
		{name="null",  type_info={e3d.EVMType.VOID + e3d.EVMType.POINTER}, const_val=e3d.NULL}
	}

	local constructor_ids: []e3d.Identifier = {
		{name="vec2Zero", type_info={e3d.EVMType.VEC2}},
		{name="vec3Zero", type_info={e3d.EVMType.VEC3}}
	}

	self.keywords:reserve(#keyword_ids)
	for i = 0, < #keyword_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = keyword_ids[i]
		id.class = e3d.Class.KEYWORD
		self.keywords[id.name] = id
	end

	self.constants:reserve(#constant_ids)
	for i = 0, < #constant_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constant_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.CONSTANT
		self.constants[id.name] = id
	end

	-- vector construction functions are special cases,
	-- they are translated directly to opcodes
	for i = 0, < #constructor_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constructor_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		self.api_ids[id.name] = id
	end

	-- define vec2 struct
	local sid: *e3d.Struct = new(@e3d.Struct)
	local v2x: *e3d.Identifier = new(@e3d.Identifier)
	local v2y: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec2"
	v2x.name = "x"
	v2x.index = 0
	v2x.type_info = {e3d.EVMType.FLOAT}

	v2y.name = "y"
	v2y.index = 1
	v2y.type_info = {e3d.EVMType.FLOAT}

	sid:addMember(v2x)
	sid:addMember(v2y)
	sid.is_complete = true
	self.struct_vec2 = sid

	-- define vec3 struct
	sid = new(@e3d.Struct)
	local v3x: *e3d.Identifier = new(@e3d.Identifier)
	local v3y: *e3d.Identifier = new(@e3d.Identifier)
	local v3z: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "vec3"
	v3x.name = "x"
	v3x.index = 0
	v3x.type_info = {e3d.EVMType.FLOAT}

	v3y.name = "y"
	v3y.index = 1
	v3y.type_info = {e3d.EVMType.FLOAT}

	v3z.name = "z"
	v3z.index = 2
	v3z.type_info = {e3d.EVMType.FLOAT}

	sid:addMember(v3x)
	sid:addMember(v3y)
	sid:addMember(v3z)
	sid.is_complete = true
	self.struct_vec3 = sid

	-- define string struct
	sid = new(@e3d.Struct)
	local string_len: *e3d.Identifier = new(@e3d.Identifier)
	local string_data: *e3d.Identifier = new(@e3d.Identifier)

	sid.name = "string"
	string_len.name = "len"
	string_len.index = 0
	string_len.type_info = {e3d.EVMType.INT}

	string_data.name = "data"
	string_data.index = 1
	string_data.type_info = {e3d.EVMType.VOID + e3d.EVMType.POINTER}

	sid:addMember(string_len)
	sid:addMember(string_data)
	sid.is_complete = true
	self.struct_string = sid
end

function e3d.EVM:registerAPI(): void
	local api_ids: []e3d.Identifier = {
		{name="halt", type_info={e3d.EVMType.VOID}, func=apiHalt},

		{name="vargc", type_info={e3d.EVMType.INT},                                                             func=apiVargc},
		{name="vargv", type_info={e3d.EVMType.VOID + e3d.EVMType.POINTER}, argdata={{type_id=e3d.EVMType.INT}}, func=apiVargv},
		
		{
			name="pressed",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiPressed
		},
		{
			name="released",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiReleased
		},
		{
			name="held",
			type_info={e3d.EVMType.INT},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiHeld
		},
		
		{name="mini",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=apiMini},
		{name="maxi",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},                            func=apiMaxi},
		{name="midi",  type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=apiMidi},
		{name="wrapi", type_info={e3d.EVMType.INT}, argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}}, func=apiWrapi},

		{name="minf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=apiMinf},
		{name="maxf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}},                              func=apiMaxf},
		{name="midf",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=apiMidf},
		{name="wrapf", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=apiWrapf},
		
		{name="signi", type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}},   func=apiSigni},
		{name="signf", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apisignf},
		{name="fract", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiFract},

		{name="deg",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiDeg},
		{name="rad",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiRad},
		{name="sin",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiSin},
		{name="cos",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiCos},
		{name="floor",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiFloor},
		{name="ceil",   type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiCeil},
		{name="round",  type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiRound},

		{name="randomize",   type_info={e3d.EVMType.VOID},                                                                      func=apiRandomize},
		{name="randomizeEx", type_info={e3d.EVMType.VOID},  argdata={{type_id=e3d.EVMType.INT}},                                func=apiRandomizeEx},
		{name="randi",       type_info={e3d.EVMType.INT},   argdata={{type_id=e3d.EVMType.INT}, {type_id=e3d.EVMType.INT}},     func=apiRandi},
		{name="randiEx",     type_info={e3d.EVMType.INT},                                                                       func=apiRandiEx},
		{name="randf",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.FLOAT}, {type_id=e3d.EVMType.FLOAT}}, func=apiRandf},
		{name="randfEx",     type_info={e3d.EVMType.FLOAT},                                                                     func=apiRandfEx},
		
		{name="time", type_info={e3d.EVMType.FLOAT}, func=apiTime},
		
		{name="vec2Len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=apiVec2Len},
		{name="vec2LenSq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}},                             func=apiVec2LenSq},
		{name="vec2Norm",      type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}},                             func=apiVec2Norm},
		{name="vec2Dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2Dot},
		{name="vec2Cross",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2Cross},
		{name="vec2Dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2Dist},
		{name="vec2DistSq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2DistSq},
		{name="vec2Direction", type_info={e3d.EVMType.VEC2},  argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2Direction},
		{name="vec2Angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2Angle},
		{name="vec2LineAngle", type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}}, func=apiVec2LineAngle},
		{
			name="vec2Lerp",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiVec2Lerp
		},
		{name="vec2Reflect", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.VEC2}},  func=apiVec2Reflect},
		{name="vec2Rotate",  type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}, {type_id=e3d.EVMType.FLOAT}}, func=apiVec2Rotate},
		{
			name="vec2MoveToward",
			type_info={e3d.EVMType.VEC2},
			argdata={
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.VEC2},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiVec2MoveToward
		},
		{name="vec2Invert", type_info={e3d.EVMType.VEC2}, argdata={{type_id=e3d.EVMType.VEC2}}, func=apiVec2Invert},
		
		{name="vec3Len",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=apiVec3Len},
		{name="vec3LenSq",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}},                             func=apiVec3LenSq},
		{name="vec3Norm",      type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}},                             func=apiVec3Norm},
		{name="vec3Dot",       type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3Dot},
		{name="vec3Cross",     type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3Cross},
		{name="vec3Dist",      type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3Dist},
		{name="vec3DistSq",    type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3DistSq},
		{name="vec3Direction", type_info={e3d.EVMType.VEC3},  argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3Direction},
		{name="vec3Angle",     type_info={e3d.EVMType.FLOAT}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}}, func=apiVec3Angle},
		{
			name="vec3Lerp",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiVec3Lerp
		},
		{name="vec3Reflect", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}, {type_id=e3d.EVMType.VEC3}},  func=apiVec3Reflect},
		{
			name="vec3Rotate",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiVec3Rotate
		},
		{
			name="vec3MoveToward",
			type_info={e3d.EVMType.VEC3},
			argdata={
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.VEC3},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiVec3MoveToward
		},
		{name="vec3Invert", type_info={e3d.EVMType.VEC3}, argdata={{type_id=e3d.EVMType.VEC3}}, func=apiVec3Invert},
		
		{name="camera2D", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=apiCamera2D},
		{
			name="getCam2DOrigin",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam2DOrigin
		},
		{
			name="setCam2DOrigin",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=apiSetCam2DOrigin
		},
		{
			name="getCam2DTarget",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam2DTarget
		},
		{
			name="setCam2DTarget",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=apiSetCam2DTarget
		},
		{
			name="getCam2DAngle",
			type_info={e3d.EVMType.FLOAT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam2DAngle
		},
		{
			name="setCam2DAngle",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiSetCam2DAngle
		},
		{
			name="getCam2DZoom",
			type_info={e3d.EVMType.FLOAT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam2DZoom
		},
		{
			name="setCam2DZoom",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiSetCam2DZoom
		},
		{name="camera3D", type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}}, func=apiCamera3D},
		{
			name="getCam3DPos",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DPos
		},
		{
			name="setCam3DPos",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=apiSetCam3DPos
		},
		{
			name="getCam3DTarget",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DTarget
		},
		{
			name="setCam3DTarget",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=apiSetCam3DTarget
		},
		{
			name="getCam3DUp",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DUp
		},
		{
			name="setCam3DUp",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.VEC3}
			},
			func=apiSetCam3DUp
		},
		{
			name="getCam3DFOV",
			type_info={e3d.EVMType.FLOAT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DFOV
		},
		{
			name="setCam3DFOV",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.FLOAT}
			},
			func=apiSetCam3DFOV
		},
		{
			name="getCam3DProj",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DProj
		},
		{
			name="setCam3DProj",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiSetCam3DProj
		},
		{
			name="getCam3DRight",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DRight
		},
		{
			name="getCam3DForward",
			type_info={e3d.EVMType.VEC3},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiGetCam3DForward
		},
		
		{
			name="viewport",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiViewport
		},
		{
			name="texture",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiTexture
		},
		{name="getTextureMode",  type_info={e3d.EVMType.INT},                                         func=apiGetTextureMode},
		{name="setTextureMode",  type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiSetTextureMode},
		{name="getCullMode",     type_info={e3d.EVMType.INT},                                         func=apiGetCullMode},
		{name="setCullMode",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiSetCullMode},
		{name="getWireMode",     type_info={e3d.EVMType.INT},                                         func=apiGetWireMode},
		{name="setWireMode",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiSetWireMode},
		{name="getFogMode",      type_info={e3d.EVMType.INT},                                         func=apiGetFogMode},
		{name="setFogMode",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiSetFogMode},
		{name="getFogStart",     type_info={e3d.EVMType.FLOAT},                                       func=apiGetFogStart},
		{name="setFogStart",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiSetFogStart},
		{name="getFogEnd",       type_info={e3d.EVMType.FLOAT},                                       func=apiGetFogEnd},
		{name="setFogEnd",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.FLOAT}}, func=apiSetFogEnd},
		{name="getFogColor",     type_info={e3d.EVMType.INT},                                         func=apiGetFogColor},
		{name="setFogColor",     type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiSetFogColor},
		{name="matrixMode",      type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiMatrixMode},
		{name="clear",           type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiClear},
		{name="pushMatrix",      type_info={e3d.EVMType.VOID},                                        func=apiPushMatrix},
		{name="popMatrix",       type_info={e3d.EVMType.VOID},                                        func=apiPopMatrix},
		{name="identity",        type_info={e3d.EVMType.VOID},                                        func=apiIdentity},
		{name="translate",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=apiTranslate},
		{name="rotate",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=apiRotate},
		{name="scale",           type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=apiScale},
		{name="vertex",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC3}},  func=apiVertex},
		{name="vertex2D",        type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},  func=apiVertex2D},
		{name="vertUV",          type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.VEC2}},  func=apiVertUV},
		{name="vertColor",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiVertColor},
		{name="beginMesh",       type_info={e3d.EVMType.VOID}, argdata={{type_id=e3d.EVMType.INT}},   func=apiBeginMesh},
		{name="endMesh",         type_info={e3d.EVMType.VOID},                                        func=apiEndMesh},
		{
			name="print2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.STRING}
			},
			is_varargs=true,
			varargs_index=4,
			func=apiPrint2D
		},
		{
			name="sprite2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiSprite2D
		},
		{
			name="sprite2DEx",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiSprite2DEx
		},

		{
			name="peek8",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiPeek8
		},
		{
			name="poke8",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiPoke8
		},
		{
			name="peek32",
			type_info={e3d.EVMType.INT},
			argdata={{type_id=e3d.EVMType.INT}},
			func=apiPeek32
		},
		{
			name="poke32",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.INT},
				{type_id=e3d.EVMType.INT}
			},
			func=apiPoke32
		},
		{
			name="memcpy",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{type_id=e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{type_id=e3d.EVMType.VOID + e3d.EVMType.INT}
			},
			func=apiMemcpy
		},
		{
			name="memset",
			type_info={e3d.EVMType.VOID},
			argdata={
				{type_id=e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{type_id=e3d.EVMType.VOID + e3d.EVMType.INT},
				{type_id=e3d.EVMType.VOID + e3d.EVMType.INT}
			},
			func=apiMemset
		},
	}

	self.api_ids:reserve(#api_ids + 2)
	for i = 0, < #api_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = api_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		id.index = i
		self.api_ids[id.name] = id
		self.api_funcs[i] = id.func
	end
end
