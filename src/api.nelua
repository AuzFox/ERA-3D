require("e3d")

function e3d.EVM:getArgI(i: uint16): int32 <forwarddecl> end
function e3d.EVM:getArgU(i: uint16): uint32 <forwarddecl> end
function e3d.EVM:getArgF(i: uint16): float32 <forwarddecl> end
function e3d.EVM:getArgV2(i: uint16): rl.vector2 <forwarddecl> end
function e3d.EVM:getArgV3(i: uint16): rl.vector3 <forwarddecl> end
function e3d.EVM:getArgStr(i: uint16): e3d.EVMString <forwarddecl> end
function e3d.EVM:getArgMat(i: uint16): rl.matrix <forwarddecl> end
function e3d.EVM:pushI(val: int32): void <forwarddecl> end
function e3d.EVM:pushU(val: uint32): void <forwarddecl> end
function e3d.EVM:pushF(val: float32): void <forwarddecl> end
function e3d.EVM:pushV2(val: rl.vector2): void <forwarddecl> end
function e3d.EVM:pushV3(val: rl.vector3): void <forwarddecl> end
function e3d.EVM:pushStr(val: e3d.EVMString): void <forwarddecl> end
function e3d.EVM:pushMat(val: rl.matrix): void <forwarddecl> end

function e3d.EVM:getMem8(addr: uint32): uint8 <forwarddecl> end
function e3d.EVM:setMem8(addr: uint32, val: uint8): boolean <forwarddecl> end
function e3d.EVM:getMem32(addr: uint32): uint32 <forwarddecl> end
function e3d.EVM:setMem32(addr: uint32, val: uint32): boolean <forwarddecl> end

function e3d.EVM:getMemColAABB(addr: uint32, box: *e3d.ColAABB): boolean <forwarddecl> end

local CollisionFunction: type = @function(*e3d.EVM, uint32, uint32): (boolean, uint32)

local function checkPointPoint(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkPointAABB(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkPointSphere(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkPointCylinder(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkAABBPoint(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkAABBAABB(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	local a: e3d.ColAABB
	local b: e3d.ColAABB
	if not vm:getMemColAABB(a_addr, &a) then return false, 0 end
	if not vm:getMemColAABB(b_addr, &b) then return false, 0 end

	local half_a_width: float32 = a.width / 2
	local half_a_height: float32 = a.height / 2
	local half_a_depth: float32 = a.depth / 2
	local min_a: rl.vector3 = {
		a.position.x - half_a_width,
		a.position.y - half_a_height,
		a.position.z - half_a_depth
	}
	local max_a: rl.vector3 = {
		a.position.x + half_a_width,
		a.position.y + half_a_height,
		a.position.z + half_a_depth
	}

	local half_b_width: float32 = b.width / 2
	local half_b_height: float32 = b.height / 2
	local half_b_depth: float32 = b.depth / 2
	local min_b: rl.vector3 = {
		b.position.x - half_b_width,
		b.position.y - half_b_height,
		b.position.z - half_b_depth
	}
	local max_b: rl.vector3 = {
		b.position.x + half_b_width,
		b.position.y + half_b_height,
		b.position.z + half_b_depth
	}

	if (min_a.x <= max_b.x) and (max_a.x >= min_b.x) and (min_a.y <= max_b.y) and (max_a.y >= min_b.y) and (min_a.z <= max_b.z) and (max_a.z >= min_b.z) then
		return true, 1
	else
		return true, 0
	end
end

local function checkAABBSphere(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkAABBCylinder(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkSpherePoint(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkSphereAABB(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkSphereSphere(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkSphereCylinder(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkCylinderPoint(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkCylinderAABB(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkCylinderSphere(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local function checkCylinderCylinder(vm: *e3d.EVM, a_addr: uint32, b_addr: uint32): (boolean, uint32)
	return true, 0
end

local ColType = @enum {
	POINT = 0,
	AABB,
	SPHERE,
	CYLINDER
}

local collision_type_names: []string = {
	"colpoint",
	"colaabb",
	"colsphere",
	"colcylinder"
}

local collision_functions: [4][4]CollisionFunction = {
	-- point             AABB               sphere               cylinder
	{checkPointPoint   , checkPointAABB   , checkPointSphere   , checkPointCylinder   }, -- point
	{checkAABBPoint    , checkAABBAABB    , checkAABBSphere    , checkAABBCylinder    }, -- AABB
	{checkSpherePoint  , checkSphereAABB  , checkSphereSphere  , checkSphereCylinder  }, -- sphere
	{checkCylinderPoint, checkCylinderAABB, checkCylinderSphere, checkCylinderCylinder}  -- cylinder
}

--[[
	API FUNCTIONS TO IMPLEMENT:
	
	// math
	bool feq(float a, float b);
	// ... ?
	
	// basic graphics
	void print3d(vec3 pos, string fmt, ...);
	
	// memory
	void* alloc(int size);
	void* realloc(void* ptr, int size);
	void free(void* ptr);
	string strdup(string str);
	string strcat(string a, string b);
	string strfmt(string fmt, ...);
	
	// i/o
	initMemoryCard(string id);
	swapCart()?
]]

-- DEBUG API FUNCTIONS (TODO: remove)

local function apiHalt(vm: *e3d.EVM): boolean
	vm.error = "PROGRAM HALTED -\n"
	return false
end

-- API FUNCTIONS:

-- getMem8() helper function for apiPrint2D()
local function getMem8(vm: *e3d.EVM, addr: uint32, c: *uint8): boolean
	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
		return false
	end

	$c = vm:getMem8(addr)

	return true
end

-- getMem32() helper function for apiPrint2D()
local function getMem32(vm: *e3d.EVM, addr: uint32, v: *uint32): boolean
	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", addr)
		return false
	end

	$v = vm:getMem32(addr)

	return true
end

-- vargv() helper function.
-- gets vargv() for the *api* function
local function vargv(vm: *e3d.EVM, offset: uint32): uint32
	vm.cf.vargc = vm.cf.vargc - offset
	
	-- get adress vargp currently points to
	local addr: uint32 = e3d.ARGS_START_ADDR + ((vm.ap + vm.cf.vargp) * 4)

	-- offset vararg pointer
	vm.cf.vargp = vm.cf.vargp + offset

	return addr
end

local function apiPrint2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void print2D(int x, int y, int color, string fmt, ...);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local col: uint32 = vm:getArgU(2)
	local fmt: e3d.EVMString = vm:getArgStr(3)

	if y >= GPU_VSCREEN_H or x >= GPU_VSCREEN_W then
		-- we're off screen, no need to render
		return true
	end

	local cur_x: int32 = x
	local start_addr: uint32 = fmt.data
	local arg_addr: uint32
	local addr: uint32
	local arg_val0: util.IntFloat
	local arg_val1: util.IntFloat
	local arg_val2: util.IntFloat
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	-- setup varargs
	vm.cf.vargp = vm.ap + 5
	vm.cf.vargc = vm.cf.argc - 5
	vm.cf.vargf = true

	local i: uinteger = 0
	while i < fmt.len do
		local c: uint8

		-- stop if we're going offscreen
		if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
			return true
		end

		addr = start_addr + i

		if not getMem8(vm, addr, &c) then return false end
		
		if c == '%'_u8 then
			if not getMem8(vm, addr + 1, &c) then return false end

			switch c do
				case 'i'_u8, 'd'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = string.format("RUNTIME ERROR: insufficient vararg bytes for format specifier `%%%c`\n", c)
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.i)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'u'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%i`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%d", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'x'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%x`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08x", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'X'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%X`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%08X", arg_val0.u)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'f'_u8 then
					if vm.cf.vargc < 1 then
						vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%f`\n"
						return false
					end

					arg_addr = vargv(vm, 1)
					if not getMem32(vm, arg_addr, &arg_val0.u) then return false end

					vm.sb:clear()
					vm.sb:writef("%.2f", arg_val0.f)

					local s: string = vm.sb:view()

					for j = 0, < #s do
						if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
							return true
						end

						vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
					end

					i = i + 1
				case 'v'_u8 then
					if not getMem8(vm, addr + 2, &c) then return false end

					switch c do
						case '2'_u8 then
							if vm.cf.vargc < 2 then
								vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%v2`\n"
								return false
							end
		
							arg_addr = vargv(vm, 2)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f)", arg_val0.f, arg_val1.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						case '3'_u8 then
							if vm.cf.vargc < 3 then
								vm.error = "RUNTIME ERROR: insufficient vararg bytes for format specifier `%v3`\n"
								return false
							end
		
							arg_addr = vargv(vm, 3)
							if not getMem32(vm, arg_addr, &arg_val0.u) then return false end
							if not getMem32(vm, arg_addr + 4, &arg_val1.u) then return false end
							if not getMem32(vm, arg_addr + 8, &arg_val2.u) then return false end
		
							vm.sb:clear()
							vm.sb:writef("(%.2f, %.2f, %.2f)", arg_val0.f, arg_val1.f, arg_val2.f)
		
							local s: string = vm.sb:view()
		
							for j = 0, < #s do
								if y >= GPU_VSCREEN_H or cur_x >= GPU_VSCREEN_W then
									return true
								end
		
								vm.gpu:drawChar2D(s[j + 1], &cur_x, y, ray_col)
							end

							i = i + 2
						else
							vm.error = string.format("RUNTIME ERROR: invalid format specifier `%%v%c`\n", c)
							return false
					end
				else
					vm.error = string.format("RUNTIME ERROR: invalid format specifier `%%%c`\n", c)
					return false
			end
		elseif c == '\n'_u8 then
			cur_x = x
			y = y + 9
		else
			vm.gpu:drawChar2D(c, &cur_x, y, ray_col)
		end

		i = i + 1
	end

	return true
end

local function apiVargc(vm: *e3d.EVM): boolean
	-- signature:
	-- int vargc();

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("RUNTIME ERROR (DEBUG): cannot call vargc() with empty callstack\n")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *e3d.CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("RUNTIME ERROR: cannot call vargc() from non-vararg function\n")
		return false
	end

	vm:pushU(frame.vargc * 4) -- return number of vararg bytes to allow use of sizeof()

	return true
end

local function apiVargv(vm: *e3d.EVM): boolean
	-- signature:
	-- void* vargv(int offset);

	local offset: uint32 = vm:getArgU(0) /// 4 -- offset is given in bytes to allow easy use of sizeof()

	if vm.csp < 1 then
		-- shouldn't happen, but just in case
		vm.error = string.format("RUNTIME ERROR (DEBUG): cannot call vargv() with empty callstack\n")
		return false
	end

	-- examine the callframe from the function we called from
	local frame: *e3d.CallFrame = &vm.callstack[vm.csp - 1]

	if not frame.vargf then
		vm.error = string.format("RUNTIME ERROR: cannot call vargv() from non-vararg function\n")
		return false
	end

	if frame.vargc == 0 then
		vm.error = string.format("RUNTIME ERROR: vargv() called after end of varargs\n")
		return false
	end

	if offset > frame.vargc then
		vm.error = string.format("RUNTIME ERROR: vararg count exceeded by %d word(s)\n", offset - frame.vargc)
		return false
	end

	frame.vargc = frame.vargc - offset
	
	-- get ap of the function we called from
	local ap: uinteger = (vm.asp - vm.cf.argc) - frame.argc
	
	-- return adress vargp currently points to
	vm:pushU(e3d.ARGS_START_ADDR + ((ap + frame.vargp) * 4))

	-- offset vararg pointer
	frame.vargp = frame.vargp + offset

	return true
end

local function apiPressed(vm: *e3d.EVM): boolean
	-- signature:
	-- int pressed(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyPressed(code) and 1 or 0)
	end
	
	return true
end

local function apiReleased(vm: *e3d.EVM): boolean
	-- signature:
	-- int released(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyReleased(code) and 1 or 0)
	end
	
	return true
end

local function apiHeld(vm: *e3d.EVM): boolean
	-- signature:
	-- int held(int player, int btn);

	local p: uint32 = vm:getArgU(0)
	local b: uint32 = vm:getArgU(1)

	p = math.clamp(p, 0, e3d.INPUT_PLAYERS_COUNT - 1)
	b = (p * e3d.ControllerButtons.COUNT) + b

	local code: cint = e3d.btnmap[b]

	if code == 0 then
		vm:pushU(0)
	else
		vm:pushU(rl.isKeyDown(code) and 1 or 0)
	end
	
	return true
end

local function apiMini(vm: *e3d.EVM): boolean
	-- signature:
	-- int mini(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMaxi(vm: *e3d.EVM): boolean
	-- signature:
	-- int maxi(int a, int b);
	
	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	
	if a < b then
		vm:pushI(a)
	else
		vm:pushI(b)
	end
	
	return true
end

local function apiMidi(vm: *e3d.EVM): boolean
	-- signature:
	-- int midi(int a, int b, int c);

	local a: int32 = vm:getArgI(0)
	local b: int32 = vm:getArgI(1)
	local c: int32 = vm:getArgI(2)
	
	vm:pushI(util.midI(a, b, c))

	return true
end

local function apiWrapi(vm: *e3d.EVM): boolean
	-- signature:
	-- int wrapi(int x, int min, int max);

	local x: int32 = vm:getArgI(0)
	local min: int32 = vm:getArgI(1)
	local max: int32 = vm:getArgI(2)

    vm:pushI(util.wrapI(x, min, max))
	
	return true
end

local function apiMinf(vm: *e3d.EVM): boolean
	-- signature:
	-- float minf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a < b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMaxf(vm: *e3d.EVM): boolean
	-- signature:
	-- float maxf(float a, float b);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)

	if a > b then
		vm:pushF(a)
	else
		vm:pushF(b)
	end

	return true
end

local function apiMidf(vm: *e3d.EVM): boolean
	-- signature:
	-- float midf(float a, float b, float c);

	local a: float32 = vm:getArgF(0)
	local b: float32 = vm:getArgF(1)
	local c: float32 = vm:getArgF(2)
	
	vm:pushF(util.midF(a, b, c))

	return true
end

local function apiWrapf(vm: *e3d.EVM): boolean
	-- signature:
	-- float wrapf(float x, float min, float max);

	local x: float32 = vm:getArgF(0)
	local min: float32 = vm:getArgF(1)
	local max: float32 = vm:getArgF(2)
	
	vm:pushF(util.wrapF(x, min, max))
	
	return true
end

local function apiSigni(vm: *e3d.EVM): boolean
	-- signature:
	-- int signi(int x);

	local x: int32 = vm:getArgI(0)

	vm:pushI(math.sign(x))

	return true
end

local function apiSignf(vm: *e3d.EVM): boolean
	-- signature:
	-- float signf(float x);

	local x: float32 = vm:getArgF(0)

	vm:pushF(math.sign(x))

	return true
end

local function apiFract(vm: *e3d.EVM): boolean
	-- signature:
	-- float fract(float x);

	local x: float32 = vm:getArgF(0)

	vm:pushF(math.fract(x))

	return true
end

local function apiDeg(vm: *e3d.EVM): boolean
	-- signature:
	-- float deg(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.deg(v))

	return true
end

local function apiRad(vm: *e3d.EVM): boolean
	-- signature:
	-- float rad(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.rad(v))

	return true
end

local function apiSin(vm: *e3d.EVM): boolean
	-- signature:
	-- float sin(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.sin(v))

	return true
end

local function apiCos(vm: *e3d.EVM): boolean
	-- signature:
	-- float cos(float x);
	
	local v: float32 = vm:getArgF(0)

	vm:pushF(math.cos(v))

	return true
end

local function apiFloor(vm: *e3d.EVM): boolean
	-- signature:
	-- float floor(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.floor(v))

	return true
end

local function apiCeil(vm: *e3d.EVM): boolean
	-- signature:
	-- float ceil(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.ceil(v))

	return true
end

local function apiRound(vm: *e3d.EVM): boolean
	-- signature:
	-- float round(float x);

	local v: float32 = vm:getArgF(0)

	vm:pushF(math.round(v))

	return true
end

local function apiRandomize(vm: *e3d.EVM): boolean
	-- signature:
	-- void randomize();

	math.randomseed()

	return true
end

local function apiRandomizeEx(vm: *e3d.EVM): boolean
	-- signature:
	-- void randomizeEx(int seed);

	local seed: uint32 = vm:getArgU(0)

	math.randomseed(seed)

	return true
end

local function apiRandi(vm: *e3d.EVM): boolean
	-- signature:
	-- int randi(int min, int max);

	local min: int32 = vm:getArgI(0)
	local max: int32 = vm:getArgI(1)

	if max < min then
		min, max = max, min
	end

	vm:pushI(math.random(min, max))

	return true
end

local function apiRandiEx(vm: *e3d.EVM): boolean
	-- signature:
	-- int randiEx();

	vm:pushI(math.random(0)) -- get int will all random bits

	return true
end

local function apiRandf(vm: *e3d.EVM): boolean
	-- signature:
	-- float randf(float min, float max);

	local min: float32 = vm:getArgF(0)
	local max: float32 = vm:getArgF(1)

	if max < min then
		min, max = max, min
	end

	local x: float32 = math.random() -- gets a float in [0, 1)

	vm:pushF(min + x * (max - min))

	return true
end

local function apiRandfEx(vm: *e3d.EVM): boolean
	-- signature:
	-- float randfEx();

	vm:pushF(math.random())

	return true
end

local function apiTime(vm: *e3d.EVM): boolean
	-- signature:
	-- float time();

	vm:pushF((@float32)(rl.getTime() - vm.init_time))
	
	return true
end

local function apiVec2Length(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Length(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(math.sqrt(v.x * v.x + v.y * v.y))

	return true
end

local function apiVec2LengthSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LengthSq(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm:pushF(v.x * v.x + v.y * v.y)

	return true
end

local function apiVec2Normalize(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Normalize(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	local l: float32 = v.x * v.x + v.y * v.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
	end

	vm:pushV2(v)

	return true
end

local function apiVec2Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Dot(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.x + a.y * b.y)

	return true
end

local function apiVec2Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Cross(vec2 a, vec2 b);
	
	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(a.x * b.y - a.y * b.x)

	return true
end

local function apiVec2Distance(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Distance(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)))
	
	return true
end

local function apiVec2DistanceSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2DistanceSq(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	
	vm:pushF((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
	
	return true
end

local function apiVec2Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Direction(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local direction: rl.vector2 = b - a;

	local l: float32 = direction.x * direction.x + direction.y * direction.y

	if l ~= 0.0 then
		l = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
	end

	vm:pushV2(direction)

	return true
end

local function apiVec2Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2Angle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(math.atan2(b.y - a.y, b.x - a.x))

	return true
end

local function apiVec2LineAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec2LineAngle(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	vm:pushF(rl.vector2LineAngle(a, b))

	return true
end

local function apiVec2Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Lerp(vec2 a, vec2 b, float amount);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local amount: float32 = vm:getArgF(4)

	a:lerp(b, amount)

	vm:pushV2(a)

	return true
end

local function apiVec2Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Reflect(vec2 a, vec2 b);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)

	a:reflect(b)
	
	vm:pushV2(a)
	
	return true
end

local function apiVec2Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Rotate(vec2 v, float angle);

	local v: rl.vector2 = vm:getArgV2(0)
	local angle: float32 = vm:getArgF(2)

	v:rotate(angle)
	
	vm:pushV2(v)

	return true
end

local function apiVec2MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2MoveToward(vec2 a, vec2 b, float delta);

	local a: rl.vector2 = vm:getArgV2(0)
	local b: rl.vector2 = vm:getArgV2(2)
	local delta: float32 = vm:getArgF(4)

	local dest: rl.vector2 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV2(b)
	else
		local temp: rl.vector2 = {
			dest.x / length * delta,
			dest.y / length * delta
		}
		vm:pushV2(a + temp)
	end

	return true
end

local function apiVec2Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec2Invert(vec2 v);
	
	local v: rl.vector2 = vm:getArgV2(0)

	v:invert()

	vm:pushV2(v)

	return true
end

local function v3Normalize(v: rl.vector3): rl.vector3
	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		v.x = v.x / l
		v.y = v.y / l
		v.z = v.z / l
	end

	return v
end

local function v3Cross(a: rl.vector3, b: rl.vector3): rl.vector3
	return {
		(a.y * b.z) - (a.z * b.y),
		(a.z * b.x) - (a.x * b.z),
		(a.x * b.y) - (a.y * b.x)
	}
end

local function apiVec3Length(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Length(vec3 v);
	
	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3LengthSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3LengthSq(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Normalize(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Normalize(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	vm:pushV3(v3Normalize(v))
	
	return true
end

local function apiVec3Dot(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Dot(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(a.x * b.x + a.y * b.y + a.z * b.z)
	
	return true
end

local function apiVec3Cross(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Cross(vec3 a, vec3 b);
	
	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushV3(v3Cross(a, b))
	
	return true
end

local function apiVec3Distance(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Distance(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(math.sqrt(x + y + z))
	
	return true
end

local function apiVec3DistanceSq(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3DistanceSq(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	
	local v: rl.vector3 = {b.x - a.x, b.y - a.y, b.z - a.z}

	local x: float32 = v.x * v.x
	local y: float32 = v.y * v.y
	local z: float32 = v.z * v.z

	vm:pushF(x + y + z)
	
	return true
end

local function apiVec3Direction(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec3Direction(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local direction: rl.vector3 = b - a;

	local x: float32 = direction.x * direction.x
	local y: float32 = direction.y * direction.y
	local z: float32 = direction.z * direction.z
	local l: float32 = x + y + z

	if l == 0.0 then
		local l: float32 = math.sqrt(l)
		direction.x = direction.x / l
		direction.y = direction.y / l
		direction.z = direction.z / l
	end

	vm:pushV3(direction)

	return true
end

local function apiVec3Angle(vm: *e3d.EVM): boolean
	-- signature:
	-- float vec3Angle(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	vm:pushF(a:angle(b))

	return true
end
local function apiVec3Lerp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Lerp(vec3 a, vec3 b, float amount);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local amount: float32 = vm:getArgF(6)

	a:lerp(b, amount)
	
	vm:pushV3(a)

	return true
end
local function apiVec3Reflect(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Reflect(vec3 a, vec3 b);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)

	a:reflect(b)
	
	vm:pushV3(a)

	return true
end
local function apiVec3Rotate(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Rotate(vec3 v, vec3 axis, float angle);

	local v: rl.vector3 = vm:getArgV3(0)
	local axis: rl.vector3 = vm:getArgV3(3)
	local angle: float32 = vm:getArgF(6)

	v:rotateByAxisAngle(axis, angle)
	
	vm:pushV3(v)

	return true
end
local function apiVec3MoveToward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3MoveToward(vec3 a, vec3 b, float delta);

	local a: rl.vector3 = vm:getArgV3(0)
	local b: rl.vector3 = vm:getArgV3(3)
	local delta: float32 = vm:getArgF(6)

	local dest: rl.vector3 = b - a
	local length: float32 = #dest

	if length <= delta or length < 0.0001 then
		vm:pushV3(b)
	else
		local temp: rl.vector3 = {
			dest.x / length * delta,
			dest.y / length * delta,
			dest.z / length * delta
		}
		vm:pushV3(a + temp)
	end

	return true
end
local function apiVec3Invert(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 vec3Invert(vec3 a);

	local v: rl.vector3 = vm:getArgV3(0)

	v:invert()
	
	vm:pushV3(v)

	return true
end

local function apiVec3ToScreen(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 vec3ToScreen(vec pos, int camera_id);

	local pos: rl.vector3 = vm:getArgV3(0)
	local camera_id: uinteger = math.clamp(vm:getArgU(3), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV2(rl.getWorldToScreenEx(pos, vm.gpu.cameras[camera_id], vm.gpu.viewport_w, vm.gpu.viewport_h))

	return true
end

local function apiMatrixIdentity(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixIdentity();

	vm:pushMat(rl.matrix.identity())

	return true
end

local function apiMatrixAdd(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixAdd(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.add(a, b))

	return true
end

local function apiMatrixSubtract(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixSubtract(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.subtract(a, b))

	return true
end

local function apiMatrixMultiply(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixMultiply(matrix a, matrix b);

	local a: rl.matrix = vm:getArgMat(0)
	local b: rl.matrix = vm:getArgMat(16)

	vm:pushMat(rl.matrix.multiply(a, b))

	return true
end

local function apiMatrixTranslate(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixTranslate(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	local tm: rl.matrix = {
		1.0, 0.0, 0.0, v.x,
		0.0, 1.0, 0.0, v.y,
		0.0, 0.0, 1.0, v.z,
		0.0, 0.0, 0.0, 1.0
	}

	vm:pushMat(rl.matrix.multiply(tm, m))

	return true
end

local function apiMatrixRotate(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixRotate(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	vm:pushMat(rl.matrix.multiply(rl.matrix.rotateZYX(v), m))

	return true
end

local function apiMatrixScale(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixScale(matrix m, vec3 v);

	local m: rl.matrix = vm:getArgMat(0)
	local v: rl.vector3 = vm:getArgV3(16)

	local sm: rl.matrix = {
		v.x, 0.0, 0.0, 0.0,
		0.0, v.y, 0.0, 0.0,
		0.0, 0.0, v.z, 0.0,
		0.0, 0.0, 0.0, 1.0
	}

	vm:pushMat(rl.matrix.multiply(sm, m))

	return true
end

local function apiMatrixTranspose(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixTranspose(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	vm:pushMat(rl.matrix.transpose(m))

	return true
end

local function apiMatrixInvert(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix matrixInvert(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	vm:pushMat(rl.matrix.invert(m))

	return true
end

local function apiCamera2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera2D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera2D(id)

	return true
end

local function apiGetCam2DOrigin(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 getCam2DOrigin(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV2(vm.gpu.cameras2D[id].offset)

	return true
end

local function apiSetCam2DOrigin(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DOrigin(int id, vec2 origin);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local origin: rl.vector2 = vm:getArgV2(1)

	vm.gpu.cameras2D[id].offset = origin

	return true
end

local function apiGetCam2DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- vec2 getCam2DTarget(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV2(vm.gpu.cameras2D[id].target)

	return true
end

local function apiSetCam2DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DTarget(int id, vec2 target);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local target: rl.vector2 = vm:getArgV2(1)

	vm.gpu.cameras2D[id].target = target

	return true
end

local function apiGetCam2DAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam2DAngle(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras2D[id].rotation)

	return true
end

local function apiSetCam2DAngle(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DAngle(int id, float angle);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local angle: float32 = vm:getArgF(1)

	vm.gpu.cameras2D[id].rotation = angle

	return true
end

local function apiGetCam2DZoom(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam2DZoom(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras2D[id].zoom)

	return true
end

local function apiSetCam2DZoom(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam2DZoom(int id, float zoom);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local zoom: float32 = vm:getArgF(1)

	vm.gpu.cameras2D[id].zoom = zoom

	return true
end

local function apiCamera3D(vm: *e3d.EVM): boolean
	-- signature:
	-- void camera3D(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	
	vm.gpu:camera3D(id)

	return true
end

local function apiGetCam3DPosition(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DPosition(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].position)

	return true
end

local function apiSetCam3DPosition(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DPosition(int id, vec3 pos);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local pos: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].position = pos

	return true
end

local function apiGetCam3DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DTarget(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].target)

	return true
end

local function apiSetCam3DTarget(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DTarget(int id, vec3 target);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local target: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].target = target

	return true
end

local function apiGetCam3DUp(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DUp(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushV3(vm.gpu.cameras[id].up)

	return true
end

local function apiSetCam3DUp(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DUp(int id, vec3 up);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local up: rl.vector3 = vm:getArgV3(1)

	vm.gpu.cameras[id].up = up

	return true
end

local function apiGetCam3DFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- float getCam3DFOV(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushF(vm.gpu.cameras[id].fovy)

	return true
end

local function apiSetCam3DFOV(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DFOV(int id, float fov);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local fov: float32 = vm:getArgF(1)

	vm.gpu.cameras[id].fovy = fov

	return true
end

local function apiGetCam3DProjection(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCam3DProjection(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)

	vm:pushI((@int32)(vm.gpu.cameras[id].projection))

	return true
end

local function apiSetCam3DProjection(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCam3DProjection(int id, int mode);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local proj: float32 = vm:getArgI(1)

	vm.gpu.cameras[id].projection = (@cint)(math.clamp(proj, 0, 1))

	return true
end



local function apiGetCam3DRight(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DRight(int id);

	-- get camera
	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	-- calculate forward vector
	local forward: rl.vector3 = v3Normalize({
			cam.target.x - cam.position.x,
			cam.target.y - cam.position.y,
			cam.target.z - cam.position.z
		}
	)

	-- get normalized up vector
    local up: rl.vector3 = v3Normalize(cam.up)

	-- calculate cross of forward and up
	vm:pushV3({
			(forward.y * up.z) - (forward.z * up.y),
			(forward.z * up.x) - (forward.x * up.z),
			(forward.x * up.y) - (forward.y * up.x)
		}
	)

	return true
end

local function apiGetCam3DForward(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCam3DForward(int id);

	local id: uinteger = math.clamp(vm:getArgU(0), 0, GPU_CAMERAS_COUNT - 1)
	local cam: rl.camera = vm.gpu.cameras[id]

	vm:pushV3(
		v3Normalize({
				cam.target.x - cam.position.x,
				cam.target.y - cam.position.y,
				cam.target.z - cam.position.z
			}
		)
	)

	return true
end

local function apiGetTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getTextureMode();

	vm:pushI((@int32)(vm.gpu.tex_mode))

	return true
end

local function apiSetTextureMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setTextureMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid texture mode `%d`\n", mode)
		return false
	end

	vm.gpu.tex_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.tex_mode_loc, &vm.gpu.tex_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function apiGetCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getCullMode();

	vm:pushI((@int32)(vm.gpu.cull_mode))

	return true
end

local function apiSetCullMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setCullMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	vm.gpu:updateVertexShaderMatrices()
	rlgl.drawRenderBatchActive()

	switch mode do
		case 0 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_BACK)
		case 1 then
			rlgl.enableBackfaceCulling()
			rlgl.setCullFace(rlgl.cullMode.FACE_FRONT)
		case 2 then
			rlgl.disableBackfaceCulling()
		else
			vm.error = string.format("RUNTIME ERROR: attempt to set invalid cull mode `%d`\n", mode)
			return false
	end

	vm.gpu.cull_mode = mode

	return true
end

local function apiGetWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getWireMode();

	vm:pushI(vm.gpu.wire_mode and 1 or 0)

	return true
end

local function apiSetWireMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setWireMode(int mode);
	
	local enable: boolean = vm:getArgU(0) ~= 0
	
	vm.gpu:updateVertexShaderMatrices()
	rlgl.drawRenderBatchActive()
	
	if enable then
		rlgl.enableWireMode()
	else
		rlgl.disableWireMode()
	end

	vm.gpu.wire_mode = enable

	return true
end

local function apiGetFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogMode();

	vm:pushI((@int32)(vm.gpu.fog_mode))

	return true
end

local function apiSetFogMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode ~= 0 then
		mode = 1
	end

	vm.gpu.fog_mode = (@cint)(mode)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_mode_loc, &vm.gpu.fog_mode, rl.shaderUniformDataType.UNIFORM_INT)

	return true
end

local function apiGetFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogStart();

	vm:pushF(vm.gpu.fog_start)

	return true
end

local function apiSetFogStart(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogStart(float start);

	local start: float32 = vm:getArgF(0)

	start = math.clamp(start, 0.0, 1000.0)
	
	vm.gpu.fog_start = start
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_start_loc, &vm.gpu.fog_start, rl.shaderUniformDataType.UNIFORM_FLOAT)
	
	return true
end

local function apiGetFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- float getFogEnd();

	vm:pushF(vm.gpu.fog_end)

	return true
end

local function apiSetFogEnd(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogEnd(float end);
	
	local fend: float32 = vm:getArgF(0)
	
	fend = math.clamp(fend, 0.0, 1000.0)
	
	vm.gpu.fog_end = fend
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_end_loc, &vm.gpu.fog_end, rl.shaderUniformDataType.UNIFORM_FLOAT)

	return true
end

local function apiGetFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- int getFogColor();
	
	local ray_col: rl.color = rl.colorFromNormalized(vm.gpu.fog_color)

	local r: uint32 = (@uint32)(ray_col.r)
	local g: uint32 = (@uint32)(ray_col.g)
	local b: uint32 = (@uint32)(ray_col.b)
	local a: uint32 = (@uint32)(ray_col.a)
	
	vm:pushU((r << 24) | (g << 16) | (b << 8) | a)

	return true
end

local function apiSetFogColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setFogColor(float color);

	local col: uint32 = vm:getArgU(0)
	local ray_col: rl.color = {
		(@cuchar)(col >> 24),
		(@cuchar)((col & 0xFF0000) >> 16),
		(@cuchar)((col & 0x00FF00) >> 8),
		(@cuchar)(col & 0xFF),
	}

	vm.gpu.fog_color = rl.colorNormalize(ray_col)
	
	rl.setShaderValue(vm.gpu.gfx_shader, vm.gpu.fog_color_loc, &vm.gpu.fog_color, rl.shaderUniformDataType.UNIFORM_VEC4)

	return true
end

local function apiGetBlendMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getBlendMode();
	
	vm:pushU(vm.gpu.blend_mode)

	return true
end

local function apiSetBlendMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setBlendMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > rl.blendMode.SUBTRACT_colorS then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid blend mode `%d`\n", mode)
		return false
	end

	vm.gpu:setBlendMode(mode)

	return true
end

local function apiGetLightingMode(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightingMode();
	
	vm:pushU(vm.gpu.lighting_mode)

	return true
end

local function apiSetLightingMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightingMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode ~= 0 then
		mode = 1
	end

	vm.gpu:updateVertexShaderMatrices()
	vm.gpu:setLightingMode(mode)

	return true
end

local function apiGetAmbientFactor(vm: *e3d.EVM): boolean
	-- signature:
	-- float getAmbientFactor();
	
	vm:pushF(vm.gpu.ambient_factor * 100.0)

	return true
end

local function apiSetAmbientFactor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setAmbientFactor(float factor);

	local factor: float32 = vm:getArgF(0)

	if factor < 0.0 or factor > 100.0 then
		vm.error = "RUNTIME ERROR: attempt to set invalid ambient factor\n"
		return false
	end

	vm.gpu:setAmbientFactor(factor)

	return true
end

local function apiGetAmbientColor(vm: *e3d.EVM): boolean
	-- signature:
	-- int getAmbientColor();
	
	local v3col = vm.gpu.ambient_color
	local r: uint8 = (@uint8)(v3col.x * 255.0)
	local g: uint8 = (@uint8)(v3col.y * 255.0)
	local b: uint8 = (@uint8)(v3col.z * 255.0)
	local col: uint32 = ((@uint32)(r) << 24) | ((@uint32)(g) << 16) | ((@uint32)(b) << 8)

	vm:pushU(col)

	return true
end

local function apiSetAmbientColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setAmbientColor(int color);

	local col: uint32 = vm:getArgU(0)

	vm.gpu:setAmbientColor(col)

	return true
end

local function apiGetLightEnabled(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightEnabled(int id);

	local id: uint32 = vm:getArgU(0)

	vm:pushU(vm.gpu.lights[id].enabled)

	return true
end

local function apiSetLightEnabled(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightEnabled(int id, int enabled);

	local id: uint32 = vm:getArgU(0)
	local enabled: uint32 = vm:getArgU(1)

	vm.gpu:setLightEnabled(id, enabled)

	return true
end

local function apiGetLightType(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightType(int id);

	local id: uint32 = vm:getArgU(0)

	vm:pushU(vm.gpu.lights[id].light_type)

	return true
end

local function apiSetLightType(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightType(int id, int type);

	local id: uint32 = vm:getArgU(0)
	local light_type: uint32 = vm:getArgU(1)

	vm.gpu:setLightType(id, light_type)

	return true
end

local function apiGetLightRadius(vm: *e3d.EVM): boolean
	-- signature:
	-- float getLightRadius(int id);

	local id: uint32 = vm:getArgU(0)

	vm:pushF(vm.gpu.lights[id].radius)

	return true
end

local function apiSetLightRadius(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightRadius(int id, float radius);

	local id: uint32 = vm:getArgU(0)
	local radius: float32 = vm:getArgF(1)

	vm.gpu:setLightRadius(id, radius)

	return true
end

local function apiGetLightPosition(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightPosition(int id);

	local id: uint32 = vm:getArgU(0)

	vm:pushV3(vm.gpu.lights[id].position)

	return true
end

local function apiSetLightPosition(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightPosition(int id, vec3 pos);

	local id: uint32 = vm:getArgU(0)
	local pos: rl.vector3 = vm:getArgV3(1)

	vm.gpu:setLightPosition(id, pos)

	return true
end

local function apiGetLightDirection(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightDirection(int id);

	local id: uint32 = vm:getArgU(0)

	vm:pushV3(vm.gpu.lights[id].direction)

	return true
end

local function apiSetLightDirection(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightDirection(int id, vec3 dir);

	local id: uint32 = vm:getArgU(0)
	local dir: rl.vector3 = vm:getArgV3(1)

	vm.gpu:setLightDirection(id, dir)

	return true
end

local function apiGetLightColor(vm: *e3d.EVM): boolean
	-- signature:
	-- int getLightColor(int id);

	local id: uint32 = vm:getArgU(0)

	local v3col = vm.gpu.lights[id].color
	local r: uint8 = (@uint8)(v3col.x * 255.0)
	local g: uint8 = (@uint8)(v3col.y * 255.0)
	local b: uint8 = (@uint8)(v3col.z * 255.0)
	local col: uint32 = ((@uint32)(r) << 24) | ((@uint32)(g) << 16) | ((@uint32)(b) << 8)

	vm:pushU(col)

	return true
end

local function apiSetLightColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void setLightColor(int id, int color);

	local id: uint32 = vm:getArgU(0)
	local col: uint32 = vm:getArgU(1)

	vm.gpu:setLightColor(id, col)

	return true
end

local function apiTexture(vm: *e3d.EVM): boolean
	-- signature:
	-- void texture(int x, int y, int w, int h);

	local x: int32 = vm:getArgI(0)
	local y: int32 = vm:getArgI(1)
	local w: int32 = vm:getArgI(2)
	local h: int32 = vm:getArgI(3)

	w = math.clamp(w, 1, 256)
	h = math.clamp(h, 1, 256)
	x = math.clamp(x, 0, 1024 - w)
	y = math.clamp(y, 0, 1024 - h)

	vm.gpu:texture(x, y, w, h)

	return true
end

local function apiClear(vm: *e3d.EVM): boolean
	-- signature:
	-- void clear(int col);

	local col: uint32 = vm:getArgU(0)

	vm.gpu:clear(col)

	return true
end

local function apiViewport(vm: *e3d.EVM): boolean
	-- signature:
	-- void viewport(int x, int y, int w, int h);

	local x: cint = (@cint)(vm:getArgI(0))
	local y: cint = (@cint)(vm:getArgI(1))
	local w: cint = (@cint)(vm:getArgI(2))
	local h: cint = (@cint)(vm:getArgI(3))

	w = math.clamp(w, 1, GPU_VSCREEN_W)
	h = math.clamp(h, 1, GPU_VSCREEN_H)
	x = math.clamp(x, 0, GPU_VSCREEN_W - w)
	y = math.clamp(y, 0, GPU_VSCREEN_H - h)

	y = GPU_VSCREEN_H - (y + h) -- flip y

	vm.gpu.viewport_w = w
	vm.gpu.viewport_h = h

	rlgl.viewport(x, y, w, h)
	rlgl.scissor(x, y, w, h)

	return true
end

local function apiSprite2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2D(int srcx, int srcy, int srcw, int srch, int destx, int desy);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(srcw), (@float32)(srch) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiSprite2DEx(vm: *e3d.EVM): boolean
	-- signature:
	-- void sprite2DEx(int srcx, int srcy, int srcw, int srch, int destx, int desy, int destw, int desth);

	local srcx: int32 = vm:getArgI(0)
	local srcy: int32 = vm:getArgI(1)
	local srcw: int32 = vm:getArgI(2)
	local srch: int32 = vm:getArgI(3)
	local destx: int32 = vm:getArgI(4)
	local desty: int32 = vm:getArgI(5)
	local destw: int32 = vm:getArgI(6)
	local desth: int32 = vm:getArgI(7)

	srcw = math.clamp(srcw, 1, 256)
	srch = math.clamp(srch, 1, 256)
	srcx = math.clamp(srcx, 0, 1024 - srcw)
	srcy = math.clamp(srcy, 0, 1024 - srch)

	local src_rect: rl.rectangle = { (@float32)(srcx), (@float32)(srcy), (@float32)(srcw), (@float32)(srch) };
	local dest_rect: rl.rectangle = { (@float32)(destx), (@float32)(desty), (@float32)(destw), (@float32)(desth) };

	rl.drawTexturePro(vm.gpu.gfx_texture, src_rect, dest_rect, {0.0, 0.0}, 0.0, rl.WHITE)

	return true
end

local function apiDrawObj(vm: *e3d.EVM): boolean
	-- signature:
	-- void drawObj(int id);

	local id: uint32 = vm:getArgU(0)

	if id > 511 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid OBJMAP entry `%d`\n", id)
		return false
	end

	vm.gpu:drawObj(id)

	return true
end

local function apiDrawObjEx(vm: *e3d.EVM): boolean
	-- signature:
	-- void drawObjEx(int mode, int start, int n);

	local mode: uint32 = vm:getArgU(0)
	local start: uint32 = vm:getArgU(1)
	local n: uint32 = vm:getArgU(2)

	vm.gpu:drawObjEx(mode, start, n)

	return true
end

local function apiBeginMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void beginMesh(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > 2 then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid primitive mode `%d`", mode)
		return false
	end

	vm.gpu:beginMesh(mode)
	
	return true
end

local function apiEndMesh(vm: *e3d.EVM): boolean
	-- signature:
	-- void endMesh();

	vm.gpu:endMesh()
	
	return true
end

local function apiMeshVertex(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshVertex(vec3 v);

	local v: rl.vector3 = vm:getArgV3(0)

	vm.gpu:vertex(v)
	
	return true
end

local function apiMeshVertex2D(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshVertex2D(vec2 v);

	local v: rl.vector2 = vm:getArgV2(0)

	vm.gpu:vertex2D(v)
	
	return true
end

local function apiMeshNormal(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshNormal(vec3 normal);

	local v: rl.vector3 = vm:getArgV3(0)
	
	vm.gpu:vertNormal(v)
	
	return true
end

local function apiMeshUV(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshUV(vec2 uv);

	local v: rl.vector2 = vm:getArgV2(0)
	
	vm.gpu:vertUV(v)
	
	return true
end

local function apiMeshColor(vm: *e3d.EVM): boolean
	-- signature:
	-- void meshColor(int col);

	local col: uint32 = vm:getArgU(0)
	
	vm.gpu:vertColor(col)
	
	return true
end

-- void normal(vec3 norm);

local function apiMatrixMode(vm: *e3d.EVM): boolean
	-- signature:
	-- void matrixMode(int mode);

	local mode: uint32 = vm:getArgU(0)

	if mode > GPU_MODELVIEW then
		vm.error = string.format("RUNTIME ERROR: attempt to set invalid matrix mode `%d`", mode)
		return false
	end

	vm.gpu:matrixMode(mode)

	return true
end

local function apiPushMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void pushMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count >= 24 then
			vm.error = "RUNTIME ERROR: projection matrix stack overflow\n"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count + 1
	else
		if vm.gpu.view_matrix_count >= 24 then
			vm.error = "RUNTIME ERROR: view matrix stack overflow\n"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count + 1
	end
	
	rlgl.pushMatrix()
	
	return true
end

local function apiPopMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void popMatrix();

	if vm.gpu.matrix_mode == rlgl.PROJECTION then
		if vm.gpu.proj_matrix_count == 0 then
			vm.error = "RUNTIME ERROR: projection matrix stack underflow\n"
			return false
		end

		vm.gpu.proj_matrix_count = vm.gpu.proj_matrix_count - 1
	else
		if vm.gpu.view_matrix_count == 0 then
			vm.error = "RUNTIME ERROR: view matrix stack underflow\n"
			return false
		end

		vm.gpu.view_matrix_count = vm.gpu.view_matrix_count - 1
	end

	rlgl.popMatrix()
	
	return true
end

local function apiGetProjectionMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix getProjectionMatrix();

	vm:pushMat(rlgl.getMatrixProjection())

	return true
end

local function apiSetProjectionMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void setProjectionMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	rlgl.setMatrixProjection(m)

	return true
end

local function apiGetModelViewMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix getModelViewMatrix();

	vm:pushMat(rlgl.getMatrixModelview())

	return true
end

local function apiSetModelViewMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void setModelViewMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	rlgl.setMatrixModelview(m)

	return true
end

local function apiGetTopMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- matrix getTopMatrix();

	vm:pushMat(rlgl.getMatrixTransform())

	return true
end

local function apiMultiplyTopMatrix(vm: *e3d.EVM): boolean
	-- signature:
	-- void multiplyTopMatrix(matrix m);

	local m: rl.matrix = vm:getArgMat(0)

	local asfloat16: rl.float16 = rl.matrix.toFloatV(m)
	rlgl.multMatrixf((@*float32)(&asfloat16.v))

	return true
end

local function apiIdentity(vm: *e3d.EVM): boolean
	-- signature:
	-- void identity();

	rlgl.loadIdentity()
	
	return true
end

local function apiTranslate(vm: *e3d.EVM): boolean
	-- signature:
	-- void translate(vec3 pos);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.translatef(v.x, v.y, v.z)
	
	return true
end

local function apiRotate(vm: *e3d.EVM): boolean
	-- signature:
	-- void rotate(vec3 rot);

	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.rotatef(v.z, 0, 0, 1)
	rlgl.rotatef(v.y, 0, 1, 0)
	rlgl.rotatef(v.x, 1, 0, 0)
	
	return true
end

local function apiScale(vm: *e3d.EVM): boolean
	-- signature:
	-- void scale(vec3 sca);
	
	local v: rl.vector3 = vm:getArgV3(0)
	
	rlgl.scalef(v.x, v.y, v.z)
	
	return true
end

local function apiFrustum(vm: *e3d.EVM): boolean
	-- signature:
	-- void frustum(float left, float right, float bottom, float top, float near, float far);

	local left: float32 = vm:getArgF(0)
	local right: float32 = vm:getArgF(1)
	local bottom: float32 = vm:getArgF(2)
	local top: float32 = vm:getArgF(3)
	local near: float32 = vm:getArgF(4)
	local far: float32 = vm:getArgF(5)

	if left == right or top == bottom or near == far then
		vm.error = "RUNTIME ERROR: invalid frustum parameters"
		return false
	end

	rlgl.frustum(left, right, bottom, top, near, far)

	return true
end

local function apiOrtho(vm: *e3d.EVM): boolean
	-- signature:
	-- void ortho(float left, float right, float bottom, float top, float near, float far);
	
	local left: float32 = vm:getArgF(0)
	local right: float32 = vm:getArgF(1)
	local bottom: float32 = vm:getArgF(2)
	local top: float32 = vm:getArgF(3)
	local near: float32 = vm:getArgF(4)
	local far: float32 = vm:getArgF(5)

	if left == right or top == bottom or near == far then
		vm.error = "RUNTIME ERROR: invalid ortho parameters"
		return false
	end

	rlgl.ortho(left, right, bottom, top, near, far)

	return true
end

local function apiPlaySong(vm: *e3d.EVM): boolean
	-- signature:
	-- void playSong(int row);

	local row: uint32 = vm:getArgU(0)

	vm.soundchip:playSongRow((@uint8)(row))

	return true
end

local function apiPlayTrack(vm: *e3d.EVM): boolean
	-- signature:
	-- void playTrack(int track, int song_row);

	local track: uint32 = vm:getArgU(0)
	local row: uint32 = vm:getArgU(1)

	vm.soundchip:playTrack((@uint8)(track), (@uint8)(row))

	return true
end

local function apiPlayPattern(vm: *e3d.EVM): boolean
	-- signature:
	-- void playPattern(int track, int pattern);

	local track: uint32 = vm:getArgU(0)
	local pattern: uint32 = vm:getArgU(1)

	vm.soundchip:playPattern((@uint8)(track), (@uint8)(pattern))

	return true
end

local function apiPlayWav(vm: *e3d.EVM): boolean
	-- signature:
	-- void playWav(int track, int id);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local id: uint32 = vm:getArgU(1)
	local volume: uint8 = (@uint8)(vm:getArgU(2))

	if id > 511 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid WAVMAP entry `%d`", id)
		return false
	end

	vm.soundchip:playWav(track, id, volume)

	return true
end

local function apiPlayWavEx(vm: *e3d.EVM): boolean
	-- signature:
	-- void playWavEx(int track, int start, int end, int note, int volume, int flags);

	local track: uint8 = (@uint8)(vm:getArgU(0))
	local start: uint8 = vm:getArgU(1)
	local send: uint8 = vm:getArgU(2)
	local note: uint8 = (@uint8)(vm:getArgU(3))
	local volume: uint8 = (@uint8)(vm:getArgU(4))
	local flags: uint8 = (@uint8)(vm:getArgU(5))

	vm.soundchip:playWavEx(track, start, send, note, volume, flags)

	return true
end

local function apiPauseTracks(vm: *e3d.EVM): boolean
	-- signature:
	-- void pauseTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags & ~((@uint8)(mask))

	return true
end

local function apiResumeTracks(vm: *e3d.EVM): boolean
	-- signature:
	-- void resumeTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	vm.soundchip.audio_state.playing_flags = vm.soundchip.audio_state.playing_flags | (@uint8)(mask)

	return true
end

local function apiStopTracks(vm: *e3d.EVM): boolean
	-- signature:
	-- void stopTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:stopTrack(i)
		end
	end

	return true
end

local function apiMuteTracks(vm: *e3d.EVM): boolean
	-- signature:
	-- void muteTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:muteTrack(i)
		end
	end

	return true
end

local function apiUnmuteTracks(vm: *e3d.EVM): boolean
	-- signature:
	-- void unmuteTracks(int mask);

	local mask: uint32 = vm:getArgU(0)

	for i = 0, < SOUNDCHIP_TRACK_COUNT do
		if mask & (0x80 >> i) ~= 0 then
			vm.soundchip:unmuteTrack(i)
		end
	end

	return true
end

local function apiCheckCollision(vm: *e3d.EVM): boolean
	-- signature:
	-- int checkCollision(void* a, void* b);

	local a_addr: uint32 = vm:getArgU(0)
	local b_addr: uint32 = vm:getArgU(1)
	local a_type: uint32
	local b_type: uint32

	if not getMem32(vm, a_addr, &a_type) then
		return false
	end

	if not getMem32(vm, b_addr, &b_type) then
		return false
	end

	if a_type > ColType.CYLINDER or a_type > ColType.CYLINDER then
		vm.error = "RUNTIME ERROR: attempt to call checkCollision() on invalid collision shape type(s)\n"
		return false
	end

	local cfunc: CollisionFunction = collision_functions[a_type][b_type]
	if cfunc == nilptr then
		vm.error = string.format(
			"RUNTIME ERROR: no collision function for types `%s` and `%s`\n",
			collision_type_names[a_type],
			collision_type_names[b_type]
		)
		return false
	end

	local success: boolean
	local collision: int32
	success, collision = cfunc(vm, a_addr, b_addr)

	if success then
		vm:pushI(collision)
		return true
	else
		return false
	end
end

local function apiCheckAABBPoint(vm: *e3d.EVM): boolean
	-- signature:
	-- int checkAABBPoint(box b, vec3 p);

	local b_position: rl.vector3 = vm:getArgV3(0)
	local b_width: float32 = vm:getArgF(3)
	local b_height: float32 = vm:getArgF(4)
	local b_depth: float32 = vm:getArgF(5)
	local p: rl.vector3 = vm:getArgV3(6)

	local half_width: float32 = b_width / 2
	local half_height: float32 = b_height / 2
	local half_depth: float32 = b_depth / 2
	local min_x: float32 = b_position.x - half_width
	local max_x: float32 = b_position.x + half_width
	local min_y: float32 = b_position.y - half_height 
	local max_y: float32 = b_position.y + half_height 
	local min_z: float32 = b_position.z - half_depth
	local max_z: float32 = b_position.z + half_depth

	if p.x < min_x or p.x > max_x then
		vm:pushI(0)
	elseif p.y < min_y or p.y > max_y then
		vm:pushI(0)
	elseif p.z < min_z or p.z > max_z then
		vm:pushI(0)
	else
		vm:pushI(1)
	end

	return true
end

local function apiGetCollisionPoint(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCollisionPoint();

	return true
end

local function apiGetCollisionNormal(vm: *e3d.EVM): boolean
	-- signature:
	-- vec3 getCollisionNormal();

	return true
end

local function apiLoadTexBank(vm: *e3d.EVM): boolean
	-- signature:
	-- void loadTexBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 3 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid texture bank `%d`", bank)
		return false
	end

	vm.gpu:loadTexBank(bank)

	return true
end

local function apiLoadObjBank(vm: *e3d.EVM): boolean
	-- signature:
	-- void loadObjBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 3 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid object bank `%d`", bank)
		return false
	end

	vm.gpu:loadObjBank(bank)

	return true
end

local function apiLoadWavBank(vm: *e3d.EVM): boolean
	-- signature:
	-- void loadWavBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 1 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid wave bank `%d`", bank)
		return false
	end

	vm.soundchip:loadWavBank(bank)

	return true
end

local function apiLoadSeqBank(vm: *e3d.EVM): boolean
	-- signature:
	-- void loadSeqBank(int bank);

	local bank: uint32 = vm:getArgU(0)

	if bank > 7 then
		vm.error = string.format("RUNTIME ERROR: attempt to load invalid sequencer bank `%d`", bank)
		return false
	end

	vm.soundchip:loadSeqBank(bank)

	return true
end

local function apiPeek8(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek8(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
		return false
	end

	vm:pushU(vm:getMem8(addr))

	return true
end

local function apiPoke8(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke8(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint8 = (@uint8)(vm:getArgU(1) & 0xFF)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid byte write address 0x%08X\n", addr)
		return false
	end

	if not vm:setMem8(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

local function apiPeek32(vm: *e3d.EVM): boolean
	-- signature:
	-- int peek32(int addr);

	local addr: uint32 = vm:getArgU(0)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", addr)
		return false
	end

	vm:pushU(vm:getMem32(addr))

	return true
end

local function apiPoke32(vm: *e3d.EVM): boolean
	-- signature:
	-- void poke32(int addr, int val);

	local addr: uint32 = vm:getArgU(0)
	local val: uint32 = vm:getArgU(1)

	if addr > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid word write address 0x%08X\n", addr)
		return false
	elseif (addr & 0b11) ~= 0 then
		vm.error = string.format("RUNTIME ERROR: misaligned word write address 0x%08X\n", addr)
		return false
	end

	if not vm:setMem32(addr, val) then
		vm.error = string.format("RUNTIME ERROR: cannot write word to ROM address 0x%08X\n", addr)
		return false
	end

	return true
end

local function apiMemcpy(vm: *e3d.EVM): boolean
	-- signature:
	-- void memcpy(void* src, void* dest, int nbytes);

	local src: uint32 = vm:getArgU(0)
	local dest: uint32 = vm:getArgU(1)
	local nbytes: uint32 = vm:getArgU(2)

	if src > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy src address 0x%08X\n", src)
		return false
	end

	if src + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy src end address 0x%08X\n", src + (nbytes - 1))
		return false
	end

	if dest > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy dest address 0x%08X\n", dest)
		return false
	end

	if dest + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memcpy dest end address 0x%08X\n", dest + (nbytes - 1))
		return false
	end

	if src == dest then
		return true
	elseif src < dest then
		-- copy from the end
		src = src + (nbytes - 1)
		dest = dest + (nbytes - 1)

		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
				return false
			end

			src = src - 1
			dest = dest - 1
		end
	else
		-- copy from the beginning
		for i = 0, < nbytes do
			local byte: uint8 = vm:getMem8(src)

			if not vm:setMem8(dest, byte) then
				vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
				return false
			end

			src = src + 1
			dest = dest + 1
		end
	end

	return true
end

local function apiMemset(vm: *e3d.EVM): boolean
	-- signature:
	-- void memset(void* dest, int nbytes, int value);

	local dest: uint32 = vm:getArgU(0)
	local nbytes: uint32 = vm:getArgU(1)
	local value: uint8 = vm:getArgU(2) & 0xFF

	if dest > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memset dest address 0x%08X\n", dest)
		return false
	end

	if dest + (nbytes - 1) > e3d.RAM_MAX_ADDR then
		vm.error = string.format("RUNTIME ERROR: invalid memset dest end address 0x%08X\n", dest + (nbytes - 1))
		return false
	end

	for i = 0, < nbytes do
		if not vm:setMem8(dest, value) then
			vm.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", dest)
			return false
		end

		dest = dest + 1
	end

	return true;
end

function e3d.EVM:registerBuiltins(): void
	-- define vec2 struct
	local sid: *e3d.Struct = new(@e3d.Struct)
	local vec2_x: *e3d.Identifier = new(@e3d.Identifier)
	local vec2_y: *e3d.Identifier = new(@e3d.Identifier)
	sid.name = "vec2"
	$vec2_x = {name="x", index=0, type_info={e3d.EVMType.FLOAT}}
	$vec2_y = {name="y", index=1, type_info={e3d.EVMType.FLOAT}}
	sid:addMember(vec2_x)
	sid:addMember(vec2_y)
	sid.is_complete = true
	self.struct_vec2 = sid

	-- define vec3 struct
	sid = new(@e3d.Struct)
	local vec3_x: *e3d.Identifier = new(@e3d.Identifier)
	local vec3_y: *e3d.Identifier = new(@e3d.Identifier)
	local vec3_z: *e3d.Identifier = new(@e3d.Identifier)
	sid.name = "vec3"
	$vec3_x = {name="x", index=0, type_info={e3d.EVMType.FLOAT}}
	$vec3_y = {name="y", index=1, type_info={e3d.EVMType.FLOAT}}
	$vec3_z = {name="z", index=2, type_info={e3d.EVMType.FLOAT}}
	sid:addMember(vec3_x)
	sid:addMember(vec3_y)
	sid:addMember(vec3_z)
	sid.is_complete = true
	self.struct_vec3 = sid

	--[[ define matrix struct, translatable to raylib's matrix type
		matrix:
			m0: float32, m4: float32, m8: float32, m12: float32,  first row
			m1: float32, m5: float32, m9: float32, m13: float32,  second row
			m2: float32, m6: float32, m10: float32, m14: float32, third row
			m3: float32, m7: float32, m11: float32, m15: float32  fourth row
	]]
	local matrix_struct: *e3d.Struct = new(@e3d.Struct)
	local matrix_m0: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m4: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m8: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m12: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m1: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m5: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m9: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m13: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m2: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m6: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m10: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m14: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m3: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m7: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m11: *e3d.Identifier = new(@e3d.Identifier)
	local matrix_m15: *e3d.Identifier = new(@e3d.Identifier)
	matrix_struct.name = "matrix"
	$matrix_m0  = {name="m0" , index=0 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m4  = {name="m4" , index=1 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m8  = {name="m8" , index=2 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m12 = {name="m12", index=3 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m1  = {name="m1" , index=4 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m5  = {name="m5" , index=5 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m9  = {name="m9" , index=6 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m13 = {name="m13", index=7 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m2  = {name="m2" , index=8 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m6  = {name="m6" , index=9 , type_info={e3d.EVMType.FLOAT}}
	$matrix_m10 = {name="m10", index=10, type_info={e3d.EVMType.FLOAT}}
	$matrix_m14 = {name="m14", index=11, type_info={e3d.EVMType.FLOAT}}
	$matrix_m3  = {name="m3" , index=12, type_info={e3d.EVMType.FLOAT}}
	$matrix_m7  = {name="m7" , index=13, type_info={e3d.EVMType.FLOAT}}
	$matrix_m11 = {name="m11", index=14, type_info={e3d.EVMType.FLOAT}}
	$matrix_m15 = {name="m15", index=16, type_info={e3d.EVMType.FLOAT}}
	matrix_struct:addMember(matrix_m0)
	matrix_struct:addMember(matrix_m4)
	matrix_struct:addMember(matrix_m8)
	matrix_struct:addMember(matrix_m12)
	matrix_struct:addMember(matrix_m1)
	matrix_struct:addMember(matrix_m5)
	matrix_struct:addMember(matrix_m9)
	matrix_struct:addMember(matrix_m13)
	matrix_struct:addMember(matrix_m2)
	matrix_struct:addMember(matrix_m6)
	matrix_struct:addMember(matrix_m10)
	matrix_struct:addMember(matrix_m14)
	matrix_struct:addMember(matrix_m3)
	matrix_struct:addMember(matrix_m7)
	matrix_struct:addMember(matrix_m11)
	matrix_struct:addMember(matrix_m15)
	matrix_struct.is_complete = true

	-- define string struct
	sid = new(@e3d.Struct)
	local string_length: *e3d.Identifier = new(@e3d.Identifier)
	local string_data: *e3d.Identifier = new(@e3d.Identifier)
	sid.name = "string"
	$string_length = {name="length", index=0, type_info={e3d.EVMType.INT}}
	$string_data = {name="data", index=1, type_info={e3d.EVMType.VOID + e3d.EVMType.POINTER}}
	sid:addMember(string_length)
	sid:addMember(string_data)
	sid.is_complete = true
	self.struct_string = sid

	-- define vertex struct
	local vertex_struct: *e3d.Struct = new(@e3d.Struct)
	local vertex_position: *e3d.Identifier = new(@e3d.Identifier)
	local vertex_normal: *e3d.Identifier = new(@e3d.Identifier)
	local vertex_uv: *e3d.Identifier = new(@e3d.Identifier)
	local vertex_color: *e3d.Identifier = new(@e3d.Identifier)
	vertex_struct.name = "vertex"
	$vertex_position = {name="position", index=0, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$vertex_normal = {name="normal", index=3, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$vertex_uv = {name="uv", index=6, type_info={e3d.EVMType.VEC2, self.struct_vec2}}
	$vertex_color = {name="color", index=8, type_info={e3d.EVMType.INT}}
	vertex_struct:addMember(vertex_position)
	vertex_struct:addMember(vertex_normal)
	vertex_struct:addMember(vertex_uv)
	vertex_struct:addMember(vertex_color)
	vertex_struct.is_complete = true

	-- define colsphere struct
	local colsphere_struct: *e3d.Struct = new(@e3d.Struct)
	local colsphere_position: *e3d.Identifier = new(@e3d.Identifier)
	local colsphere_radius: *e3d.Identifier = new(@e3d.Identifier)
	colsphere_struct.name = "colsphere"
	$colsphere_position = {name="position", index=0, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$colsphere_radius = {name="radius", index=3, type_info={e3d.EVMType.FLOAT}}
	colsphere_struct:addMember(colsphere_position)
	colsphere_struct:addMember(colsphere_radius)
	colsphere_struct.is_complete = true

	-- define colaabb struct
	local colaabb_struct: *e3d.Struct = new(@e3d.Struct)
	local colaabb_type: *e3d.Identifier = new(@e3d.Identifier)
	local colaabb_position: *e3d.Identifier = new(@e3d.Identifier)
	local colaabb_width: *e3d.Identifier = new(@e3d.Identifier)
	local colaabb_height: *e3d.Identifier = new(@e3d.Identifier)
	local colaabb_depth: *e3d.Identifier = new(@e3d.Identifier)
	colaabb_struct.name = "colaabb"
	$colaabb_type = {name="type", index=0, type_info={e3d.EVMType.INT}}
	$colaabb_position = {name="position", index=1, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$colaabb_width = {name="width", index=4, type_info={e3d.EVMType.FLOAT}}
	$colaabb_height = {name="height", index=5, type_info={e3d.EVMType.FLOAT}}
	$colaabb_depth = {name="depth", index=6, type_info={e3d.EVMType.FLOAT}}
	colaabb_struct:addMember(colaabb_type)
	colaabb_struct:addMember(colaabb_position)
	colaabb_struct:addMember(colaabb_width)
	colaabb_struct:addMember(colaabb_height)
	colaabb_struct:addMember(colaabb_depth)
	colaabb_struct.is_complete = true

	-- define colcylinder struct
	local colcylinder_struct: *e3d.Struct = new(@e3d.Struct)
	local colcylinder_position: *e3d.Identifier = new(@e3d.Identifier)
	local colcylinder_height: *e3d.Identifier = new(@e3d.Identifier)
	local colcylinder_radius: *e3d.Identifier = new(@e3d.Identifier)
	colcylinder_struct.name = "colcylinder"
	$colcylinder_position = {name="position", index=0, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$colcylinder_height = {name="height", index=3, type_info={e3d.EVMType.FLOAT}}
	$colcylinder_radius = {name="radius", index=4, type_info={e3d.EVMType.FLOAT}}
	colcylinder_struct:addMember(colcylinder_position)
	colcylinder_struct:addMember(colcylinder_height)
	colcylinder_struct:addMember(colcylinder_radius)
	colcylinder_struct.is_complete = true

	-- define coltriangle struct
	local coltriangle_struct: *e3d.Struct = new(@e3d.Struct)
	local coltriangle_point1: *e3d.Identifier = new(@e3d.Identifier)
	local coltriangle_point2: *e3d.Identifier = new(@e3d.Identifier)
	local coltriangle_point3: *e3d.Identifier = new(@e3d.Identifier)
	coltriangle_struct.name = "coltriangle"
	$coltriangle_point1 = {name="point1", index=0, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$coltriangle_point2 = {name="point2", index=3, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	$coltriangle_point3 = {name="point3", index=6, type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	coltriangle_struct:addMember(coltriangle_point1)
	coltriangle_struct:addMember(coltriangle_point2)
	coltriangle_struct:addMember(coltriangle_point3)
	coltriangle_struct.is_complete = true

	local builtin_structs: []e3d.Identifier = {
		{name="matrix",      type_info={e3d.EVMType.STRUCT, matrix_struct}},
		{name="vertex",      type_info={e3d.EVMType.STRUCT, vertex_struct}},
		{name="colsphere",   type_info={e3d.EVMType.STRUCT, colsphere_struct}},
		{name="colaabb",     type_info={e3d.EVMType.STRUCT, colaabb_struct}},
		{name="colcylinder", type_info={e3d.EVMType.STRUCT, colcylinder_struct}},
		{name="coltriangle", type_info={e3d.EVMType.STRUCT, coltriangle_struct}}
	}
	
	local keyword_ids: []e3d.Identifier = {
		{name="void",     token=e3d.Token.VOID},
		{name="int",      token=e3d.Token.INT},
		{name="float",    token=e3d.Token.FLOAT},
		{name="vec2",     token=e3d.Token.VEC2},
		{name="vec3",     token=e3d.Token.VEC3},
		{name="string",   token=e3d.Token.STRING},
		{name="enum",     token=e3d.Token.ENUM},
		{name="struct",   token=e3d.Token.STRUCT},
		{name="if",       token=e3d.Token.IF},
		{name="else",     token=e3d.Token.ELSE},
		{name="return",   token=e3d.Token.RETURN},
		{name="break",    token=e3d.Token.BREAK},
		{name="continue", token=e3d.Token.CONTINUE},
		{name="sizeof",   token=e3d.Token.SIZEOF},
		{name="for",      token=e3d.Token.FOR},
		{name="while",    token=e3d.Token.WHILE}
	}

	local constant_ids: []e3d.Identifier = {
		{name="true",  type_info={e3d.EVMType.INT},                        const_val=1},
		{name="false", type_info={e3d.EVMType.INT},                        const_val=0},
		{name="null",  type_info={e3d.EVMType.VOID + e3d.EVMType.POINTER}, const_val=e3d.NULL}
	}

	local constructor_ids: []e3d.Identifier = {
		{name="vec2Zero", type_info={e3d.EVMType.VEC2, self.struct_vec2}},
		{name="vec3Zero", type_info={e3d.EVMType.VEC3, self.struct_vec3}}
	}

	self.keywords:reserve(#keyword_ids)
	for i = 0, < #keyword_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = keyword_ids[i]
		id.class = e3d.Class.KEYWORD
		self.keywords[id.name] = id
	end

	self.constants:reserve(#constant_ids)
	for i = 0, < #constant_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constant_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.CONSTANT
		self.constants[id.name] = id
	end

	-- vector construction functions are special cases,
	-- they are translated directly to opcodes
	for i = 0, < #constructor_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = constructor_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		self.api_ids[id.name] = id
	end

	self.builtin_struct_ids:reserve(#builtin_structs)
	for i = 0, < #builtin_structs do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = builtin_structs[i]
		id.token = e3d.Token.STRUCT_ID
		id.class = e3d.Class.STRUCT
		self.builtin_struct_ids[id.name] = id
	end
end

function e3d.EVM:registerAPI(): void
	local matrix_struct: *e3d.Struct = self.builtin_struct_ids["matrix"].type_info.structref

	local api_ids: []e3d.Identifier = {
		{
			name="halt",
			type_info={e3d.EVMType.VOID},
			func=apiHalt
		},
		{
			name="vargc",
			type_info={e3d.EVMType.INT},
			func=apiVargc
		},
		{
			name="vargv",
			type_info={e3d.EVMType.VOID + e3d.EVMType.POINTER},
			argdata={{e3d.EVMType.INT}},
			func=apiVargv
		},
		{
			name="pressed",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPressed
		},
		{
			name="released",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiReleased
		},
		{
			name="held",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiHeld
		},
		{
			name="mini",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiMini
		},
		{
			name="maxi",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiMaxi
		},
		{
			name="midi",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiMidi
		},
		{
			name="wrapi",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiWrapi
		},
		{
			name="minf",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiMinf
		},
		{
			name="maxf",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiMaxf
		},
		{
			name="midf",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiMidf
		},
		{
			name="wrapf",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiWrapf
		},
		{
			name="signi",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiSigni
		},
		{
			name="signf",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiSignf
		},
		{
			name="fract",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiFract
		},
		{
			name="deg",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiDeg
		},
		{
			name="rad",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiRad
		},
		{
			name="sin",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiSin
		},
		{
			name="cos",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiCos
		},
		{
			name="floor",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiFloor
		},
		{
			name="ceil",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiCeil
		},
		{
			name="round",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiRound
		},
		{
			name="randomize",
			type_info={e3d.EVMType.VOID},
			func=apiRandomize
		},
		{
			name="randomizeEx",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiRandomizeEx
		},
		{
			name="randi",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiRandi
		},
		{
			name="randiEx",
			type_info={e3d.EVMType.INT},
			func=apiRandiEx
		},
		{
			name="randf",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiRandf
		},
		{
			name="randfEx",
			type_info={e3d.EVMType.FLOAT},
			func=apiRandfEx
		},
		{
			name="time",
			type_info={e3d.EVMType.FLOAT},
			func=apiTime
		},
		{
			name="vec2Length",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Length
		},
		{
			name="vec2LengthSq",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiVec2LengthSq
		},
		{
			name="vec2Normalize",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Normalize
		},
		{
			name="vec2Dot",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Dot
		},
		{
			name="vec2Cross",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Cross
		},
		{
			name="vec2Distance",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Distance
		},
		{
			name="vec2DistanceSq",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2DistanceSq
		},
		{
			name="vec2Direction",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Direction
		},
		{
			name="vec2Angle",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Angle
		},
		{
			name="vec2LineAngle",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2LineAngle
		},
		{
			name="vec2Lerp",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec2Lerp
		},
		{
			name="vec2Reflect",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiVec2Reflect
		},
		{
			name="vec2Rotate",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec2Rotate
		},
		{
			name="vec2MoveToward",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.VEC2, self.struct_vec2},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec2MoveToward
		},
		{
			name="vec2Invert",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiVec2Invert
		},
		{
			name="vec3Length",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Length
		},
		{
			name="vec3LengthSq",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiVec3LengthSq
		},
		{
			name="vec3Normalize",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Normalize
		},
		{
			name="vec3Dot",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Dot
		},
		{
			name="vec3Cross",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Cross
		},
		{
			name="vec3Distance",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Distance
		},
		{
			name="vec3DistanceSq",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3DistanceSq
		},
		{
			name="vec3Direction",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Direction
		},
		{
			name="vec3Angle",
			type_info={e3d.EVMType.FLOAT},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Angle
		},
		{
			name="vec3Lerp",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec3Lerp
		},
		{
			name="vec3Reflect",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiVec3Reflect
		},
		{
			name="vec3Rotate",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec3Rotate
		},
		{
			name="vec3MoveToward",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.FLOAT}
			},
			func=apiVec3MoveToward
		},
		{
			name="vec3Invert",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiVec3Invert
		},
		{
			name="vec3ToScreen",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={
				{e3d.EVMType.VEC3, self.struct_vec3},
				{e3d.EVMType.INT}
			},
			func=apiVec3ToScreen
		},
		{
			name="matrixIdentity",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			func=apiMatrixIdentity
		},
		{
			name="matrixAdd",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixAdd
		},
		{
			name="matrixSubtract",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixSubtract
		},
		{
			name="matrixMultiply",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiMatrixMultiply
		},
		{
			name="matrixTranslate",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixTranslate
		},
		{
			name="matrixRotate",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixRotate
		},
		{
			name="matrixScale",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiMatrixScale
		},
		{
			name="matrixTranspose",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={{e3d.EVMType.STRUCT, matrix_struct}},
			func=apiMatrixTranspose
		},
		{
			name="matrixInvert",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			argdata={{e3d.EVMType.STRUCT, matrix_struct}},
			func=apiMatrixInvert
		},
		{
			name="camera2D",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiCamera2D
		},
		{
			name="getCam2DOrigin",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam2DOrigin
		},
		{
			name="setCam2DOrigin",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiSetCam2DOrigin
		},
		{
			name="getCam2DTarget",
			type_info={e3d.EVMType.VEC2, self.struct_vec2},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam2DTarget
		},
		{
			name="setCam2DTarget",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC2, self.struct_vec2}
			},
			func=apiSetCam2DTarget
		},
		{
			name="getCam2DAngle",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam2DAngle
		},
		{
			name="setCam2DAngle",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.FLOAT}
			},
			func=apiSetCam2DAngle
		},
		{
			name="getCam2DZoom",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam2DZoom
		},
		{
			name="setCam2DZoom",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.FLOAT}
			},
			func=apiSetCam2DZoom
		},
		{
			name="camera3D",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiCamera3D
		},
		{
			name="getCam3DPosition",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DPosition
		},
		{
			name="setCam3DPosition",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiSetCam3DPosition
		},
		{
			name="getCam3DTarget",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DTarget
		},
		{
			name="setCam3DTarget",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiSetCam3DTarget
		},
		{
			name="getCam3DUp",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DUp
		},
		{
			name="setCam3DUp",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiSetCam3DUp
		},
		{
			name="getCam3DFOV",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DFOV
		},
		{
			name="setCam3DFOV",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.FLOAT}
			},
			func=apiSetCam3DFOV
		},
		{
			name="getCam3DProjection",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DProjection
		},
		{
			name="setCam3DProjection",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSetCam3DProjection
		},
		{
			name="getCam3DRight",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DRight
		},
		{
			name="getCam3DForward",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetCam3DForward
		},
		{
			name="viewport",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiViewport
		},
		{
			name="texture",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiTexture
		},
		{
			name="getTextureMode",
			type_info={e3d.EVMType.INT},
			func=apiGetTextureMode
		},
		{
			name="setTextureMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetTextureMode
		},
		{
			name="getCullMode",
			type_info={e3d.EVMType.INT},
			func=apiGetCullMode
		},
		{
			name="setCullMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetCullMode
		},
		{
			name="getWireMode",
			type_info={e3d.EVMType.INT},
			func=apiGetWireMode
		},
		{
			name="setWireMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetWireMode
		},
		{
			name="getFogMode",
			type_info={e3d.EVMType.INT},
			func=apiGetFogMode
		},
		{
			name="setFogMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetFogMode
		},
		{
			name="getFogStart",
			type_info={e3d.EVMType.FLOAT},
			func=apiGetFogStart
		},
		{
			name="setFogStart",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiSetFogStart
		},
		{
			name="getFogEnd",
			type_info={e3d.EVMType.FLOAT},
			func=apiGetFogEnd
		},
		{
			name="setFogEnd",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiSetFogEnd
		},
		{
			name="getFogColor",
			type_info={e3d.EVMType.INT},
			func=apiGetFogColor
		},
		{
			name="setFogColor",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetFogColor
		},
		{
			name="getBlendMode",
			type_info={e3d.EVMType.INT},
			func=apiGetBlendMode
		},
		{
			name="setBlendMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetBlendMode
		},
		{
			name="getLightingMode",
			type_info={e3d.EVMType.INT},
			func=apiGetLightingMode
		},
		{
			name="setLightingMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetLightingMode
		},
		{
			name="getAmbientFactor",
			type_info={e3d.EVMType.FLOAT},
			func=apiGetAmbientFactor
		},
		{
			name="setAmbientFactor",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.FLOAT}},
			func=apiSetAmbientFactor
		},
		{
			name="getAmbientColor",
			type_info={e3d.EVMType.INT},
			func=apiGetAmbientColor
		},
		{
			name="setAmbientColor",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiSetAmbientColor
		},
		{
			name="getLightEnabled",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightEnabled
		},
		{
			name="setLightEnabled",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSetLightEnabled
		},
		{
			name="getLightType",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightType
		},
		{
			name="setLightType",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSetLightType
		},
		{
			name="getLightRadius",
			type_info={e3d.EVMType.FLOAT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightRadius
		},
		{
			name="setLightRadius",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.FLOAT}
			},
			func=apiSetLightRadius
		},
		{
			name="getLightPosition",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightPosition
		},
		{
			name="setLightPosition",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiSetLightPosition
		},
		{
			name="getLightDirection",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightDirection
		},
		{
			name="setLightDirection",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.VEC3, self.struct_vec3}
			},
			func=apiSetLightDirection
		},
		{
			name="getLightColor",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiGetLightColor
		},
		{
			name="setLightColor",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSetLightColor
		},
		{
			name="clear",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiClear
		},
		{
			name="matrixMode",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiMatrixMode
		},
		{
			name="pushMatrix",
			type_info={e3d.EVMType.VOID},
			func=apiPushMatrix
		},
		{
			name="popMatrix",
			type_info={e3d.EVMType.VOID},
			func=apiPopMatrix
		},
		{
			name="getProjectionMatrix",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			func=apiGetProjectionMatrix
		},
		{
			name="setProjectionMatrix",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiSetProjectionMatrix
		},
		{
			name="getModelViewMatrix",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			func=apiGetModelViewMatrix
		},
		{
			name="setModelViewMatrix",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiSetModelViewMatrix
		},
		{
			name="getTopMatrix",
			type_info={e3d.EVMType.STRUCT, matrix_struct},
			func=apiGetTopMatrix
		},
		{
			name="multiplyTopMatrix",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.STRUCT, matrix_struct}
			},
			func=apiMultiplyTopMatrix
		},
		{
			name="identity",
			type_info={e3d.EVMType.VOID},
			func=apiIdentity
		},
		{
			name="translate",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiTranslate
		},
		{
			name="rotate",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiRotate
		},
		{
			name="scale",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiScale
		},
		{
			name="frustum",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiFrustum
		},
		{
			name="ortho",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT},
				{e3d.EVMType.FLOAT}
			},
			func=apiOrtho
		},
		{
			name="meshVertex",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiMeshVertex
		},
		{
			name="meshVertex2D",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiMeshVertex2D
		},
		{
			name="meshUV",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC2, self.struct_vec2}},
			func=apiMeshUV
		},
		{
			name="meshNormal",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.VEC3, self.struct_vec3}},
			func=apiMeshNormal
		},
		{
			name="meshColor",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiMeshColor
		},
		{
			name="beginMesh",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiBeginMesh
		},
		{
			name="endMesh",
			type_info={e3d.EVMType.VOID},
			func=apiEndMesh
		},
		{
			name="print2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.STRING, self.struct_string}
			},
			is_varargs=true,
			varargs_index=4,
			func=apiPrint2D
		},
		{
			name="sprite2D",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSprite2D
		},
		{
			name="sprite2DEx",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiSprite2DEx
		},
		{
			name="drawObj",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT}
			},
			func=apiDrawObj
		},
		{
			name="drawObjEx",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiDrawObjEx
		},
		{
			name="playSong",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiPlaySong
		},
		{
			name="playTrack",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPlayTrack
		},
		{
			name="playPattern",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPlayPattern
		},
		{
			name="playWav",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPlayWav
		},
		{
			name="playWavEx",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPlayWavEx
		},
		{
			name="pauseTracks",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiPauseTracks
		},
		{
			name="resumeTracks",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiResumeTracks
		},
		{
			name="stopTracks",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiStopTracks
		},
		{
			name="muteTracks",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiMuteTracks
		},
		{
			name="unmuteTracks",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiUnmuteTracks
		},
		{
			name="checkCollision",
			type_info={e3d.EVMType.INT},
			argdata={
				{e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{e3d.EVMType.VOID + e3d.EVMType.POINTER}
			},
			func=apiCheckCollision
		},
		{
			name="getCollisionPoint",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			func=apiGetCollisionPoint
		},
		{
			name="getCollisionNormal",
			type_info={e3d.EVMType.VEC3, self.struct_vec3},
			func=apiGetCollisionNormal
		},
		{
			name="loadTexBank",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiLoadTexBank
		},
		{
			name="loadObjBank",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiLoadObjBank
		},
		{
			name="loadWavBank",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiLoadWavBank
		},
		{
			name="loadSeqBank",
			type_info={e3d.EVMType.VOID},
			argdata={{e3d.EVMType.INT}},
			func=apiLoadSeqBank
		},
		{
			name="peek8",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiPeek8
		},
		{
			name="poke8",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPoke8
		},
		{
			name="peek32",
			type_info={e3d.EVMType.INT},
			argdata={{e3d.EVMType.INT}},
			func=apiPeek32
		},
		{
			name="poke32",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiPoke32
		},
		{
			name="memcpy",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{e3d.EVMType.INT}
			},
			func=apiMemcpy
		},
		{
			name="memset",
			type_info={e3d.EVMType.VOID},
			argdata={
				{e3d.EVMType.VOID + e3d.EVMType.POINTER},
				{e3d.EVMType.VOID + e3d.EVMType.INT},
				{e3d.EVMType.INT}
			},
			func=apiMemset
		},
	}

	self.api_ids:reserve(#api_ids + 2)
	for i = 0, < #api_ids do
		local id: *e3d.Identifier = new(@e3d.Identifier)
		$id = api_ids[i]
		id.token = e3d.Token.ID
		id.class = e3d.Class.API
		id.index = i
		self.api_ids[id.name] = id
		self.api_funcs[i] = id.func
	end
end
