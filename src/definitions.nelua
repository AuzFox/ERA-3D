require("sequence")
require("hashmap")
require("span")
require("stringbuilder")
require("filestream")

require("rayeasings")
require("blipkit")
require("raylib")
require("rlgl")
require("json")
require("tinyfiledialogs")

-- --------------------------------
-- CONSTANTS
-- --------------------------------

-- ERA-3D version info
global ERA_VER_MAJOR <comptime> = 0
global ERA_VER_MINOR <comptime> = 0
global ERA_VER_PATCH <comptime> = 0

-- EVM internal memory constants
global EVM_SRC_SIZE       <comptime> = 1024 * 1024
global EVM_OPSTACK_SIZE   <comptime> = 65536 -- 256KiB (65536 words)
global EVM_BYTECODE_SIZE  <comptime> = 131072 -- 128KiB (131072 bytes)
global EVM_CALLSTACK_SIZE <comptime> = 256
global EVM_API_FUNCS_SIZE <comptime> = 65536

--[[ VM logical memory map
note: 1 vm word = 4 bytes

SYSTEM MEMORY:
  HEAP              (8MiB          ) 0x00000000 - 0x007FFFFF (general purpose RAM)
  TEXMEM            (4MiB          ) 0x00800000 - 0x00BFFFFF (texture data (1024*1024, 32BPP))
  OBJMEM            (3MiB + 384KiB ) 0x00C00000 - 0x00F5FFFF (mesh data (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
  AOBMEM            (8KiB          ) 0x00F60000 - 0x00F61FFF (audio output buffer (2048 16bit stereo audio samples))
  SYSMEM            (632KiB        ) 0x00F62000 - 0x00FFFFFF (system state memory)
    audio state     (1B            )                         (1 byte (track playing flags))
    track state     (80B           )                         (8 * 10 bytes (playflags, bpm, volume, pan, song id+pos, pattern id+pos, groove id+pos))
    padding         (3B            )                         (unused)
    objmem map      (6KiB          )                         (OBJMEM map (512 entries; 3 words each (type, start, n)))
    wavmem map      (8KiB          )                         (WAVMEM map (512 entries; 4 words each (sample start, sample end, sustain start, sustain end)))
	3D cameras      (208B          ) 0x00F65854 - 0x00F65923 (3D camera data (4 cameras; 13 words each (pos, target, up, fov, near, far, projection)))
	2D cameras      (96B           ) 0x00F65924 - 0x00F65983 (2D camera data (4 cameras; 6 words each (offset, target, rotation, zoom)))
	lights          (320B          ) 0x00F65984 - 0x00F65AC3 (light data (8 lights; 10 words each (enabled, type, radius, color, position, direction)))
	render state    (???B          ) 0x00F65AC4 - 0x00FFFFFF (system render state registers; see RenderState record)
  WAVMEM            (7MiB          ) 0x01000000 - 0x016FFFFF (~1min 23s of audio wave data (22050hz, 16bit, stereo))
  SEQMEM            (256KiB        ) 0x01700000 - 0x0173FFFF (audio sequencer data)
    song data       (2KiB          )                         (256 * 8 bytes)
    pattern data    (80KiB         )                         (256 * 64 * 5 bytes (note, vol, instr, fx, arg))
    instrument data (6KiB + 256B   )                         (256 * 25 bytes (flags, sample start (24bit), sample end(24bit), sustain start (24bit), sustain end(24bit), attack, decay, sustain, release, name))
    groove data     (1KiB          )                         (16 * 64 bytes)
  GLOBALS           (256KiB        ) 0x01740000 - 0x0177FFFF (vm global variables (65536 vm words))
  LOCALS            (256KiB        ) 0x01780000 - 0x017BFFFF (vm local variables (65536 vm words))
  ARGS              (256KiB        ) 0x017C0000 - 0x017FFFFF (vm function arguments (65536 vm words))
CART ROM:
  TEXBANK[0-3]      (16MiB         ) 0x01800000 - 0x027FFFFF (4x texture sheets (1024*1024, 32BPP))
  OBJBANK[0-3]      (13MiB + 512KiB) 0x02800000 - 0x0357FFFF (4x mesh data buffers (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
  OMPBANK[0-3]      (1MiB + 256KiB ) 0x03580000 - 0x036BFFFF (4x maps for OBJBANK[0-3])
  WMPBANK[0-1]      (1MiB + 256KiB ) 0x036C0000 - 0x037FFFFF (2x maps for WAVBANK[0-1])
  WAVBANK[0-1]      (14MiB         ) 0x03800000 - 0x045FFFFF (2x wav data buffers (22050hz, 16bit, stereo))
  SEQBANK[0-7]      (2MiB          ) 0x04600000 - 0x047FFFFF (8x audio sequencer data buffers)
  ROM               (16MiB         ) 0x04800000 - 0x057FFFFF (string data + user ROM)
MEMORY CARD:
  MEMCARD           (4KiB          ) 0x05800000 - 0x05800FFF (persistent save data (4KiB per registered cart ID))
]]

-- memory size and address constants
##[[
local KiB = 1024
local MiB = (1024 * 1024)
local mem_regions = {
	-- system memory
	{name='HEAP',    size=8*MiB,             element_size=1},
	{name='TEXMEM',  size=4*MiB,             element_size=4},
	{name='OBJMEM',  size=(3*MiB + 384*KiB), element_size=4},
	{name='AOBMEM',  size=8*KiB,             element_size=2},
	{name='SYSMEM',  size=632*KiB,           element_size=1},
	{name='WAVMEM',  size=7*MiB,             element_size=2},
	{name='SEQMEM',  size=256*KiB,           element_size=1},
	{name='GLOBALS', size=256*KiB,           element_size=4},
	{name='LOCALS',  size=256*KiB,           element_size=4},
	{name='ARGS',    size=256*KiB,           element_size=4},

	-- cart data
	{name='TEXBANK', size=16*MiB,             element_size=4},
	{name='OBJBANK', size=(13*MiB + 512*KiB), element_size=4},
	{name='OMPBANK', size=(1*MiB + 256*KiB),  element_size=1},
	{name='WMPBANK', size=(1*MiB + 256*KiB),  element_size=1},
	{name='WAVBANK', size=14*MiB,             element_size=2},
	{name='SEQBANK', size= 2*MiB,             element_size=1},
	{name='ROM',     size=16*MiB,             element_size=1},

	-- memory card
	{name='MEMCARD', size=4*KiB, element_size=1}
}
]]

## local mem_region_offset = 0
## for _ , region in ipairs(mem_regions) do
	global #|"MEMORY_"..region.name..'_START_ADDR'|# <comptime> = #[mem_region_offset]#
    global #|"MEMORY_"..region.name..'_SIZE_BYTES'|# <comptime> = #[region.size]#
    global #|"MEMORY_"..region.name..'_SIZE_ELEMENTS'|# <comptime> = #[region.size // region.element_size]#

	## mem_region_offset = mem_region_offset + region.size
	
	global #|"MEMORY_"..region.name..'_MAX_ADDR'|# <comptime> = #[mem_region_offset - 1]#
## end

global MEMORY_OBJMAP_SIZE <comptime> = (512 * 12) -- 6KiB
global MEMORY_WAVMAP_SIZE <comptime> = (512 * 16) -- 8KiB
global MEMORY_CAMERAS3D_SIZE <comptime> = 208 -- 4 cameras * 13 words * 4 bytes
global MEMORY_CAMERAS2D_SIZE <comptime> = 96 -- 4 cameras * 6 words * 4 bytes
global MEMORY_LIGHTS_SIZE <comptime> = 320 -- 8 lights * 10 words * 4 bytes
global MEMORY_CAMERAS3D_INDEX <comptime> = (84 + MEMORY_OBJMAP_SIZE + MEMORY_WAVMAP_SIZE)
global MEMORY_CAMERAS2D_INDEX <comptime> = (MEMORY_CAMERAS3D_INDEX + MEMORY_CAMERAS3D_SIZE)
global MEMORY_LIGHTS_INDEX <comptime> = (MEMORY_CAMERAS2D_INDEX + MEMORY_CAMERAS2D_SIZE)
global MEMORY_RENDER_STATE_INDEX <comptime> = (MEMORY_LIGHTS_INDEX + MEMORY_LIGHTS_SIZE)
global MEMORY_MAX_ADDR <comptime> = #[mem_region_offset - 1]#
global MEMORY_NULL <comptime> = 0xFFFFFFFF

global GPU_ALPHA_BLACK <comptime> = 0x00000000
global GPU_ALPHA_WHITE <comptime> = 0xFFFFFF00
global GPU_ALPHA_GRAY  <comptime> = 0x808080C0
global GPU_ALPHA_DGRAY <comptime> = 0x484848C0
global GPU_BLACK       <comptime> = 0x000000FF
global GPU_LGRAY       <comptime> = 0xC3C3C3FF
global GPU_GRAY        <comptime> = 0x808080FF
global GPU_DGRAY       <comptime> = 0x484848FF
global GPU_WHITE       <comptime> = 0xFFFFFFFF
global GPU_RED         <comptime> = 0xFF6868FF
global GPU_ORANGE      <comptime> = 0xFFB762FF
global GPU_YELLOW      <comptime> = 0xFBFF70FF
global GPU_GREEN       <comptime> = 0x8FFF78FF
global GPU_LBLUE       <comptime> = 0x59F0FFFF
global GPU_BLUE        <comptime> = 0x5E9BFFFF
global GPU_PURPULE     <comptime> = 0x826DFFFF
global GPU_PINK        <comptime> = 0xFF7EFFFF
global GPU_PALETTE: []uint32 = {
	GPU_RED,
	GPU_ORANGE,
	GPU_YELLOW,
	GPU_GREEN,
	GPU_LBLUE,
	GPU_BLUE,
	GPU_PURPULE,
	GPU_PINK,
	GPU_WHITE,
	GPU_LGRAY,
	GPU_GRAY,
	GPU_DGRAY,
	GPU_BLACK,
	GPU_BLACK,
	GPU_BLACK,
	GPU_ALPHA_BLACK
}

-- screen dimentions (vscreen is console's virtual resolution)
global GPU_VSCREEN_W <comptime> = 640
global GPU_VSCREEN_H <comptime> = 360
global GPU_VSCREEN_HALF_W <comptime> = (GPU_VSCREEN_W /// 2)
global GPU_VSCREEN_HALF_H <comptime> = (GPU_VSCREEN_H /// 2)

global GPU_LINES <comptime> = 0
global GPU_TRIANGLES <comptime> = 1
global GPU_QUADS <comptime> = 2

global GPU_PROJECTION <comptime> = 0
global GPU_MODELVIEW <comptime> = 1

-- geometry face types
global GPU_FRONT <comptime> = 0
global GPU_BACK <comptime> = 1
global GPU_FRONT_AND_BACK <comptime> = 2

-- polygon modes
global GPU_POLY_POINTS <comptime> = 0
global GPU_POLY_LINES <comptime> = 1
global GPU_POLY_FILL <comptime> = 2

-- depth/stencil comparison functions
global GPU_LESS <comptime> = 0
global GPU_LEQUAL <comptime> = 1
global GPU_GREATER <comptime> = 2
global GPU_GEQUAL <comptime> = 3
global GPU_EQUAL <comptime> = 4
global GPU_NOTEQUAL <comptime> = 5
global GPU_ALWAYS <comptime> = 6
global GPU_NEVER <comptime> = 7

-- blend factors
global GPU_BLEND_ZERO <comptime> = 0
global GPU_BLEND_ONE <comptime> = 1
global GPU_SRC_COLOR <comptime> = 2
global GPU_ONE_MINUS_SRC_COLOR <comptime> = 3
global GPU_DST_COLOR <comptime> = 4
global GPU_ONE_MINUS_DST_COLOR <comptime> = 5
global GPU_SRC_ALPHA <comptime> = 6
global GPU_ONE_MINUS_SRC_ALPHA <comptime> = 7
global GPU_DST_ALPHA <comptime> = 8
global GPU_ONE_MINUS_DST_ALPHA <comptime> = 9
global GPU_CONSTANT_COLOR <comptime> = 10
global GPU_ONE_MINUS_CONSTANT_COLOR <comptime> = 11
global GPU_CONSTANT_ALPHA <comptime> = 12
global GPU_ONE_MINUS_CONSTANT_ALPHA <comptime> = 13
global GPU_SRC_ALPHA_SATURATE <comptime> = 14

-- blend equations
global GPU_ADD <comptime> = 0
global GPU_SUBTRACT <comptime> = 1
global GPU_REVERSE_SUBTRACT <comptime> = 2
global GPU_MIN <comptime> = 3
global GPU_MAX <comptime> = 4

-- stencil actions
global GPU_KEEP <comptime> = 0
global GPU_REPLACE <comptime> = 1
global GPU_INCR <comptime> = 2
global GPU_INCR_WRAP <comptime> = 3
global GPU_DECR <comptime> = 4
global GPU_DECR_WRAP <comptime> = 5
global GPU_STENCIL_ZERO <comptime> = 6
global GPU_INVERT <comptime> = 7

-- texture filter modes
global GPU_NEAREST <comptime> = 0
global GPU_LINEAR <comptime> = 1

-- render state masks and constants

-- flags byte 1 (flags_tmccsbfl)
global GPU_DEPTH_TEST_BIT <comptime> = 0b10000000
global GPU_DEPTH_MASK_BIT <comptime> = 0b01000000
global GPU_CULL_MODE_MASK <comptime> = 0b00110000
global GPU_STENCIL_BIT <comptime>    = 0b00001000
global GPU_BLENDING_BIT <comptime>   = 0b00000100
global GPU_FOG_BIT <comptime>        = 0b00000010
global GPU_LIGHTING_BIT <comptime>   = 0b00000001

-- flags byte 2 (flags_f0stt000)
global GPU_TEXTURE_FILTER_MASK <comptime> = 0b10000000
global GPU_SCISSOR_BIT <comptime>         = 0b00100000
global GPU_TEXTURE_MODE_MASK <comptime>   = 0b00011000

-- flags byte 3 (flags_00ppcccc)
global GPU_POLYGON_MODE_MASK <comptime> = 0b00110000
global GPU_COLOR_MASK_MASK <comptime>   = 0b00001111

global GPU_CLEAR_COLOR <comptime>   = 0b100
global GPU_CLEAR_DEPTH <comptime>   = 0b010
global GPU_CLEAR_STENCIL <comptime> = 0b001
global GPU_CLEAR_ALL <comptime>     = 0b111
global GPU_COLOR_MASK_R <comptime>   = 0b1000
global GPU_COLOR_MASK_G <comptime>   = 0b0100
global GPU_COLOR_MASK_B <comptime>   = 0b0010
global GPU_COLOR_MASK_A <comptime>   = 0b0001
global GPU_COLOR_MASK_ALL <comptime> = 0b1111

global GPU_TEXMEM_WIDTH <comptime> = 1024
global GPU_TEXMEM_HEIGHT <comptime> = 1024

global GPU_LIGHTS_COUNT <comptime> = 8
global GPU_CAMERAS_COUNT <comptime> = 4

global SOUNDCHIP_TRACK_COUNT <comptime> = 8
global SOUNDCHIP_SAMPLE_RATE <comptime> = 22050 -- 22050hz sample rate
global SOUNDCHIP_FRAMES_PER_UPDATE <comptime> = 896
global SOUNDCHIP_EMPTY_VALUE <comptime> = 0xFF
global SOUNDCHIP_NOTE_MUTE <comptime> = 0xFE
global SOUNDCHIP_NOTE_RELEASE <comptime> = 0xFD
global SOUNDCHIP_MIN_OCTAVE <comptime> = 0
global SOUNDCHIP_MAX_OCTAVE <comptime> = 7
global SOUNDCHIP_OCTAVE_SIZE <comptime> = 12

global SOUNDCHIP_SONG_SIZE <comptime> = 256 * 8
global SOUNDCHIP_PATTERN_ROW_SIZE <comptime> = 5
global SOUNDCHIP_PATTERN_SIZE <comptime> = 64 * SOUNDCHIP_PATTERN_ROW_SIZE
global SOUNDCHIP_PATTERN_COUNT <comptime> = 256
global SOUNDCHIP_INSTRUMENT_SIZE <comptime> = 25
global SOUNDCHIP_INSTRUMENT_COUNT <comptime> = 256
global SOUNDCHIP_GROOVE_SIZE <comptime> = 64
global SOUNDCHIP_GROOVE_COUNT <comptime> = 16

global SOUNDCHIP_PATTERN_DATA_START <comptime> = SOUNDCHIP_SONG_SIZE
global SOUNDCHIP_INSTRUMENT_DATA_START <comptime> = SOUNDCHIP_PATTERN_DATA_START + (SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)
global SOUNDCHIP_GROOVE_DATA_START <comptime> = SOUNDCHIP_INSTRUMENT_DATA_START + (SOUNDCHIP_INSTRUMENT_COUNT * SOUNDCHIP_INSTRUMENT_SIZE)

global VM_MAX_CYCLES <comptime> = 1066666 -- 1066666 cycles per frame (~64 million cycles per second)

global LOG_MAX_LINES <comptime> = 20
global LOG_H <comptime> = ((LOG_MAX_LINES + 1) * 9)

-- --------------------------------
-- ENUMS
-- --------------------------------

-- tokens used by the compiler
global Token = @enum {
	INT_LITERAL = 128, -- start at 128 to avoid conflicts with ASCII chars
	FLOAT_LITERAL,
	STRING_LITERAL,
	COMMENT, -- only used for code editor syntax highlighting
	UNKNOWN, -- only used for code editor syntax highlighting
	VOID,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT_ID, -- struct type id
	STRING,
	STRUCT,
	ENUM,
	ID,
	ELSE,
	IF,
	RETURN,
	BREAK,
	CONTINUE,
	SIZEOF,
	FOR,
	WHILE,
	VARARGS,
	LNOT,
	NOT,
	ASSIGN,
	COND,
	LOR,
	LAND,
	OR,
	XOR,
	AND,
	EQ,
	NE,
	LT,
	GT,
	LE,
	GE,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	ADD,
	SUB,
	MUL,
	DIV,
	MOD,
	ARROW,
	DOT,
	BRAK
}

-- opcodes used by the vm and emitted by the compiler
global Opcode = @enum {
	GET_G = 0,
	GET_GX,
	SET_G,
	SET_GX,
	NEW_L,
	DEL_L,
	GET_L,
	GET_LX,
	SET_L,
	SET_LX,
	GET_A,
	GET_AX,
	SET_A,
	SET_AX,
	GET_M,
	GET_MX,
	SET_M,
	SET_MX,
	GET_S,
	SET_S,
	ADDROF_G,
	ADDROF_L,
	ADDROF_A,
	PUSH_ZERO,
	PUSH_ZEROF,
	PUSH_ZERO_N,
	PUSH_ONE,
	PUSH_ONEF,
	PUSH_CHAR,
	PUSH_INT,
	PUSH_FLOAT,
	PUSH_VEC2_ZERO,
	PUSH_VEC2_ONE,
	PUSH_VEC2_UP,
	PUSH_VEC2_DOWN,
	PUSH_VEC2_LEFT,
	PUSH_VEC2_RIGHT,
	PUSH_VEC3_ZERO,
	PUSH_VEC3_ONE,
	PUSH_VEC3_UP,
	PUSH_VEC3_DOWN,
	PUSH_VEC3_LEFT,
	PUSH_VEC3_RIGHT,
	PUSH_VEC3_FORWARD,
	PUSH_VEC3_BACK,
	PUSH_STRING,
	SAVE_FPTR,
	DISCARD,
	NOT,
	OR,
	XOR,
	AND,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	NEG,
	NEGF,
	NEGV,
	ADD,
	ADDF,
	ADDV,
	ADDP,
	SUB,
	SUBF,
	SUBV,
	SUBP,
	MUL,
	MULF,
	MULV,
	DIV,
	DIVU,
	DIVF,
	DIVV,
	MOD,
	MODU,
	MODF,
	LNOT,
	LNOTP,
	LNOTFP,
	EQ,
	EQF,
	EQV,
	EQS,
	NE,
	NEF,
	NEV,
	NES,
	LTI,
	LTU,
	LTF,
	LTV,
	GTI,
	GTU,
	GTF,
	GTV,
	LEI,
	LEU,
	LEF,
	LEV,
	GEI,
	GEU,
	GEF,
	GEV,
	JUMP,
	JUMP_Z,
	JUMP_ZD,
	JUMP_NZD,
	JUMP_NULL,
	JUMP_NULLD,
	JUMP_NNULLD,
	JUMP_FPNULL,
	JUMP_FPNULLD,
	JUMP_FPNNULLD,
	CALL,
	CALL_FPTR,
	CALL_SAVED_FPTR,
	RETURN,
	VARGP,
	FTOI,
	ITOF,
	ITOB, -- int to bool, used by || and && operators
	PTOB, -- pointer to bool, used by || and && operators
	FPTOB, -- function pointer to bool, used by || and && operators
	API
}

global Class = @enum {
	KEYWORD = 0,
	API,
	CONSTANT,
	STRUCT,
	FUNCTION,
	MEMORY, -- only used when writing values into memory using pointers
	STRING, -- only used when writing characters to a string using indexing
	GLOBAL,
	ARG,
	LOCAL
}

global EVMType = @enum {
	VOID = 0,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT,
	STRING,
	FUNC_POINTER,
	POINTER = 16 -- repeatedly added to type id value to indicate pointer levels
}

-- vm multiplication opcode has several modes for multiplying different types
global MulVMode = @enum {
	INT_V2 = 0,
	INT_V3,
	FLOAT_V2,
	FLOAT_V3,
	V2_INT,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm division opcode has several modes for dividing different types
global DivVMode = @enum {
	V2_INT = 0,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm script hook function ids
global Hook = @enum {
	INIT = 0,
	UPDATE,
	DRAW,
	COUNT
}

global GPUBank = @enum {
	SYSTEM = 0,
	TEXBANK0 = 1,
	TEXBANK1,
	TEXBANK2,
	TEXBANK3,
	OBJBANK0 = 1,
	OBJBANK1,
	OBJBANK2,
	OBJBANK3
}

global RenderTexture = @enum {
    CODE = 0,
    TRACKER,
    MODEL,
    TEXTURE,
	COUNT
}

global LightAttribute = @enum {
	ENABLED = 0,
	TYPE,
	RADIUS,
	COLOR,
	POSITION,
	DIRECTION,
	COUNT -- not an actual attribute, used to count the number of attributes
}

global Icon = @enum {
	STATE_CODE = 0,
	STATE_TRACKER,
	STATE_MODEL,
	STATE_TEXTURE,
	TOOL_PENCIL,
	TOOL_LINE,
	TOOL_RECT,
	TOOL_ELIPSE,
	TOOL_BUCKET,
	TOOL_SELECT,
	COUNT -- not an actual icon, used to count the number of icons
}

global SoundchipBank = @enum {
	SYSTEM = 0,
	WAVBANK0 = 1,
	WAVBANK1,
	SEQBANK0 = 1,
	SEQBANK1,
	SEQBANK2,
	SEQBANK3,
	SEQBANK4,
	SEQBANK5,
	SEQBANK6,
	SEQBANK7
}

-- instrument flags byte:
-- W 0 0 0 0 0 LM
-- W = use sample start value as wavmap index
-- LM = loop mode (2 bits)
global InstrumentFlag = @enum {
	LOOP_OFF = 0,
	LOOP_FORWARD,
	LOOP_PINGPONG,
	LOOP_RANGE,
	LOOP_MASK = 0b00000011,
	MANUAL    = 0b10000000
}

-- playflags byte:
-- M L 0 0 0 0 PM
-- M = mute
-- L = loop
-- PM = play mode (2 bits)
global PlayFlag = @enum {
	PLAY_SONG = 0,
	PLAY_PATTERN,
	PLAY_SAMPLE,
	PLAY_MASK = 0b00000011,
	MUTE      = 0b10000000,
	LOOP      = 0b01000000
}

global StateID = @enum {
	STATE_SAME = 0xFF,
	STATE_LEFT = 0xFE,
	STATE_RIGHT = 0xFD,
    BOOT = 0,
    CODE,
    TRACKER,
    MODEL,
    TEXTURE,
    RUN,
    COUNT
}

global DialogID = @enum {
    NONE = 0,
	IMAGE_CONFIG,
	SAMPLE_CONFIG,
	MODEL_CONFIG,
    COUNT
}

global MenuAnimation = @enum {
    NONE = 0,
	STATE_SWITCH,
	DIALOG_OPENCLOSE,
	LOG_OPENCLOSE
}

global PopupState = @enum {
    HIDDEN = 0,
	ANIMATING,
	SHOWN
}

global LogState = @enum {
    NONE = 0,
	HIDDEN,
	SHOWN
}

global LogEntryType = @enum {
	INPUT = 0, -- used when logging user command input
	INFO,
	HOST_ERROR,
	COMPILE_ERROR,
	RUNTIME_ERROR
}

-- --------------------------------
-- RECORDS
-- --------------------------------

global EVM <forwarddecl> = @record {}

global Identifier <forwarddecl> = @record {}

global FuncPointerInfo <forwarddecl> = @record {}

global APIFunction: type = @function(): boolean

-- union used to store values of different types
global IntFloat = @union {
	i: int32,
	u: uint32,
	f: float32
}

-- record used to represet an ERA-C string struct
global EVMString = @record {
    len: uint32, -- string length
    data: uint32 -- string data virtual address
}

-- records used to represet ERA-C collision object structs
global ColPoint = @record {
    type: uint32,
    position: rl.vector3
}

global ColAABB = @record {
    type: uint32,
    position: rl.vector3,
    width: float32,
    height: float32,
    depth: float32
}

global ColSphere = @record {
    type: uint32,
    position: rl.vector3,
    radius: float32
}

global ColCylinder = @record {
    type: uint32,
    position: rl.vector3,
    height: float32,
    radius: float32
}

global ColTriangle = @record {
    type: uint32,
    point1: rl.vector3,
    point2: rl.vector3,
    point3: rl.vector3
}

-- record that tracks data used by the vm when calling functions
global CallFrame = @record {
    pc: uinteger,
    lbp: uinteger,
    argc: uint16,
    vargc: uint16, -- remaining vararg word count for function
    vargp: uint16, -- vararg pointer (argstack index to current vararg)
    vargf: boolean, -- vararg flag, true if the function for this frame is a varargs function
}

-- ERA-C struct metadata record used in the compiler
global Struct = @record {
    is_complete: boolean,
    size: uinteger,
    name: string,
    member_map: hashmap(string, uinteger),
    members: sequence(*Identifier)
}

global TypeInfo = @record {
	type_id: uinteger,
	structref: *Struct, -- only used when type_id is EVMType.STRUCT
	fptr_info: *FuncPointerInfo -- only used when type_id is EVMType.FUNC_POINTER
}

FuncPointerInfo = @record {
	return_type: TypeInfo,
	argdata: sequence(TypeInfo), -- used to track function pointer argument types
	is_varargs: boolean
}

global LoopInfo = @record {
    loop_start: uinteger,
    loop_step: uinteger,
    loop_end: uinteger,
    break_count: uinteger,
    step_count: uinteger,
    del_l_count: uinteger,
    has_step: boolean
}

Identifier = @record {
    name: string,
    token: uinteger,
    class: uinteger,
    index: uinteger,
    varargs_index: uinteger, -- only used for varargs functions
    type_info: TypeInfo,
    is_array: boolean,
    is_varargs: boolean, -- only used for functions
    const_val: uint32, -- only used for constants
    const_valf: float32, -- only used for constants
    func: APIFunction, -- only used when registering api functions
    argdata: sequence(TypeInfo) -- only used to track function arguments
}

global Cart = @record {
    texbank: [MEMORY_TEXBANK_SIZE_ELEMENTS]rl.color,
    objbank: [MEMORY_OBJBANK_SIZE_ELEMENTS]IntFloat,
    ompbank: [MEMORY_OMPBANK_SIZE_ELEMENTS]uint8,
    wmpbank: [MEMORY_WMPBANK_SIZE_ELEMENTS]uint8,
    wavbank: [MEMORY_WAVBANK_SIZE_ELEMENTS]BKFrame,
    seqbank: [MEMORY_SEQBANK_SIZE_ELEMENTS]uint8,
    rom: [MEMORY_ROM_SIZE_ELEMENTS]uint8,
}

-- rendertexture wrapper that also stores a stencil attachment
global GPURenderTexture = @record {
	rl_rendertexture: rl.renderTexture,
	stencil: rl.texture
}

-- memory-mapped 3D camera object
-- stored in SYSMEM
global EVMCam3D = @record {
	-- vec3 position
	position_x0: uint8,
	position_x1: uint8,
	position_x2: uint8,
	position_x3: uint8,
	position_y0: uint8,
	position_y1: uint8,
	position_y2: uint8,
	position_y3: uint8,
	position_z0: uint8,
	position_z1: uint8,
	position_z2: uint8,
	position_z3: uint8,

	-- vec3 target
	target_x0: uint8,
	target_x1: uint8,
	target_x2: uint8,
	target_x3: uint8,
	target_y0: uint8,
	target_y1: uint8,
	target_y2: uint8,
	target_y3: uint8,
	target_z0: uint8,
	target_z1: uint8,
	target_z2: uint8,
	target_z3: uint8,

	-- vec3 up
	up_x0: uint8,
	up_x1: uint8,
	up_x2: uint8,
	up_x3: uint8,
	up_y0: uint8,
	up_y1: uint8,
	up_y2: uint8,
	up_y3: uint8,
	up_z0: uint8,
	up_z1: uint8,
	up_z2: uint8,
	up_z3: uint8,

	-- float fov
	fov0: uint8,
	fov1: uint8,
	fov2: uint8,
	fov3: uint8,

	-- float near
	near0: uint8,
	near1: uint8,
	near2: uint8,
	near3: uint8,

	-- float far
	far0: uint8,
	far1: uint8,
	far2: uint8,
	far3: uint8,

	-- int projection
	projection0: uint8,
	projection1: uint8,
	projection2: uint8,
	projection3: uint8
}

-- memory-mapped 2D camera object
-- stored in SYSMEM
global EVMCam2D = @record {
	-- vec2 offset
	offset_x0: uint8,
	offset_x1: uint8,
	offset_x2: uint8,
	offset_x3: uint8,
	offset_y0: uint8,
	offset_y1: uint8,
	offset_y2: uint8,
	offset_y3: uint8,

	-- vec2 target
	target_x0: uint8,
	target_x1: uint8,
	target_x2: uint8,
	target_x3: uint8,
	target_y0: uint8,
	target_y1: uint8,
	target_y2: uint8,
	target_y3: uint8,

	-- float rotation
	rotation0: uint8,
	rotation1: uint8,
	rotation2: uint8,
	rotation3: uint8,

	-- float zoom
	zoom0: uint8,
	zoom1: uint8,
	zoom2: uint8,
	zoom3: uint8
}

-- memory-mapped light object
-- stored in SYSMEM
global EVMLight = @record {
	-- int enabled
	enabled0: uint8,
	enabled1: uint8,
	enabled2: uint8,
	enabled3: uint8,

	-- int type
	type0: uint8,
	type1: uint8,
	type2: uint8,
	type3: uint8,

	-- float radius
	radius0: uint8,
	radius1: uint8,
	radius2: uint8,
	radius3: uint8,

	-- int color
	color_r: uint8,
	color_g: uint8,
	color_b: uint8,
	color_a: uint8,

	-- vec3 position
	position_x0: uint8,
	position_x1: uint8,
	position_x2: uint8,
	position_x3: uint8,
	position_y0: uint8,
	position_y1: uint8,
	position_y2: uint8,
	position_y3: uint8,
	position_z0: uint8,
	position_z1: uint8,
	position_z2: uint8,
	position_z3: uint8,

	-- vec3 direction
	direction_x0: uint8,
	direction_x1: uint8,
	direction_x2: uint8,
	direction_x3: uint8,
	direction_y0: uint8,
	direction_y1: uint8,
	direction_y2: uint8,
	direction_y3: uint8,
	direction_z0: uint8,
	direction_z1: uint8,
	direction_z2: uint8,
	direction_z3: uint8
}

-- memory-mapped render state object
-- stored in SYSMEM
global RenderState = @record {
	-- ERA-C int-type state
	clear_color_r: uint8,
	clear_color_g: uint8,
	clear_color_b: uint8,
	clear_color_a: uint8,
	blend_color_r: uint8,
	blend_color_g: uint8,
	blend_color_b: uint8,
	blend_color_a: uint8,
	fog_color_r: uint8,
	fog_color_g: uint8,
	fog_color_b: uint8,
	fog_color_a: uint8,
	ambient_color_r: uint8,
	ambient_color_g: uint8,
	ambient_color_b: uint8,
	ambient_color_a: uint8,
	texture_x0: uint8,
	texture_x1: uint8,
	texture_x2: uint8,
	texture_x3: uint8,
	texture_y0: uint8,
	texture_y1: uint8,
	texture_y2: uint8,
	texture_y3: uint8,
	viewport_x0: uint8,
	viewport_x1: uint8,
	viewport_x2: uint8,
	viewport_x3: uint8,
	viewport_y0: uint8,
	viewport_y1: uint8,
	viewport_y2: uint8,
	viewport_y3: uint8,
	viewport_width0: uint8,
	viewport_width1: uint8,
	viewport_width2: uint8,
	viewport_width3: uint8,
	viewport_height0: uint8,
	viewport_height1: uint8,
	viewport_height2: uint8,
	viewport_height3: uint8,
	scissor_x0: uint8,
	scissor_x1: uint8,
	scissor_x2: uint8,
	scissor_x3: uint8,
	scissor_y0: uint8,
	scissor_y1: uint8,
	scissor_y2: uint8,
	scissor_y3: uint8,
	scissor_width0: uint8,
	scissor_width1: uint8,
	scissor_width2: uint8,
	scissor_width3: uint8,
	scissor_height0: uint8,
	scissor_height1: uint8,
	scissor_height2: uint8,
	scissor_height3: uint8,

	-- ERA-C float-type state
	clear_depth0: uint8,
	clear_depth1: uint8,
	clear_depth2: uint8,
	clear_depth3: uint8,
	fog_start0: uint8,
	fog_start1: uint8,
	fog_start2: uint8,
	fog_start3: uint8,
	fog_end0: uint8,
	fog_end1: uint8,
	fog_end2: uint8,
	fog_end3: uint8,
	ambient_factor0: uint8,
	ambient_factor1: uint8,
	ambient_factor2: uint8,
	ambient_factor3: uint8,

	-- single-byte state
	flags_tmccsbfl: uint8, -- TMCCSBFL (depth test, depth mask, cull, stencil, blending, fog, lighting)
	flags_f0stt000: uint8, -- F0STT000 (texture filter, 0, scissor test, texture mode, 0, 0, 0)
	flags_00ppcccc: uint8, -- 00PPCCCC (0, 0, polygon mode, color mask)
	stencil_functions: uint8, -- FFFFBBBB (front, back)

	stencil_mask_front: uint8,
	stencil_ref_front: uint8,
	stencil_func_mask_front: uint8,
	stencil_mask_back: uint8,

	stencil_ref_back: uint8,
	stencil_func_mask_back: uint8,
	stencil_sfails: uint8, -- FFFFBBBB (front, back)
	stencil_dpfails: uint8, -- FFFFBBBB (front, back)

	stencil_dppasses: uint8, -- FFFFBBBB (front, back)
	clear_stencil: uint8,
	depth_function: uint8,
	rgb_factors: uint8, -- SSSSDDDD (source, dest)

	alpha_factors: uint8, -- SSSSDDDD (source, dest)
	blend_equations: uint8, -- RRRRAAAA (rgb, alpha)
	texture_width: uint8,
	texture_height: uint8
}

-- holds graphics information for the vm
global GPU = @record {
	texmem: [MEMORY_TEXMEM_SIZE_ELEMENTS]rl.color,
	objmem: [MEMORY_OBJMEM_SIZE_ELEMENTS]IntFloat,
	system_cam3d: rl.camera,
	system_cam2d: rl.camera2D,
	gfx_master_rendertexture: rl.renderTexture,
	gfx_rendertextures: [RenderTexture.COUNT]rl.renderTexture,
	gfx_texture: rl.texture,
	gfx_shader: rl.shader,
	crt_shader: rl.shader,
	gfx_ui_texture: rl.texture, -- texture containing the default font and some UI icons
	gfx_checker_texture: rl.texture, -- texture containing a 32x32 checkerboard pattern
	gfx_rendertexture_index: uinteger,
	texbank_ptr: *[0]rl.color,
	objbank_ptr: *[0]IntFloat,
	ompbank_ptr: *[0]uint8,
	sysmem_ptr: *[0]uint8,
	texture_data: *[0]rl.color,
	model_data: *[0]IntFloat,
	objmap_data: *[0]uint8,
	cameras3D: *[0]EVMCam3D,
	cameras2D: *[0]EVMCam2D,
	lights: *[0]EVMLight,
	render_state: *RenderState,
	current_texbank: uint8,
	current_objbank: uint8,
	
	-- shader uniform locations
	mat_model_loc: cint,
	mat_normal_loc: cint,
	tex_mode_loc: cint,
	tex_x_loc: cint,
	tex_y_loc: cint,
	tex_w_loc: cint,
	tex_h_loc: cint,
	tex_filter_loc: cint,
	fog_mode_loc: cint,
	fog_start_loc: cint,
	fog_end_loc: cint,
	fog_color_loc: cint,
	lighting_mode_loc: cint,
	ambient_factor_loc: cint,
	ambient_color_loc: cint,
	crt_time_loc: cint,
	crt_brightness_loc: cint,
	crt_blur_loc: cint,
	crt_noise_loc: cint,
	crt_scanlines_loc: cint,

	update_tex: boolean, -- set when TEXMEM is updated. when set, TEXMEM is uploaded to the real GPU
	update_lights: boolean, -- set when SYSMEM lights are updated. when set, SYSMEM lights are updated on the real GPU

	-- "triangle mode" data
	--
	-- RLGL currently doesn't allow primitives created using RL_TRIANGLES to use UV coordinates for textures.
	-- to mimic textured triangles, we use use RL_QUADS and send a copy of the first vertex as the last quad vertex
	triangle_mode: boolean,
	triangle_vert_index: integer,

	proj_matrix_count: uinteger, -- used to track matrix stack
	view_matrix_count: uinteger, -- used to track matrix stack
	matrix_mode: uinteger,
	master_dest_rect: rl.rectangle,
	screen_w: int32,
	screen_h: int32,
	system_viewport_w: cint,
	system_viewport_h: cint,
	enable_flush: boolean -- when true, uploads matrices to shader and flushes render batch upon rlgl/raylib state change
}

global SoundChip <forwarddecl> = @record {}

global AudioState = @record {
    playing_flags: uint8
}

global TrackContext = @record {
    bk_track: BKTrack,
    bk_clock: BKClock,
    bk_divider: BKDivider,
    bk_instrument: BKInstrument,
    soundchip: *SoundChip,
    track_index: uint8
}

-- track state object, stored in sysmem
global TrackState = @record {
    playflags: uint8,
    bpm: uint8,
    volume: uint8,
    pan: int8,
    song_id: uint8,
    song_pos: uint8,
    pattern_id: uint8,
    pattern_pos: uint8,
    groove_id: uint8,
    groove_pos: uint8
}

SoundChip = @record {
    seqmem: [MEMORY_SEQMEM_SIZE_ELEMENTS]uint8, -- song, chain, phrase, instrument, and state data
    wavmem: [MEMORY_WAVMEM_SIZE_ELEMENTS]BKFrame, -- sample wave data
    aobmem: [MEMORY_AOBMEM_SIZE_ELEMENTS]BKFrame, -- working audio buffer
    track_contexts: [SOUNDCHIP_TRACK_COUNT]TrackContext,
    preview_bk_track: BKTrack,
    preview_bk_instrument: BKInstrument,
    bk_context: BKContext,
    bk_data: BKData,
    audio_stream: rl.audioStream,
    current_wavbank: uint8, -- which region of memory to use for sample data
    current_seqbank: uint8, -- which region of memory to use for sequencer data
    bk_data_flags: BKEnum, -- flags describing sample data format

    -- memory pointers
    sysmem_ptr: *[0]uint8,
    wmpbank_ptr: *[0]uint8,
    wavbank_ptr: *[0]BKFrame,
    seqbank_ptr: *[0]uint8,
    song_data: *[0]uint8,
    pattern_data: *[0]uint8,
    instrument_data: *[0]uint8,
    groove_data: *[0]uint8,
    wavmap_data: *[0]uint8,
    audio_state: *AudioState,
    track_state: *[0]uint8
}

global HeapBlock = @record {
	next: *HeapBlock,
	address: uint32,
	size: uint32,
	used: boolean
}

EVM = @record {
    -- vm vars
    heap: [MEMORY_HEAP_SIZE_ELEMENTS]uint8,
    globals: [MEMORY_GLOBALS_SIZE_ELEMENTS]IntFloat,
    locals: [MEMORY_LOCALS_SIZE_ELEMENTS]IntFloat,
    args: [MEMORY_ARGS_SIZE_ELEMENTS]IntFloat,
    opstack: [EVM_OPSTACK_SIZE]IntFloat,
    bytecode: [EVM_BYTECODE_SIZE]uint8,
    callstack: [EVM_CALLSTACK_SIZE]CallFrame,
    api_funcs: [EVM_API_FUNCS_SIZE]APIFunction,
    sysmem: [MEMORY_SYSMEM_SIZE_ELEMENTS]uint8,
	memcard: [MEMORY_MEMCARD_SIZE_ELEMENTS]uint8,
    cf: CallFrame,
    rom_len: uinteger,
    bytecode_len: uinteger,
    globals_len: uinteger,
    lsp: uinteger,
    asp: uinteger,
    ap: uinteger, -- ap for current function
    osp: uinteger,
    csp: uinteger,
	saved_fptr: uint32, -- temporary register for function pointers (used when calling a fptr from an expression)
    hook_addresses: [3]uint32,
    hook_flags: [3]boolean,
    current_hook: uinteger,
    objmap_ptr: *[0]uint8,
    wavmap_ptr: *[0]uint8,
	heap_head: *HeapBlock,
    
    -- compiler vars
    src_index: uinteger, -- line character index
    prev_src_index: uinteger,
    prev_line: uinteger,
	current_src_line: sequence(uint8),
    token: uinteger,
    token_val: uinteger,
    token_valf: float32,
    string_len: uinteger,
    prev_token: uinteger,
    prev_scope_size: uint16,
    line: uinteger,
    expr_type: TypeInfo,
    local_index: uinteger,
    mlcomment_level: uinteger,
    prev_opcode: uint8,
    has_id: boolean,
    skip_next_id_lookup: boolean,
    current_id: *Identifier,
    current_id_name: string,
    current_func_id: *Identifier,
    struct_vec2: *Struct,
    struct_vec3: *Struct,
    struct_string: *Struct,
    sb: stringbuilder,
    keywords: hashmap(string, *Identifier),
    constants: hashmap(string, *Identifier),
    api_ids: hashmap(string, *Identifier),
    builtin_struct_ids: hashmap(string, *Identifier),
    struct_ids: hashmap(string, *Identifier),
    sym_tables: sequence(*hashmap(string, *Identifier)),
    scope_sizes: sequence(uinteger),
    loop_info_stack: sequence(LoopInfo),
    loop_break_stack: sequence(uint32),
    loop_step_stack: sequence(uint32),
    loop_del_l_stack: sequence(uint32),
	funcmap: hashmap(uint32, boolean), -- used to determine if bytecode function pointers are legit
    
    -- general vars
    cart: Cart,
    temp_cart: Cart, -- used for temp storage while saving cart data
    soundchip: SoundChip,
    gpu: GPU,
    error: string,
    init_time: float64,
    cycle_count: uint64,
	memcard_id: string,
	memcard_initialized: boolean
}

global State <forwarddecl> = @record {}
global StateMachine <forwarddecl> = @record {}

global StateFunction: type = @function(): void

State = @record {
	init: StateFunction,
	enter: StateFunction,
	exit: StateFunction,
	update: StateFunction,
	draw: StateFunction,
	cleanup: StateFunction
}

global Dialog = @record {
	reset: StateFunction,
	update: StateFunction,
	draw: StateFunction
}

StateMachine = @record {
	states: [StateID.COUNT]State,
	dialogs: [DialogID.COUNT]Dialog,
	state_ptr: *State,
	dialog_ptr: *Dialog,
	state_id: integer,
	dialog_id: integer,
	queued_state: integer,
	queued_dialog: integer,
	prev_state: integer
}

-- config file data record
global ConfigInfo = @record {
	log_level: cint,
	vsync: boolean,
	highdpi: boolean,
	draw_fps: boolean,
	crt_blur: boolean,
	crt_noise: boolean,
	crt_scanlines: boolean
}

-- global data record
global CoreData = @record {
	-- menu animation data
	animation_type: uint32,
	anim_time: float32,
	anim_beginning: float32,
	anim_target: float32,
	-- 3D menu swapping animation
	facing_angle: float32,
	-- dialog open/close animation
	dialog_size: float32,

	log_text: [LOG_MAX_LINES * (GPU_VSCREEN_W /// 6) + 1]cchar, -- log text buffer
	log_types: [LOG_MAX_LINES]uint8, -- log line types, 1 LogEntryType per line
	log_command_buffer: [(GPU_VSCREEN_W /// 6) + 1]uint8, -- log console command text buffer
	log_command_str: string,
	log_command_args: sequence(string),
	log_command_split_index: uinteger,
	log_update_fn: function(): void,
	log_draw_fn: function(int32): void,
	log_prev_update_fn: function(): void,
	log_prev_draw_fn: function(int32): void,
	api_current_list: sequence(string),
	api_list_catagory: integer,
	api_list_index: integer,
	current_doc_str: string,

	text_buffer: *[0]uint8,
	src_lines: sequence(sequence(uint8)),
	recycled_lines: sequence(sequence(uint8)),
	current_line: sequence(uint8),
    line_index: int32,
    char_index: int32,
	start_line: int32, -- line index to start drawing from
	start_char: int32, -- char index to start drawing from

	config: ConfigInfo,

	user_directory: string,
	data_directory: string,
	carts_directory: string,
	memcards_directory: string,
	current_cart_path: string,
	current_cart_name: string,
	config_file_path: string,
	popup_text: string,
	popup_state: integer,
	popup_timer: float32,
	popup_beginning_factor: float32,
	popup_target_factor: float32,
	popup_current_factor: float32,
	popup_offset: int32,
	popup_color: uint32,
	image_to_import: rl.image,
	import_texture: rl.texture,
	sample_frame_count: uint64,
	model_to_import: rl.model,
	model_vertex_count: uint32,
	log_index: integer,
	log_count: integer,
	log_offset: float32,
	log_state: integer,
	queued_log_state: integer,
	has_loaded_image: boolean,
	has_import_texture: boolean,
	has_loaded_model: boolean,

	cursor_color: uint32,
	cursor_color_dark: uint32
}

function CoreData:setDefaultConfig(): void
	self.config.log_level = rl.traceLogLevel.NONE
	self.config.vsync = true
	self.config.highdpi = true
	self.config.draw_fps = false
	self.config.crt_blur = true
	self.config.crt_noise = true
	self.config.crt_scanlines = true
end

function CoreData:loadConfigFile(): void
	local fs, err, errcode = filestream.open(self.config_file_path, "r")
	if not fs:isopen() then
		self:setDefaultConfig()
		return
	end
	
	local text: string
	local errmsg: string
	local errcode: integer
	text, errmsg, errcode = fs:read("a")

	self.config = json.parse(text, @ConfigInfo)

	fs:close()
	
	-- validate
	if self.config.log_level < 0 or self.config.log_level > rl.traceLogLevel.NONE then
		self.config.log_level = rl.traceLogLevel.NONE
	end
end

function CoreData:saveConfigFile(): void
	local fs, err, errcode = filestream.open(self.config_file_path, "w")
	if not fs:isopen() then
		return
	end
	
	local text: string = json.emit(self.config)
	fs:write(text)

	fs:close()
end

-- display popup message
function CoreData:popup(message_type: uint8, text: string): void
	self.popup_text = text
	self.popup_state = PopupState.ANIMATING
	self.popup_timer = 0.0
	self.popup_target_factor = 1.0
	self.popup_beginning_factor = 0.0
	self.popup_current_factor = 0.0
	self.popup_offset = 0

	switch message_type do
		case LogEntryType.INFO then
			self.popup_color = GPU_GREEN
		case LogEntryType.HOST_ERROR then
			self.popup_color = GPU_YELLOW
		case LogEntryType.COMPILE_ERROR then
			self.popup_color = GPU_ORANGE
		case LogEntryType.RUNTIME_ERROR then
			self.popup_color = GPU_RED
	end
end

function CoreData:clearConsoleCommand(): void
	self.log_command_str.size = 0
end

function CoreData:getNextCommandArg(): (boolean, string)
	local succees: boolean = false
	local arg: string = {nilptr, 0}

	local in_arg: boolean = false
	local c: uint8

	while true do
		if self.log_command_split_index > self.log_command_str.size then
			if in_arg then
				arg[#arg + 1] = '\0'_u8
			end

			break
		end

		c = self.log_command_str[self.log_command_split_index]

		if in_arg then
			if c == ' '_u8 then
				arg[#arg + 1] = '\0'_u8
				in_arg = false
				break
			else
				arg.size = arg.size + 1
			end
		else
			if c ~= ' '_u8 and c ~= '\0'_u8 then
				-- establish arg string
				arg = (@string){
					(@*[0]uint8)(&self.log_command_buffer[self.log_command_split_index - 1]),
					1
				}
				in_arg = true
				succees = true
			end
		end

		self.log_command_split_index = self.log_command_split_index + 1
	end

	return succees, arg
end

function CoreData:splitConsoleCommand(): void
	self.log_command_args:clear()
	
	if self.log_command_str.size == 0 then
		return
	end
	
	self.log_command_split_index = 1
	
	while true do
		local arg: string
		local succees: boolean
		succees, arg = self:getNextCommandArg()
		if not succees then
			break
		end
		
		self.log_command_args:push(arg)
	end
end

function CoreData:insertConsoleChar(c: uint8): void
	if self.log_command_str.size >= (GPU_VSCREEN_W /// 6) - 1 then
		return
	end

	if self.log_command_str.size == 0 then
		self.log_command_str[1] = c
	else
		self.log_command_str[#self.log_command_str + 1] = c
	end

	self.log_command_str.size = self.log_command_str.size + 1
end

function CoreData:deleteConsoleChar(): void
	if self.log_command_str.size > 0 then
		self.log_command_str[#self.log_command_str] = '\0'_u8
		self.log_command_str.size = self.log_command_str.size - 1
	end
end

function CoreData:clearLog(): void
	self.log_index = 0
	self.log_count = 0
end

-- add string to log
function CoreData:log(entry_type: uint8, text: string, make_popup: boolean): void
	local line_ptr: *[0]cchar = (@*[0]cchar)(&self.log_text[self.log_index * (GPU_VSCREEN_W /// 6) + 1])
	local char_index: uint8 = 0

	for i = 1, <= #text do
		local c: cchar = text[i]

		if c ~= '\n'_u8 then
			line_ptr[char_index] = c
			char_index = char_index + 1
		end

		if (char_index == (GPU_VSCREEN_W /// 6)) or (c == '\n'_u8) or (i == #text) then
			line_ptr[char_index] = '\0'_u8 -- terminate line
			self.log_types[self.log_index] = entry_type -- set line type
			self.log_index = self.log_index + 1
			
			-- increment log index and wrap if needed
			if self.log_index == LOG_MAX_LINES then
				self.log_index = 0
			end

			-- increment log size if needed
			if self.log_count < LOG_MAX_LINES then
				self.log_count = self.log_count + 1
			end

			line_ptr = (@*[0]cchar)(&self.log_text[self.log_index * (GPU_VSCREEN_W /// 6) + 1]) -- update line pointer
			char_index = 0 -- set cursor to start of line
		end
	end

	if make_popup then
		self:popup(entry_type, text)
	end
end

function CoreData:changeCharacterIndex(new_index: int32): void
	self.char_index = math.clamp(new_index, 1, #self.current_line)

	-- TODO: change 98's and 99's to (80 - chars_needed_for_line_number_bar)

	if self.char_index < self.start_char + 1 then
		self.start_char = math.max(self.char_index - 1, 1)
	elseif self.char_index > self.start_char + 98 then
		self.start_char = math.clamp(self.char_index - 98, 1, math.max(1, #self.current_line - 99))
	end

	if self.line_index < self.start_line + 1 then
		self.start_line = math.max(self.line_index - 1, 1)
	elseif self.line_index > self.start_line + 36 then
		self.start_line = math.clamp(self.line_index - 36, 1, math.max(1, #self.src_lines - 37))
	end
end

function CoreData:changeCodeLine(index: int32): void
    self.line_index = math.clamp(index, 1, #self.src_lines)
    self.current_line = self.src_lines[self.line_index]
    self:changeCharacterIndex(self.char_index)
end

function CoreData:getNewLine(): sequence(uint8)
    if #self.recycled_lines > 0 then
        return self.recycled_lines:pop()
    else
        return {'\0'_u8}
    end
end

function CoreData:appendLine(): void
    self.src_lines:push(self:getNewLine())
end

function CoreData:insertLine(index: usize): void
    self.src_lines:insert(index, self:getNewLine())
end

function CoreData:deleteLine(index: usize): void
    local line: sequence(uint8) = self.src_lines:remove(index)
    line:clear()
    line:push('\0'_u8)
    self.recycled_lines:push(line)
end

function CoreData:insertChar(c: uint8): void
    self.current_line:insert(self.char_index, c)
    self:changeCharacterIndex(self.char_index + 1)
end

function CoreData:deleteChar(forward: boolean): void
    if forward then
        if self.char_index < #self.current_line then
            self.current_line:remove(self.char_index)
        elseif self.char_index == #self.current_line and self.line_index < #self.src_lines then
            -- append next line to end of current
            local next_line: sequence(uint8) = self.src_lines[self.line_index + 1]
    
            self.current_line:pop() -- remove terminator
            for i = 1, <= #next_line do
                self.current_line:push(next_line[i])
            end
    
            self:deleteLine(self.line_index + 1)
        end
    else
        if self.char_index > 1 then
            self:changeCharacterIndex(self.char_index - 1)
            self.current_line:remove(self.char_index)
        elseif self.char_index == 1 and self.line_index > 1 then
            -- append current line to end of previous
            local prev_line: sequence(uint8) = self.src_lines[self.line_index - 1]
            local new_index: int32 = (@int32)(#prev_line)
    
            prev_line:pop() -- remove terminator
            for i = 1, < #self.current_line do
                prev_line:push(self.current_line[i])
            end
            prev_line:push('\0'_u8)
    
            self:deleteLine(self.line_index)
            self:changeCodeLine(self.line_index - 1)
            self:changeCharacterIndex(new_index)
        end
    end
end

function CoreData:clearSrc(): void
	for i = #self.src_lines, >= 1, -1 do
		self:deleteLine(i)
	end
	self.line_index = 1
	self.char_index = 1
	self.start_line = 1
	self.start_char = 1
end

global core: CoreData
global statemachine: StateMachine
global vm: *EVM
global gpu: *GPU
global soundchip: *SoundChip
