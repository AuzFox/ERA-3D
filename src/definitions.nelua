require("sequence")
require("hashmap")
require("span")
require("stringbuilder")

require("rayeasings")
require("blipkit")
require("raylib")
require("rlgl")

-- --------------------------------
-- CONSTANTS
-- --------------------------------

-- ERA-3D version info
global ERA_VER_MAJOR <comptime> = 0
global ERA_VER_MINOR <comptime> = 0
global ERA_VER_PATCH <comptime> = 0

-- EVM internal memory constants
global EVM_SRC_SIZE       <comptime> = 1024 * 1024
global EVM_OPSTACK_SIZE   <comptime> = 65536 -- 256KiB (65536 words)
global EVM_BYTECODE_SIZE  <comptime> = 65536 -- 64KiB (65536 bytes)
global EVM_CALLSTACK_SIZE <comptime> = 256
global EVM_API_FUNCS_SIZE <comptime> = 65536

--[[ VM logical memory map
	note: 1 vm word = 4 bytes

	SYSTEM MEMORY:
		HEAP                (8MiB          ) 0x00000000 - 0x007FFFFF (general purpose RAM)
		TEXMEM              (4MiB          ) 0x00800000 - 0x00BFFFFF (texture data (1024*1024, 32BPP))
		OBJMEM              (3MiB + 384KiB ) 0x00C00000 - 0x00F5FFFF (mesh data (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
		AOBMEM              (8KiB          ) 0x00F60000 - 0x00F61FFF (audio output buffer (2048 16bit stereo audio samples))
		SYSMEM              (632KiB        ) 0x00F62000 - 0x00FFFFFF (system state registers)
			audio state     (1B            )                         (1 byte (track playing flags))
			track state     (80B           )                         (8 * 10 bytes (playflags, bpm, volume, pan, song id+pos, pattern id+pos, groove id+pos))
			padding         (3B            )                         (unused)
			objmem map      (6KiB          )                         (OBJMEM map (512 entries; 3 words each (type, start, n)))
			wavmem map      (8KiB          )                         (WAVMEM map (512 entries; 4 words each (sample start, sample end, sustain start, sustain end)))
		WAVMEM              (7MiB          ) 0x01000000 - 0x016FFFFF (~1min 23s of audio wave data (22050hz, 16bit, stereo))
		SEQMEM              (256KiB        ) 0x01700000 - 0x0173FFFF (audio sequencer data)
			song data       (2KiB          )                         (256 * 8 bytes)
			pattern data    (80KiB         )                         (256 * 64 * 5 bytes (note, vol, instr, fx, arg))
			instrument data (6KiB + 256B   )                         (256 * 25 bytes (flags, sample start (24bit), sample end(24bit), sustain start (24bit), sustain end(24bit), attack, decay, sustain, release, name))
			groove data     (1KiB          )                         (16 * 64 bytes)
			unused          (???KiB + ???B )                         (unused)
		GLOBALS             (256KiB        ) 0x01740000 - 0x0177FFFF (vm global variables (65536 vm words))
		LOCALS              (256KiB        ) 0x01780000 - 0x017BFFFF (vm local variables (65536 vm words))
		ARGS                (256KiB        ) 0x017C0000 - 0x017FFFFF (vm function arguments (65536 vm words))
	CART ROM:
		TEXBANK[0-3]        (16MiB         ) 0x01800000 - 0x027FFFFF (4x texture sheets (1024*1024, 32BPP))
		OBJBANK[0-3]        (13MiB + 512KiB) 0x02800000 - 0x0357FFFF (4x mesh data buffers (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
		OMPBANK[0-3]        (1MiB + 256KiB ) 0x03580000 - 0x036BFFFF (4x maps for OBJBANK[0-3])
		WMPBANK[0-1]        (1MiB + 256KiB ) 0x036C0000 - 0x037FFFFF (2x maps for WAVBANK[0-1])
		WAVBANK[0-1]        (14MiB         ) 0x03800000 - 0x045FFFFF (2x wav data buffers (22050hz, 16bit, stereo))
		SEQBANK[0-7]        (2MiB          ) 0x04600000 - 0x047FFFFF (8x audio sequencer data buffers)
		ROM                 (16MiB         ) 0x04800000 - 0x057FFFFF (string data + user ROM)
	MEMORY CARD:
		MEMCARD             (256KiB        ) 0x05800000 - 0x0583FFFF (persistent save data (256KiB per registered cart ID))
]]

-- memory size and address constants
##[[
local KiB = 1024
local MiB = (1024 * 1024)
local mem_regions = {
	-- system memory
	{name='HEAP',    size=8*MiB,             element_size=1},
	{name='TEXMEM',  size=4*MiB,             element_size=4},
	{name='OBJMEM',  size=(3*MiB + 384*KiB), element_size=4},
	{name='AOBMEM',  size=8*KiB,             element_size=2},
	{name='SYSMEM',  size=632*KiB,           element_size=1},
	{name='WAVMEM',  size=7*MiB,             element_size=2},
	{name='SEQMEM',  size=256*KiB,           element_size=1},
	{name='GLOBALS', size=256*KiB,           element_size=4},
	{name='LOCALS',  size=256*KiB,           element_size=4},
	{name='ARGS',    size=256*KiB,           element_size=4},

	-- cart data
	{name='TEXBANK', size=16*MiB,             element_size=4},
	{name='OBJBANK', size=(13*MiB + 512*KiB), element_size=4},
	{name='OMPBANK', size=(1*MiB + 256*KiB),  element_size=1},
	{name='WMPBANK', size=(1*MiB + 256*KiB),  element_size=1},
	{name='WAVBANK', size=14*MiB,             element_size=2},
	{name='SEQBANK', size= 2*MiB,             element_size=1},
	{name='ROM',     size=16*MiB,             element_size=1},

	-- memory card
	{name='MEMCARD', size=256*KiB, element_size=1}
}
]]

## local mem_region_offset = 0
## for _ , region in ipairs(mem_regions) do
	global #|"MEMORY_"..region.name..'_START_ADDR'|# <comptime> = #[mem_region_offset]#
    global #|"MEMORY_"..region.name..'_SIZE_BYTES'|# <comptime> = #[region.size]#
    global #|"MEMORY_"..region.name..'_SIZE_ELEMENTS'|# <comptime> = #[region.size // region.element_size]#

	## mem_region_offset = mem_region_offset + region.size
	
	global #|"MEMORY_"..region.name..'_MAX_ADDR'|# <comptime> = #[mem_region_offset - 1]#
## end

global MEMORY_OBJMAP_SIZE <comptime> = (512 * 12) -- 6KiB
global MEMORY_WAVMAP_SIZE <comptime> = (512 * 16) -- 8KiB
global MEMORY_MAX_ADDR <comptime> = #[mem_region_offset - 1]#
global MEMORY_NULL <comptime> = 0xFFFFFFFF

global GPU_ALPHA_BLACK <comptime> = 0x00000000
global GPU_ALPHA_WHITE <comptime> = 0xFFFFFF00
global GPU_BLACK       <comptime> = 0x000000FF
global GPU_LGRAY       <comptime> = 0xC3C3C3FF
global GPU_GRAY        <comptime> = 0x808080FF
global GPU_DGRAY       <comptime> = 0x484848FF
global GPU_WHITE       <comptime> = 0xFFFFFFFF
global GPU_RED         <comptime> = 0xFF6868FF
global GPU_ORANGE      <comptime> = 0xFFB762FF
global GPU_YELLOW      <comptime> = 0xFBFF70FF
global GPU_GREEN       <comptime> = 0x8FFF78FF
global GPU_LBLUE       <comptime> = 0x59F0FFFF
global GPU_BLUE        <comptime> = 0x5E9BFFFF
global GPU_PURPULE     <comptime> = 0x826DFFFF
global GPU_PINK        <comptime> = 0xFF7EFFFF
global GPU_PALETTE: []uint32 = {
	GPU_RED,
	GPU_ORANGE,
	GPU_YELLOW,
	GPU_GREEN,
	GPU_LBLUE,
	GPU_BLUE,
	GPU_PURPULE,
	GPU_PINK
}

-- screen dimentions (vscreen is console's virtual resolution)
global GPU_VSCREEN_W <comptime> = 480
global GPU_VSCREEN_H <comptime> = 360
global GPU_SCREEN_SCALE <comptime> = 2
global GPU_VSCREEN_HALF_W <comptime> = (GPU_VSCREEN_W /// 2)
global GPU_VSCREEN_HALF_H <comptime> = (GPU_VSCREEN_H /// 2)
global GPU_SCREEN_W <comptime> = (GPU_VSCREEN_W * GPU_SCREEN_SCALE)
global GPU_SCREEN_H <comptime> = (GPU_VSCREEN_H * GPU_SCREEN_SCALE)

global GPU_LINES <comptime> = 0
global GPU_TRIANGLES <comptime> = 1
global GPU_QUADS <comptime> = 2
global GPU_PROJECTION <comptime> = 0
global GPU_MODELVIEW <comptime> = 1

global GPU_TEXMEM_WIDTH <comptime> = 1024
global GPU_TEXMEM_HEIGHT <comptime> = 1024

global GPU_LIGHTS_COUNT <comptime> = 8
global GPU_CAMERAS_COUNT <comptime> = 4

global SOUNDCHIP_TRACK_COUNT <comptime> = 8
global SOUNDCHIP_SAMPLE_RATE <comptime> = 22050 -- 22050hz sample rate
global SOUNDCHIP_FRAMES_PER_UPDATE <comptime> = 2048
global SOUNDCHIP_EMPTY_VALUE <comptime> = 0xFF
global SOUNDCHIP_NOTE_MUTE <comptime> = 0xFE
global SOUNDCHIP_NOTE_RELEASE <comptime> = 0xFD
global SOUNDCHIP_MIN_OCTAVE <comptime> = 0
global SOUNDCHIP_MAX_OCTAVE <comptime> = 7
global SOUNDCHIP_OCTAVE_SIZE <comptime> = 12

global SOUNDCHIP_SONG_SIZE <comptime> = 256 * 8
global SOUNDCHIP_PATTERN_ROW_SIZE <comptime> = 5
global SOUNDCHIP_PATTERN_SIZE <comptime> = 64 * SOUNDCHIP_PATTERN_ROW_SIZE
global SOUNDCHIP_PATTERN_COUNT <comptime> = 256
global SOUNDCHIP_INSTRUMENT_SIZE <comptime> = 25
global SOUNDCHIP_INSTRUMENT_COUNT <comptime> = 256
global SOUNDCHIP_GROOVE_SIZE <comptime> = 64
global SOUNDCHIP_GROOVE_COUNT <comptime> = 16

global SOUNDCHIP_PATTERN_DATA_START <comptime> = SOUNDCHIP_SONG_SIZE
global SOUNDCHIP_INSTRUMENT_DATA_START <comptime> = SOUNDCHIP_PATTERN_DATA_START + (SOUNDCHIP_PATTERN_COUNT * SOUNDCHIP_PATTERN_SIZE)
global SOUNDCHIP_GROOVE_DATA_START <comptime> = SOUNDCHIP_INSTRUMENT_DATA_START + (SOUNDCHIP_INSTRUMENT_COUNT * SOUNDCHIP_INSTRUMENT_SIZE)

-- --------------------------------
-- ENUMS
-- --------------------------------

-- tokens used by the compiler
global Token = @enum {
	INT_LITERAL = 128, -- start at 128 to avoid conflicts with ASCII chars
	FLOAT_LITERAL,
	STRING_LITERAL,
	COMMENT, -- only used for code editor syntax highlighting
	UNKNOWN, -- only used for code editor syntax highlighting
	VOID,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT_ID, -- struct type id
	STRING,
	STRUCT,
	FUNCTION,
	ENUM,
	ID,
	ELSE,
	IF,
	RETURN,
	BREAK,
	CONTINUE,
	SIZEOF,
	FOR,
	WHILE,
	VARARGS,
	LNOT,
	NOT,
	ASSIGN,
	COND,
	LOR,
	LAND,
	OR,
	XOR,
	AND,
	EQ,
	NE,
	LT,
	GT,
	LE,
	GE,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	ADD,
	SUB,
	MUL,
	DIV,
	MOD,
	ARROW,
	DOT,
	BRAK
}

-- opcodes used by the vm and emitted by the compiler
global Opcode = @enum {
	GET_G = 0,
	GET_GX,
	SET_G,
	SET_GX,
	NEW_L,
	DEL_L,
	GET_L,
	GET_LX,
	SET_L,
	SET_LX,
	GET_A,
	GET_AX,
	SET_A,
	SET_AX,
	GET_M,
	GET_MX,
	SET_M,
	SET_MX,
	GET_S,
	SET_S,
	ADDROF_G,
	ADDROF_L,
	ADDROF_A,
	PUSH_ZERO,
	PUSH_ZEROF,
	PUSH_ONE,
	PUSH_ONEF,
	PUSH_CHAR,
	PUSH_INT,
	PUSH_FLOAT,
	PUSH_VEC2_ZERO,
	PUSH_VEC3_ZERO,
	PUSH_STRING,
	DISCARD,
	NOT,
	OR,
	XOR,
	AND,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	NEG,
	NEGF,
	NEGV,
	ADD,
	ADDF,
	ADDV,
	ADDP,
	SUB,
	SUBF,
	SUBV,
	SUBP,
	MUL,
	MULF,
	MULV,
	DIV,
	DIVU,
	DIVF,
	DIVV,
	MOD,
	MODU,
	MODF,
	LNOT,
	LNOTP,
	EQ,
	EQF,
	EQV,
	EQS,
	NE,
	NEF,
	NEV,
	NES,
	LTI,
	LTU,
	LTF,
	LTV,
	GTI,
	GTU,
	GTF,
	GTV,
	LEI,
	LEU,
	LEF,
	LEV,
	GEI,
	GEU,
	GEF,
	GEV,
	JUMP,
	JUMP_Z,
	JUMP_ZD,
	JUMP_NZD,
	JUMP_NULL,
	JUMP_NULLD,
	JUMP_NNULLD,
	CALL,
	CALL_PTR,
	RETURN,
	VARGP,
	FTOI,
	ITOF,
	ITOB, -- int to bool, used by || and && operators
	PTOB, -- pointer to bool, used by || and && operators
	API
}

global Class = @enum {
	KEYWORD = 0,
	API,
	CONSTANT,
	STRUCT,
	FUNCTION,
	MEMORY, -- only used when writing values into memory using pointers
	STRING, -- only used when writing characters to a string using indexing
	GLOBAL,
	ARG,
	LOCAL
}

global EVMType = @enum {
	VOID = 0,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT,
	STRING,
	FUNC_POINTER,
	POINTER = 16 -- repeatedly added to type id value to indicate pointer levels
}

-- vm multiplication opcode has several modes for multiplying different types
global MulVMode = @enum {
	INT_V2 = 0,
	INT_V3,
	FLOAT_V2,
	FLOAT_V3,
	V2_INT,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm division opcode has several modes for dividing different types
global DivVMode = @enum {
	V2_INT = 0,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm script hook function ids
global Hook = @enum {
	INIT = 0,
	UPDATE,
	DRAW,
	COUNT
}

global RenderTexture = @enum {
    CODE = 0,
    TRACKER,
    MODEL,
    TEXTURE,
	COUNT
}

global LightAttribute = @enum {
	ENABLED = 0,
	TYPE,
	RADIUS,
	POSITION,
	DIRECTION,
	COLOR,
	COUNT -- not an actual attribute, used to count the number of attributes
}

global SoundchipBank = @enum {
	SYSTEM = 0,
	WAVBANK0 = 1,
	WAVBANK1,
	SEQBANK0 = 1,
	SEQBANK1,
	SEQBANK2,
	SEQBANK3,
	SEQBANK4,
	SEQBANK5,
	SEQBANK6,
	SEQBANK7
}

-- instrument flags byte:
-- W 0 0 0 0 0 LM
-- W = use sample start value as wavmap index
-- LM = loop mode (2 bits)
global InstrumentFlag = @enum {
	LOOP_OFF = 0,
	LOOP_FORWARD,
	LOOP_PINGPONG,
	LOOP_RANGE,
	LOOP_MASK = 0b00000011,
	MANUAL    = 0b10000000
}

-- playflags byte:
-- M L 0 0 0 0 PM
-- M = mute
-- L = loop
-- PM = play mode (2 bits)
global PlayFlag = @enum {
	PLAY_SONG = 0,
	PLAY_PATTERN,
	PLAY_SAMPLE,
	PLAY_MASK = 0b00000011,
	MUTE      = 0b10000000,
	LOOP      = 0b01000000
}

global StateID = @enum {
	STATE_SAME = 0xFF,
	STATE_LEFT = 0xFE,
	STATE_RIGHT = 0xFD,
    BOOT = 0,
    CODE,
    TRACKER,
    MODEL,
    TEXTURE,
    RUN,
    COUNT
}

global DialogID = @enum {
    NONE = 0,
	IMPORT_CODE,
	IMPORT_TEXTURE,
	IMPORT_MODEL,
	IMPORT_SAMPLE,
	LOAD_CART,
	SAVE_CART,
    COUNT
}

global DialogStep = @enum {
    FILE_BROWSER = 0,
	TEXTURE_POSITION,
	TEXTURE_CROP,
	MODEL_CONFIG,
	SAMPLE_CONFIG,
	SAMPLE_CROP
}

global FileBrowserMode = @enum {
    LOAD = 0,
	SAVE
}

global FileBrowserInputMode = @enum {
    SET_FILENAME = 0,
	SELECT_FILE_OR_DIR
}

global FileBrowserResult = @enum {
    CONTINUE = 0,
	CANCEL,
	SELECTED_FILE,
	SELECTED_DIRECTORY
}

global MenuAnimation = @enum {
    NONE = 0,
	STATE_SWITCH,
	DIALOG_OPENCLOSE,
	LOG_OPENCLOSE
}

global PopupState = @enum {
    HIDDEN = 0,
	ANIMATING,
	SHOWN
}

global LogState = @enum {
    NONE = 0,
	HIDDEN,
	SHOWN
}

global LogEntryType = @enum {
	INFO = 0,
	HOST_ERROR,
	COMPILE_ERROR,
	RUNTIME_ERROR
}

-- --------------------------------
-- RECORDS
-- --------------------------------

global EVM <forwarddecl> = @record {}

global Identifier <forwarddecl> = @record {}

global APIFunction: type = @function(vm: *EVM): boolean

-- union used to store values of different types
global IntFloat = @union {
	i: int32,
	u: uint32,
	f: float32
}

-- record used to represet an ERA-C string struct
global EVMString = @record {
    len: uint32, -- string length
    data: uint32 -- string data virtual address
}

-- record used to represet an ERA-C colaabb struct
global ColAABB = @record {
    type: uint32,
    position: rl.vector3,
    width: float32,
    height: float32,
    depth: float32
}

-- record that tracks data used by the vm when calling functions
global CallFrame = @record {
    pc: uinteger,
    lbp: uinteger,
    argc: uint16,
    vargc: uint16, -- remaining vararg word count for function
    vargp: uint16, -- vararg pointer
    vargf: boolean, -- vararg flag, true if the function for this frame is a varargs function
}

-- ERA-C struct metadata record used in the compiler
global Struct = @record {
    is_complete: boolean,
    size: uinteger,
    name: string,
    member_map: hashmap(string, uinteger),
    members: sequence(*Identifier)
}

global TypeInfo = @record {
    type_id: uinteger,
    structref: *Struct -- only used when base_type is EVMType.STRUCT
}

global LoopInfo = @record {
    loop_start: uinteger,
    loop_step: uinteger,
    loop_end: uinteger,
    break_count: uinteger,
    step_count: uinteger,
    del_l_count: uinteger,
    has_step: boolean
}

Identifier = @record {
    name: string,
    token: uinteger,
    class: uinteger,
    index: uinteger,
    varargs_index: uinteger, -- only used for varargs functions
    type_info: TypeInfo,
    is_array: boolean,
    is_varargs: boolean, -- only used for functions
    const_val: uint32, -- only used for constants
    const_valf: float32, -- only used for constants
    func: APIFunction, -- only used when registering api functions
    argdata: sequence(TypeInfo) -- only used to track function arguments
}

global Cart = @record {
    texbank: [MEMORY_TEXBANK_SIZE_ELEMENTS]rl.color,
    objbank: [MEMORY_OBJBANK_SIZE_ELEMENTS]IntFloat,
    ompbank: [MEMORY_OMPBANK_SIZE_ELEMENTS]uint8,
    wmpbank: [MEMORY_WMPBANK_SIZE_ELEMENTS]uint8,
    wavbank: [MEMORY_WAVBANK_SIZE_ELEMENTS]BKFrame,
    seqbank: [MEMORY_SEQBANK_SIZE_ELEMENTS]uint8,
    rom: [MEMORY_ROM_SIZE_ELEMENTS]uint8,
}

global Light = @record {
	enabled: cint,
	light_type: cint,
	radius: float32,
	position: rl.vector3,
	direction: rl.vector3,
	color: rl.vector3
}

-- holds graphics information for the vm
global GPU = @record {
	texmem: [MEMORY_TEXMEM_SIZE_ELEMENTS]rl.color,
	objmem: [MEMORY_OBJMEM_SIZE_ELEMENTS]IntFloat,
	cameras2D: [GPU_CAMERAS_COUNT]rl.camera2D,
	system_cam2d: rl.camera2D,
	cameras: [GPU_CAMERAS_COUNT]rl.camera,
	system_cam: rl.camera,
	lights: [GPU_LIGHTS_COUNT]Light,
	gfx_master_rendertexture: rl.renderTexture,
	gfx_rendertextures: [RenderTexture.COUNT]rl.renderTexture,
	gfx_texture: rl.texture,
	gfx_shader: rl.shader,
	gfx_font_texture: rl.texture,
	gfx_rendertexture_index: uinteger,
	texbank_ptr: *[0]rl.color,
	objbank_ptr: *[0]IntFloat,
	ompbank_ptr: *[0]uint8,
	sysmem_ptr: *[0]uint8,
	
	-- shader uniform locations
	mat_model_loc: cint,
	mat_normal_loc: cint,
	tex_mode_loc: cint,
	tex_x_loc: cint,
	tex_y_loc: cint,
	tex_w_loc: cint,
	tex_h_loc: cint,
	fog_mode_loc: cint,
	fog_start_loc: cint,
	fog_end_loc: cint,
	fog_color_loc: cint,
	lighting_mode_loc: cint,
	ambient_factor_loc: cint,
	ambient_color_loc: cint,

	update_tex: boolean, -- set when TEXMEM is updated. when set, TEXMEM is uploaded to the real GPU

	-- "triangle mode" data
	--
	-- RLGL currently doesn't allow primitives created using RL_TRIANGLES to use UV coordinates for textures.
	-- to mimic textured triangles, we use use RL_QUADS and send a copy of the first vertex as the last quad vertex
	triangle_mode: boolean,
	triangle_vert_index: integer,

	proj_matrix_count: uinteger, -- used to track matrix stack
	view_matrix_count: uinteger, -- used to track matrix stack
	matrix_mode: uinteger,
	
	-- graphics state
	cull_mode: uinteger,
	wire_mode: boolean,
	tex_mode: cint,
	tex_x: cint,
	tex_y: cint,
	tex_w: cint,
	tex_h: cint,
	fog_mode: cint,
	fog_start: float32,
	fog_end: float32,
	fog_color: rl.vector4,
	lighting_mode: cint,
	ambient_factor: float32,
	ambient_color: rl.vector3,
	blend_mode: cint,
	viewport_w: cint,
	viewport_h: cint
}

global SoundChip <forwarddecl> = @record {}

global AudioState = @record {
    playing_flags: uint8
}

global TrackContext = @record {
    bk_track: BKTrack,
    bk_clock: BKClock,
    bk_divider: BKDivider,
    bk_instrument: BKInstrument,
    soundchip: *SoundChip,
    track_index: uint8
}

-- track state object, stored in sysmem
global TrackState = @record {
    playflags: uint8,
    bpm: uint8,
    volume: uint8,
    pan: uint8,
    song_id: uint8,
    song_pos: uint8,
    pattern_id: uint8,
    pattern_pos: uint8,
    groove_id: uint8,
    groove_pos: uint8
}

SoundChip = @record {
    seqmem: [MEMORY_SEQMEM_SIZE_ELEMENTS]uint8, -- song, chain, phrase, instrument, and state data
    wavmem: [MEMORY_WAVMEM_SIZE_ELEMENTS]BKFrame, -- sample wave data
    aobmem: [MEMORY_AOBMEM_SIZE_ELEMENTS]BKFrame, -- working audio buffer
    track_contexts: [SOUNDCHIP_TRACK_COUNT]TrackContext,
    preview_bk_track: BKTrack,
    preview_bk_instrument: BKInstrument,
    bk_context: BKContext,
    bk_data: BKData,
    audio_stream: rl.audioStream,
    current_wavbank: uint8, -- which region of memory to use for sample data
    current_seqbank: uint8, -- which region of memory to use for sequencer data
    bk_data_flags: BKEnum, -- flags describing sample data format

    -- memory pointers
    sysmem_ptr: *[0]uint8,
    wmpbank_ptr: *[0]uint8,
    wavbank_ptr: *[0]BKFrame,
    seqbank_ptr: *[0]uint8,
    song_data: *[0]uint8,
    pattern_data: *[0]uint8,
    instrument_data: *[0]uint8,
    groove_data: *[0]uint8,
    audio_state: *AudioState,
    track_state: *[0]uint8
}

EVM = @record {
    -- vm vars
    heap: [MEMORY_HEAP_SIZE_ELEMENTS]uint8,
    globals: [MEMORY_GLOBALS_SIZE_ELEMENTS]IntFloat,
    locals: [MEMORY_LOCALS_SIZE_ELEMENTS]IntFloat,
    args: [MEMORY_ARGS_SIZE_ELEMENTS]IntFloat,
    opstack: [EVM_OPSTACK_SIZE]IntFloat,
    bytecode: [EVM_BYTECODE_SIZE]uint8,
    callstack: [EVM_CALLSTACK_SIZE]CallFrame,
    api_funcs: [EVM_API_FUNCS_SIZE]APIFunction,
    sysmem: [MEMORY_SYSMEM_SIZE_ELEMENTS]uint8,
    cf: CallFrame,
    rom_len: uinteger,
    bytecode_len: uinteger,
    globals_len: uinteger,
    lsp: uinteger,
    asp: uinteger,
    ap: uinteger, -- ap for current function
    osp: uinteger,
    csp: uinteger,
    hook_addresses: [3]uint16,
    hook_flags: [3]boolean,
    current_hook: uinteger,
    objmap_ptr: *[0]uint8,
    wavmap_ptr: *[0]uint8,
    
    -- compiler vars
    src_index: uinteger, -- line character index
    prev_src_index: uinteger,
    prev_line: uinteger,
	current_src_line: sequence(uint8),
    token: uinteger,
    token_val: uinteger,
    token_valf: float32,
    string_len: uinteger,
    prev_token: uinteger,
    prev_scope_size: uint16,
    line: uinteger,
    expr_type: TypeInfo,
    local_index: uinteger,
    mlcomment_level: uinteger,
    prev_opcode: uint8,
    has_id: boolean,
    skip_next_id_lookup: boolean,
    compile_err: boolean,
    current_id: *Identifier,
    current_id_name: string,
    current_func_id: *Identifier,
    struct_vec2: *Struct,
    struct_vec3: *Struct,
    struct_string: *Struct,
    sb: stringbuilder,
    keywords: hashmap(string, *Identifier),
    constants: hashmap(string, *Identifier),
    api_ids: hashmap(string, *Identifier),
    builtin_struct_ids: hashmap(string, *Identifier),
    struct_ids: hashmap(string, *Identifier),
    sym_tables: sequence(*hashmap(string, *Identifier)),
    scope_sizes: sequence(uinteger),
    loop_info_stack: sequence(LoopInfo),
    loop_break_stack: sequence(uint16),
    loop_step_stack: sequence(uint16),
    loop_del_l_stack: sequence(uint16),
    
    -- general vars
    cart: Cart,
    temp_cart: Cart, -- used for temp storage while saving cart data
    soundchip: SoundChip,
    gpu: GPU,
    error: string,
    init_time: float64
}

global State <forwarddecl> = @record {}
global StateMachine <forwarddecl> = @record {}

global StateFunction: type = @function(*StateMachine, *EVM): void

State = @record {
	init: StateFunction,
	enter: StateFunction,
	exit: StateFunction,
	update: StateFunction,
	draw: StateFunction,
	cleanup: StateFunction
}

global Dialog = @record {
	update: StateFunction,
	draw: StateFunction
}

StateMachine = @record {
	states: [StateID.COUNT]State,
	dialogs: [DialogID.COUNT]Dialog,
	state_ptr: *State,
	dialog_ptr: *Dialog,
	vm_ptr: *EVM,
	state_id: integer,
	dialog_id: integer,
	queued_state: integer,
	queued_dialog: integer,
	prev_state: integer
}

-- global data record
global CoreData = @record {
	--gpu: GPU,
	--soundchip: Soundchip,
	--vm: EVM,
	--compiler: Compiler,
	--sm: Statemachine,

	-- menu animation data
	animation_type: uint32,
	anim_time: float32,
	anim_beginning: float32,
	anim_target: float32,
	-- 3D menu swapping animation
	facing_angle: float32,
	-- dialog open/close animation
	dialog_size: float32,

	log_text: [16 * 81]cchar, -- log text buffer, 64x 80-character strings
	log_types: [64]uint8, -- log line types, 1 LogEntryType per line

	text_buffer: *[0]uint8,
	src_lines: sequence(sequence(uint8)),
	recycled_lines: sequence(sequence(uint8)),
	current_line: sequence(uint8),
    line_index: int32,
    char_index: int32,
	start_line: int32, -- line index to start drawing from
	start_char: int32, -- char index to start drawing from

	user_directory: string,
	data_directory: string,
	carts_directory: string,
	current_cart_path: string,
	current_cart_name: string,
	current_browser_path: string,
	popup_text: string,
	popup_state: integer,
	popup_timer: float32,
	popup_beginning_factor: float32,
	popup_target_factor: float32,
	popup_current_factor: float32,
	popup_offset: int32,
	popup_color: uint32,
	file_name: [65]uint8, -- used to name a file when saving
	byte_buffer: [8]uint8,
	dialog_val0: int32, -- general purpose integer used by dialogs
	dialog_val1: int32, -- general purpose integer used by dialogs
	dialog_val2: int32, -- general purpose integer used by dialogs
	dialog_val3: int32, -- general purpose integer used by dialogs
	file_paths: rl.filePathList,
	image_to_import: rl.image,
	sample_to_import: rl.wave,
	model_to_import: rl.model,
	model_vertex_count: uint32,
	log_index: integer,
	log_count: integer,
	log_offset: float32,
	log_state: integer,
	dialog_step: uinteger,
	browser_index: integer,
	browser_mode: integer,
	browser_input_mode: integer, -- setting file name vs selecting dir/file
	queued_log_state: integer,
	has_loaded_paths: boolean,
	has_loaded_image: boolean,
	has_loaded_sample: boolean,
	has_loaded_model: boolean,

	cursor_color: uint32
}

--function CoreData:__close(): void
--	-- do cleanup here...
--end

-- display popup message
function CoreData:popup(message_type: uint8, text: string): void
	self.popup_text = text
	self.popup_state = PopupState.ANIMATING
	self.popup_timer = 0.0
	self.popup_target_factor = 1.0
	self.popup_beginning_factor = 0.0
	self.popup_current_factor = 0.0
	self.popup_offset = 0

	switch message_type do
		case LogEntryType.INFO then
			self.popup_color = GPU_GREEN
		case LogEntryType.HOST_ERROR then
			self.popup_color = GPU_YELLOW
		case LogEntryType.COMPILE_ERROR then
			self.popup_color = GPU_ORANGE
		case LogEntryType.RUNTIME_ERROR then
			self.popup_color = GPU_RED
	end
end

function CoreData:clearLog(): void
	self.log_index = 0
	self.log_count = 0
end

-- add string to log
function CoreData:log(entry_type: uint8, text: string, make_popup: boolean): void
	local line_ptr: *[0]cchar = (@*[0]cchar)(&self.log_text[self.log_index * 81])
	local char_index: uint8 = 0

	for i = 1, <= #text do
		local c: cchar = text[i]

		if c ~= '\n'_u8 then
			line_ptr[char_index] = c
			char_index = char_index + 1
		end

		if (char_index == 80) or (c == '\n'_u8) or (i == #text) then
			line_ptr[char_index] = '\0'_u8 -- terminate line
			self.log_types[self.log_index] = entry_type -- set line type
			self.log_index = self.log_index + 1
			
			-- increment log index and wrap if needed
			if self.log_index == 16 then
				self.log_index = 0
			end

			-- increment log size if needed
			if self.log_count < 16 then
				self.log_count = self.log_count + 1
			end

			line_ptr = (@*[0]cchar)(&self.log_text[self.log_index * 81]) -- update line pointer
			char_index = 0 -- set cursor to start of line
		end
	end

	if make_popup then
		self:popup(entry_type, text)
	end
end

function CoreData:changeCharacterIndex(new_index: int32): void
	self.char_index = math.clamp(new_index, 1, #self.current_line)

	if self.char_index < self.start_char + 1 then
		self.start_char = math.max(self.char_index - 1, 1)
	elseif self.char_index > self.start_char + 78 then
		self.start_char = math.clamp(self.char_index - 78, 1, math.max(1, #self.current_line - 79))
	end
end

function CoreData:changeCodeLine(index: int32): void
    self.line_index = math.clamp(index, 1, #self.src_lines)
    self.current_line = self.src_lines[self.line_index]
    self:changeCharacterIndex(self.char_index)

	if self.line_index < self.start_line + 1 then
		self.start_line = math.max(self.line_index - 1, 1)
	elseif self.line_index > self.start_line + 36 then
		self.start_line = math.clamp(self.line_index - 36, 1, math.max(1, #self.src_lines - 37))
	end
end

function CoreData:getNewLine(): sequence(uint8)
    if #self.recycled_lines > 0 then
        return self.recycled_lines:pop()
    else
        return {'\0'_u8}
    end
end

function CoreData:appendLine(): void
    self.src_lines:push(self:getNewLine())
end

function CoreData:insertLine(index: usize): void
    self.src_lines:insert(index, self:getNewLine())
end

function CoreData:deleteLine(index: usize): void
    local line: sequence(uint8) = self.src_lines:remove(index)
    line:clear()
    line:push('\0'_u8)
    self.recycled_lines:push(line)
end

function CoreData:insertChar(c: uint8): void
    self.current_line:insert(self.char_index, c)
    self:changeCharacterIndex(self.char_index + 1)
end

function CoreData:deleteChar(forward: boolean): void
    if forward then
        if self.char_index < #self.current_line then
            self.current_line:remove(self.char_index)
        elseif self.char_index == #self.current_line and self.line_index < #self.src_lines then
            -- append next line to end of current
            local next_line: sequence(uint8) = self.src_lines[self.line_index + 1]
    
            self.current_line:pop() -- remove terminator
            for i = 1, <= #next_line do
                self.current_line:push(next_line[i])
            end
    
            self:deleteLine(self.line_index + 1)
        end
    else
        if self.char_index > 1 then
            self:changeCharacterIndex(self.char_index - 1)
            self.current_line:remove(self.char_index)
        elseif self.char_index == 1 and self.line_index > 1 then
            -- append current line to end of previous
            local prev_line: sequence(uint8) = self.src_lines[self.line_index - 1]
            local new_index: int32 = (@int32)(#prev_line)
    
            prev_line:pop() -- remove terminator
            for i = 1, < #self.current_line do
                prev_line:push(self.current_line[i])
            end
            prev_line:push('\0'_u8)
    
            self:deleteLine(self.line_index)
            self:changeCodeLine(self.line_index - 1)
            self:changeCharacterIndex(new_index)
        end
    end
end

function CoreData:clearSrc(): void
	for i = #self.src_lines, >= 1, -1 do
		self:deleteLine(i)
	end
	self.line_index = 1
	self.char_index = 1
	self.start_line = 1
	self.start_char = 1
end

global core: CoreData --<close>
