require("statemachine")

-- TODO: add basic ui to load audio samples

local PIANO_KEYS_COUNT <comptime> = SOUNDCHIP_OCTAVE_SIZE * 2
local HEX_KEYS_COUNT <comptime> = 16

local Editor = @enum {
    SONG = 0,
    PATTERN,
    COUNT
}

local TrackerData = @record {
    clipboard: [SOUNDCHIP_SONG_SIZE]uint8,
    clipboard_len: uinteger,
    clipboard_type: uinteger, -- type of data currently in clipboard
    selection_start: uinteger,
    selection_len: uinteger,
    current_editor: integer,
    octave: uint8,
    song_id: uint8,
    song_x: integer,
    song_y: integer,
    track: integer,
    pattern_x: integer,
    pattern_y: integer,
    prev_volume: uint8,
    prev_instrument: uint8,
    byte_val: uint8
}

local note_names: [SOUNDCHIP_OCTAVE_SIZE]string = {
    "C-",
    "C#",
    "D-",
    "D#",
    "E-",
    "F-",
    "F#",
    "G-",
    "G#",
    "A-",
    "A#",
    "B-"
}

local piano_keys: [PIANO_KEYS_COUNT]cint = {
    -- base octave
    rl.keyboardKey.Z, -- C
    rl.keyboardKey.S, -- C#
    rl.keyboardKey.X, -- D
    rl.keyboardKey.D, -- D#
    rl.keyboardKey.C, -- E
    rl.keyboardKey.V, -- F
    rl.keyboardKey.G, -- F#
    rl.keyboardKey.B, -- G
    rl.keyboardKey.H, -- G#
    rl.keyboardKey.N, -- A
    rl.keyboardKey.J, -- A#
    rl.keyboardKey.M, -- B

    -- octave + 1
    rl.keyboardKey.Q,     -- C
    rl.keyboardKey.TWO,   -- C#
    rl.keyboardKey.W,     -- D
    rl.keyboardKey.THREE, -- D#
    rl.keyboardKey.E,     -- E
    rl.keyboardKey.R,     -- F
    rl.keyboardKey.FIVE,  -- F#
    rl.keyboardKey.T,     -- G
    rl.keyboardKey.SIX,   -- G#
    rl.keyboardKey.Y,     -- A
    rl.keyboardKey.SEVEN, -- A#
    rl.keyboardKey.U      -- B
}

local hex_keys: [HEX_KEYS_COUNT]cint = {
    rl.keyboardKey.ZERO,
    rl.keyboardKey.ONE,
    rl.keyboardKey.TWO,
    rl.keyboardKey.THREE,
    rl.keyboardKey.FOUR,
    rl.keyboardKey.FIVE,
    rl.keyboardKey.SIX,
    rl.keyboardKey.SEVEN,
    rl.keyboardKey.EIGHT,
    rl.keyboardKey.NINE,
    rl.keyboardKey.A,
    rl.keyboardKey.B,
    rl.keyboardKey.C,
    rl.keyboardKey.D,
    rl.keyboardKey.E,
    rl.keyboardKey.F
}

local data: TrackerData

local function drawLevels(sm: *StateMachine, vm: *EVM): void
    local l: BKFrame = 0
    local r: BKFrame = 0

    for i = 0, < SOUNDCHIP_FRAMES_PER_UPDATE do
        local idx: uinteger = i * 2
        local ltemp: BKFrame = math.abs(vm.soundchip.aobmem[idx])
        local rtemp: BKFrame = math.abs(vm.soundchip.aobmem[idx + 1])

        if ltemp > l then l = ltemp end
        if rtemp > r then r = rtemp end
    end

    --print("left", l, "right", r)
end

local function drawSong(sm: *StateMachine, vm: *EVM): void
    vm.gpu:print2D(18, 9, GPU_WHITE, "SEQBANK")
    vm.gpu:printHexNibble2D(66, 9, GPU_WHITE, vm.soundchip.current_seqbank - SoundchipBank.SEQBANK0)

    local start_row: int32 = util.midI(0, data.song_y - 3, 248)

    for x = 0, < SOUNDCHIP_TRACK_COUNT do
        for y = 0, < 8 do
            local startx: int32 = 18 + x * 12
            local starty: int32 = 18 + y * 9
            local row: int32
            local byte_val: uint8 = vm.soundchip.song_data[8 * (start_row + y) + x]

            vm.gpu:printHexByte2D(6, starty, GPU_RED, start_row + y)

            if (data.song_x /// 2) == x and data.song_y == (start_row + y) then
                vm.gpu:drawRect2D(startx + ((data.song_x & 1) * 6), starty, 6, 9, (data.current_editor == Editor.SONG) and GPU_RED or GPU_GRAY)
            end

            if byte_val == SOUNDCHIP_EMPTY_VALUE then
                vm.gpu:print2D(startx, starty, GPU_WHITE, "..")
            else
                vm.gpu:printHexByte2D(startx, starty, GPU_WHITE, byte_val)
            end
        end
    end
end

local function getNoteText(note: uint8): string
    if note == SOUNDCHIP_EMPTY_VALUE then
        return "..."
    elseif note == SOUNDCHIP_NOTE_MUTE then
        return "OFF"
    elseif note == SOUNDCHIP_NOTE_RELEASE then
        return "REL"
    else
        local base_note: uint8 = note %%% SOUNDCHIP_OCTAVE_SIZE
        local octave: uint8 = note /// SOUNDCHIP_OCTAVE_SIZE
        return string.format("%s%1X", note_names[base_note], octave)
    end
end

local function drawPatterns(sm: *StateMachine, vm: *EVM): void
    local start_track: int32 = util.midI(0, data.track - 1, 4)
    local start_pattern_y: int32 = 108

    for i = 0, < 4 do
        local start_pattern_x: int32 = 6 + (i * 13 * 6)

        if data.track == start_track + i then
            local selcol: uint32 = (data.current_editor == Editor.PATTERN) and GPU_RED or GPU_GRAY
            vm.gpu:drawRect2D(start_pattern_x - 2, start_pattern_y - 10, 75, 1, selcol)
            vm.gpu:drawRect2D(start_pattern_x - 2, start_pattern_y - 9, 1, 153, selcol)
            vm.gpu:drawRect2D(start_pattern_x + 72, start_pattern_y - 9, 1, 153, selcol)
            vm.gpu:drawRect2D(start_pattern_x - 2, start_pattern_y + 144, 75, 1, selcol)
        end
        vm.gpu:print2D(start_pattern_x + 12, start_pattern_y - 9, GPU_WHITE, "TRACK")
        vm.gpu:printHexNibble2D(start_pattern_x + 48, start_pattern_y - 9, GPU_WHITE, start_track + i)

        local start_row: int32 = util.midI(0, data.pattern_y - 7, 64-16)
        for j = 0, < 16 do
            local y: int32 = start_pattern_y + j * 9

            if (data.track == start_track + i) and (data.pattern_y == start_row + j) then
                -- draw cursor
                local cx: int32
                local cw: int32 = 6

                if data.pattern_x == 0 then
                    cx = 0
                    cw = 18
                else
                    cx = 18 + ((data.pattern_x - 1) * 6)
                end

                vm.gpu:drawRect2D(start_pattern_x + 12 + cx, y, cw, 9, (data.current_editor == Editor.PATTERN) and GPU_RED or GPU_GRAY)
            end

            local row: *[0]uint8 = vm.soundchip:getPatternRow(vm.soundchip.song_data[8 * data.song_y + (start_track + i)], start_row + j)
            local note: uint8 = row[0]
            local vol: uint8 = row[1]
            local instr: uint8 = row[2]
            local fx: uint8 = row[3]
            local arg: uint8 = row[4]

            vm.gpu:printHexByte2D(start_pattern_x, y, GPU_RED, start_row + j)
            vm.gpu:print2D(start_pattern_x + 12, y, GPU_WHITE, getNoteText(note))
            if vol == SOUNDCHIP_EMPTY_VALUE then
                vm.gpu:print2D(start_pattern_x + 30, y, GPU_GREEN, "..")
            else
                vm.gpu:printHexByte2D(start_pattern_x + 30, y, GPU_GREEN, vol)
            end
            if instr == SOUNDCHIP_EMPTY_VALUE then
                vm.gpu:print2D(start_pattern_x + 42, y, GPU_BLUE, "..")
            else
                vm.gpu:printHexByte2D(start_pattern_x + 42, y, GPU_BLUE, instr)
            end
            vm.gpu:print2D(start_pattern_x + 54, y, GPU_RED, ".")
            if fx == SOUNDCHIP_EMPTY_VALUE then
                vm.gpu:print2D(start_pattern_x + 60, y, GPU_WHITE, "..")
            else
                vm.gpu:printHexByte2D(start_pattern_x + 60, y, GPU_WHITE, arg)
            end
        end
    end
end

local function doNoteInput(vm: *EVM): boolean
    local row: *[0]uint8 = vm.soundchip:getPatternRow(vm.soundchip.song_data[8 * data.song_y + data.track], data.pattern_y)

    if rl.isKeyPressed(rl.keyboardKey.BACKSPACE) then
        row[0] = SOUNDCHIP_EMPTY_VALUE
        row[1] = SOUNDCHIP_EMPTY_VALUE
        row[2] = SOUNDCHIP_EMPTY_VALUE
        return true
    elseif rl.isKeyPressed(rl.keyboardKey.COMMA) then
        row[0] = SOUNDCHIP_NOTE_RELEASE
        row[1] = SOUNDCHIP_EMPTY_VALUE
        row[2] = SOUNDCHIP_EMPTY_VALUE
        return true
    elseif rl.isKeyPressed(rl.keyboardKey.PERIOD) then
        row[0] = SOUNDCHIP_NOTE_MUTE
        row[1] = SOUNDCHIP_EMPTY_VALUE
        row[2] = SOUNDCHIP_EMPTY_VALUE
        return true
    else
        for i = 0, < PIANO_KEYS_COUNT do
            if rl.isKeyPressed(piano_keys[i]) then
                if vm.soundchip.audio_state.playing_flags == 0 then
                    local note: uint8 = (@uint8)(i + data.octave * SOUNDCHIP_OCTAVE_SIZE)
                    row[0] = note
                    row[1] = data.prev_volume
                    row[2] = data.prev_instrument
                    vm.soundchip:playPreviewNote(note)
                    return true
                end
            elseif rl.isKeyReleased(piano_keys[i]) then
                vm.soundchip:stopPreviewNote()
                return false
            end
        end
    end

    return false
end

local function doHexInput(vm: *EVM, byte_ptr: *[0]uint8, nibble_index: uinteger): boolean
    local pressed: boolean = false
    local nibble: uint8

    if rl.isKeyPressed(rl.keyboardKey.BACKSPACE) then
        byte_ptr[0] = SOUNDCHIP_EMPTY_VALUE
        return true
    end

    for i: uint8 = 0, < HEX_KEYS_COUNT do
        if rl.isKeyPressed(hex_keys[i]) then
            pressed = true
            nibble = i
        end
    end

    if pressed then
        local byte_val: uint8 = byte_ptr[0]

        if byte_val == SOUNDCHIP_EMPTY_VALUE then
            byte_val = 0
        end

        if nibble_index == 0 then
            byte_val = (byte_val & 0x0F) | (nibble << 4)
        else
            byte_val = (byte_val & 0xF0) | nibble
        end

        data.byte_val = byte_val

        byte_ptr[0] = byte_val
    end

    return pressed
end

global function stateTrackerInit(sm: *StateMachine, vm: *EVM): void
    data.clipboard_len = 0
    data.clipboard_type = 0
    data.selection_start = 0
    data.selection_len = 0
    data.current_editor = Editor.SONG
    data.octave = 4
    data.song_id = 0
    data.song_x = 0
    data.song_y = 0
    data.track = 0
    data.pattern_x = 0
    data.pattern_y = 0
    data.prev_volume = 0xA0
    data.prev_instrument = 0
end

global function stateTrackerEnter(sm: *StateMachine, vm: *EVM): void
    vm.gpu:setRenderTexture(RenderTexture.TRACKER)
end

global function stateTrackerExit(sm: *StateMachine, vm: *EVM): void
end

global function stateTrackerUpdate(sm: *StateMachine, vm: *EVM): void
    local is_shift_down: boolean = rl.isKeyDown(rl.keyboardKey.LEFT_SHIFT) or rl.isKeyDown(rl.keyboardKey.RIGHT_SHIFT)
    local is_ctrl_down: boolean = rl.isKeyDown(rl.keyboardKey.LEFT_CONTROL) or rl.isKeyDown(rl.keyboardKey.RIGHT_CONTROL)

    if is_ctrl_down and rl.isKeyPressed(rl.keyboardKey.LEFT) then
        sm.queued_state = StateID.MAIN
        return
    end

    if rl.isKeyPressed(rl.keyboardKey.SPACE) then
        if vm.soundchip.audio_state.playing_flags ~= 0 then
            vm.soundchip:stopAllTracks()
        else
            vm.soundchip:playSongRow(data.song_y)
        end
        return
    end

    if vm.soundchip.audio_state.playing_flags ~= 0 then
        local ts: *TrackState = vm.soundchip:getTrackState(data.track)
        data.song_y = ts.song_pos
        data.pattern_y = ts.pattern_pos
        return
    end
    
    if rl.isKeyPressed(rl.keyboardKey.MINUS) then
        data.octave = util.midI(0, data.octave - 1, SOUNDCHIP_MAX_OCTAVE)
    elseif rl.isKeyPressed(rl.keyboardKey.EQUAL) then
        data.octave = util.midI(0, data.octave + 1, SOUNDCHIP_MAX_OCTAVE)
    elseif is_ctrl_down then
        if data.current_editor == Editor.SONG and rl.isKeyPressed(rl.keyboardKey.DOWN) then
            data.current_editor = Editor.PATTERN
            return
        elseif data.current_editor == Editor.PATTERN and rl.isKeyPressed(rl.keyboardKey.UP) then
            data.current_editor = Editor.SONG
            return
        end
    end

    switch data.current_editor do
        case Editor.SONG then
            if rl.isKeyPressed(rl.keyboardKey.TAB) then
                if is_shift_down then
                    data.song_x = util.wrapI(data.song_x - 2, 0, 16)
                    data.track = util.wrapI(data.track - 1, 0, 8)
                else
                    data.song_x = util.wrapI(data.song_x + 2, 0, 16)
                    data.track = util.wrapI(data.track + 1, 0, 8)
                end
            elseif rl.isKeyPressed(rl.keyboardKey.PAGE_UP) then
                data.song_y = util.wrapI(data.song_y - 8, 0, 256)
            elseif rl.isKeyPressed(rl.keyboardKey.PAGE_DOWN) then
                data.song_y = util.wrapI(data.song_y + 8, 0, 256)
            elseif rl.isKeyPressed(rl.keyboardKey.HOME) then
                data.song_y = 0
            elseif rl.isKeyPressed(rl.keyboardKey.END) then
                data.song_y = 255
            elseif rl.isKeyPressed(rl.keyboardKey.UP) then
                data.song_y = util.wrapI(data.song_y - 1, 0, 256)
            elseif rl.isKeyPressed(rl.keyboardKey.DOWN) then
                data.song_y = util.wrapI(data.song_y + 1, 0, 256)
            elseif rl.isKeyPressed(rl.keyboardKey.LEFT) then
                if data.song_x & 1 == 0 then
                    data.track = util.wrapI(data.track - 1, 0, 8)
                end
                data.song_x = util.wrapI(data.song_x - 1, 0, 16)
            elseif rl.isKeyPressed(rl.keyboardKey.RIGHT) then
                if data.song_x & 1 == 1 then
                    data.track = util.wrapI(data.track + 1, 0, 8)
                end
                data.song_x = util.wrapI(data.song_x + 1, 0, 16)
            else
                if doHexInput(
                    vm,
                    &vm.soundchip.song_data[8 * data.song_y + (data.song_x /// 2)],
                    data.song_x & 1
                ) then
                    data.song_y = util.wrapI(data.song_y + 1, 0, 256)
                end
            end
        case Editor.PATTERN then
            if rl.isKeyPressed(rl.keyboardKey.TAB) then
                if is_shift_down then
                    data.song_x = util.wrapI(data.song_x - 2, 0, 16)
                    data.track = util.wrapI(data.track - 1, 0, 8)
                else
                    data.song_x = util.wrapI(data.song_x + 2, 0, 16)
                    data.track = util.wrapI(data.track + 1, 0, 8)
                end
            elseif rl.isKeyPressed(rl.keyboardKey.PAGE_UP) then
                data.pattern_y = data.pattern_y - 16
                if data.pattern_y < 0 then
                    data.song_y = util.wrapI(data.song_y - 1, 0, 256)
                end
                data.pattern_y = util.wrapI(data.pattern_y, 0, 64)
            elseif rl.isKeyPressed(rl.keyboardKey.PAGE_DOWN) then
                data.pattern_y = data.pattern_y + 16
                if data.pattern_y > 63 then
                    data.song_y = util.wrapI(data.song_y + 1, 0, 256)
                end
                data.pattern_y = util.wrapI(data.pattern_y, 0, 64)
            elseif rl.isKeyPressed(rl.keyboardKey.HOME) then
                data.pattern_y = 0
            elseif rl.isKeyPressed(rl.keyboardKey.END) then
                data.pattern_y = 63
            elseif rl.isKeyPressed(rl.keyboardKey.UP) then
                data.pattern_y = data.pattern_y - 1
                if data.pattern_y < 0 then
                    data.pattern_y = 63
                    data.song_y = util.wrapI(data.song_y - 1, 0, 256)
                end
            elseif rl.isKeyPressed(rl.keyboardKey.DOWN) then
                data.pattern_y = data.pattern_y + 1
                if data.pattern_y > 63 then
                    data.pattern_y = 0
                    data.song_y = util.wrapI(data.song_y + 1, 0, 256)
                end
            elseif rl.isKeyPressed(rl.keyboardKey.LEFT) then
                data.pattern_x = data.pattern_x - 1
                if data.pattern_x < 0 then
                    data.pattern_x = 7
                    data.song_x = util.wrapI(data.song_x - 2, 0, 16)
                    data.track = util.wrapI(data.track - 1, 0, 8)
                end
            elseif rl.isKeyPressed(rl.keyboardKey.RIGHT) then
                data.pattern_x = data.pattern_x + 1
                if data.pattern_x > 7 then
                    data.pattern_x = 0
                    data.song_x = util.wrapI(data.song_x + 2, 0, 16)
                    data.track = util.wrapI(data.track + 1, 0, 8)
                end
            else
                switch data.pattern_x do
                    case 0 then -- note
                        if doNoteInput(vm) then
                            data.pattern_y = util.wrapI(data.pattern_y + 1, 0, 64)
                        end
                    case 1,2,3,4,6,7 then -- vol, inst, arg
                        local nibble_index: uinteger
                        local byte_index: uinteger
                        local row: *[0]uint8 = vm.soundchip:getPatternRow(vm.soundchip.song_data[8 * data.song_y + data.track], data.pattern_y)

                        if data.pattern_x < 6 then
                            nibble_index = (data.pattern_x - 1) & 1
                            byte_index = (data.pattern_x < 3) and 1 or 2
                        else
                            nibble_index = data.pattern_x & 1
                            byte_index = 4
                        end

                        if doHexInput(
                            vm,
                            &row[byte_index],
                            nibble_index
                        ) then
                            if byte_index == 1 then
                                data.prev_volume = data.byte_val
                            elseif byte_index == 2 then
                                data.prev_instrument = data.byte_val
                            end
                            data.pattern_y = util.wrapI(data.pattern_y + 1, 0, 64)
                        end
                    case 5 then -- fx
                        do end
                end
            end
    end
end

global function stateTrackerDraw(sm: *StateMachine, vm: *EVM): void
    rl.clearBackground({0, 0, 0, 0})
    vm.gpu:camera2D(-1)

    --drawLevels(sm, vm)
    drawSong(sm, vm)
    drawPatterns(sm, vm)
end
