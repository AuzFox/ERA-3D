require("definitions")

global util = @record {}

function util.getIntFloatBtye(array: *[0]IntFloat, segment_start: uint32, addr: uint32): uint8
	return (@uint8)((array[(addr - segment_start) /// 4].u >> (8 * (3 - (addr & 0b11)))) & 0xFF)
end

function util.setIntFloatByte(array: *[0]IntFloat, segment_start: uint32, addr: uint32, val: uint8): void
	local shift: uinteger = 8 * (3 - (addr & 0b11))
	local v: *IntFloat = &array[(addr - segment_start) /// 4]
	v.u = (v.u & (0xFF000000 >> shift)) | (((@uint32)(val) << 24) >> shift)
end

function util.midI(a: int32, b: int32, c: int32): int32
    if b < a then
		local t: int32 = a
		a = b
		b = t
	end
	if c < b then
		local t: int32 = c
		c = b
		b = t
	end
	if b < a then
		local t: int32 = a
		a = b
		b = t
	end

    return b
end

function util.wrapI(x: int32, min: int32, max: int32): int32
    if min == max then
        return min
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    return min + ((temp + ((x - min) %%% temp)) %%% temp)
end

function util.midF(a: float32, b: float32, c: float32): float32
    if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
	if c < b then
	    local t: float32 = c
	    c = b
	    b = t
	end
	if b < a then
	    local t: float32 = a
	    a = b
	    b = t
	end
    
    return b
end

function util.wrapF(x: float32, min: float32, max: float32): float32
    if min == max then
        return min
    elseif min > max then
        min, max = max, min
    end

    -- TODO: code solution for when range is all negative
    if max < 0 then
        -- ???
    end

    local temp: float32 = max - min
    return min + ((temp + ((x - min) %%% temp)) %%% temp)
end

-- read float value from pointer in big-endian order
function util.peekF(ptr: *[0]uint8): float32
	local intf: IntFloat
	intf = {
		u =
		((@uint32)(ptr[0]) << 24) |
		((@uint32)(ptr[1]) << 16) |
		((@uint32)(ptr[2]) << 8) |
		((@uint32)(ptr[3]))
	}

	return intf.f
end

-- read uint32 valuefromo pointer in big-endian order
function util.peekU(ptr: *[0]uint8): uint32
	local intf: IntFloat
	intf = {
		u =
		((@uint32)(ptr[0]) << 24) |
		((@uint32)(ptr[1]) << 16) |
		((@uint32)(ptr[2]) << 8) |
		((@uint32)(ptr[3]))
	}

	return intf.u
end

-- read int32 value from pointer in big-endian order
function util.peekI(ptr: *[0]uint8): int32
	local intf: IntFloat
	intf = {
		u =
		((@uint32)(ptr[0]) << 24) |
		((@uint32)(ptr[1]) << 16) |
		((@uint32)(ptr[2]) << 8) |
		((@uint32)(ptr[3]))
	}

	return intf.i
end

-- write float value to pointer in big-endian order
function util.pokeF(ptr: *[0]uint8, x: float32): void
	local intf: IntFloat = {f=x}
	ptr[0] = (@uint8)((intf.u & 0xFF000000) >> 24)
	ptr[1] = (@uint8)((intf.u & 0x00FF0000) >> 16)
	ptr[2] = (@uint8)((intf.u & 0x0000FF00) >> 8)
	ptr[3] = (@uint8)(intf.u & 0x000000FF)
end

-- write uint32 value to pointer in big-endian order
function util.pokeU(ptr: *[0]uint8, x: uint32): void
	ptr[0] = (@uint8)((x & 0xFF000000) >> 24)
	ptr[1] = (@uint8)((x & 0x00FF0000) >> 16)
	ptr[2] = (@uint8)((x & 0x0000FF00) >> 8)
	ptr[3] = (@uint8)(x & 0x000000FF)
end

-- write int32 value to pointer in big-endian order
function util.pokeI(ptr: *[0]uint8, x: int32): void
	local intf: IntFloat = {i=x}
	ptr[0] = (@uint8)((intf.u & 0xFF000000) >> 24)
	ptr[1] = (@uint8)((intf.u & 0x00FF0000) >> 16)
	ptr[2] = (@uint8)((intf.u & 0x0000FF00) >> 8)
	ptr[3] = (@uint8)(intf.u & 0x000000FF)
end

-- create a wrapper for mkdir() on linux and _mkdir() on windows
-- taken from fs.nelua from nelua batteries (https://github.com/edubart/nelua-batteries)

## if ccinfo.is_windows then
	local function win_mkdir(path: cstring): cint <cimport'_mkdir',cinclude'<direct.h>'> end
## else
	local S_IRUSR: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IWUSR: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IXUSR: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IRGRP: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IWGRP: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IXGRP: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IROTH: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IWOTH: cuint <cimport,cinclude'<sys/stat.h>',const>
	local S_IXOTH: cuint <cimport,cinclude'<sys/stat.h>',const>
	local function linux_mkdir(path: cstring, mode: cuint): cint <cimport 'mkdir',cinclude'<sys/stat.h>'> end
## end

local function strerror(errnum: cint): cstring <cimport,cinclude'<string.h>'> end
local errno: cint <cimport,cinclude'<errno.h>'>

local function result_from_errno(ok: boolean): (boolean, string, integer)
	if not ok then
	  return false, strerror(errno), errno
	end
	return true, (@string){}, 0
  end

function util.mkdir(path: string): (boolean, string, integer)
	## if ccinfo.is_windows then
		return result_from_errno(win_mkdir(path) == 0)
	## else
		local mode: cuint = S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH
		return result_from_errno(linux_mkdir(path, mode) == 0)
	## end
end
