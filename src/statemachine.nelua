require("rayeasings")

require("definitions")

function StateMachine:initState(): void
    self.state_ptr.init(self, self.vm_ptr)
end

function StateMachine:updateState(): void
    self.state_ptr.update(self, self.vm_ptr)
end

function StateMachine:drawState(): void
    self.state_ptr.draw(self, self.vm_ptr)
end

function StateMachine:back(): void
    self.queued_state = self.prev_state
end

function StateMachine:init(vm: *EVM): void
    self.vm_ptr = vm

    for i = 0, < StateID.COUNT do
        local st: *State = &self.states[i]
        st.init(self, vm)
    end
    
    self.state_id = StateID.MAIN -- start with main state
    self.state_ptr = &self.states[self.state_id]
    self.queued_state = -1
    self.prev_state = self.state_id

    self.state_ptr.enter(self, vm)

    self.animation_type = StateAnimation.NONE
	self.anim_time = 0.0
	self.anim_beginning = 0.0
	self.anim_target = 0.0
    self.facing_angle = 0.0
    self.dialog_size = 0.0

    self.dialog_id = DialogID.NONE
    self.queued_dialog = -1
end

function StateMachine:updateAnimation(): void
    switch self.animation_type do
        case StateAnimation.STATE_SWITCH then
            if self.anim_time < 0.5 then
                self.anim_time = self.anim_time + rl.getFrameTime()
                self.facing_angle = rle.quadOut(self.anim_time, self.anim_beginning, self.anim_target - self.anim_beginning, 0.5)
            else
                self.facing_angle = self.anim_target
                self.animation_type = StateAnimation.NONE
            end
        case StateAnimation.DIALOG_OPENCLOSE then
            if self.anim_time < 0.25 then
                self.anim_time = self.anim_time + rl.getFrameTime()
                self.dialog_size = rle.quadOut(self.anim_time, self.anim_beginning, self.anim_target - self.anim_beginning, 0.25)
            else
                self.dialog_size = self.anim_target
                self.animation_type = StateAnimation.NONE
            end
    end
end

function StateMachine:updateDialog(): void
    self.dialog_ptr.update(self, self.vm_ptr)
end

function StateMachine:drawDialog(): void
    if self.animation_type == StateAnimation.DIALOG_OPENCLOSE then
        rl.clearBackground({0, 0, 0, 0})
        self.vm_ptr.gpu:camera2D(-1)

        local final_size_w: float32 = (@float32)(GPU_VSCREEN_W - 8)
        local final_size_h: float32 = (@float32)(GPU_VSCREEN_H - 34)

        local x: int32 = GPU_VSCREEN_HALF_W - (@int32)((final_size_w * self.dialog_size) / 2)
        local y: int32 = GPU_VSCREEN_HALF_H - (@int32)((final_size_h * self.dialog_size) / 2)
        local w: int32 = (@int32)(final_size_w * self.dialog_size)
        local h: int32 = (@int32)(final_size_h * self.dialog_size)
        self.vm_ptr.gpu:drawRect2D(x, y, w, 1, GPU_GRAY)
        self.vm_ptr.gpu:drawRect2D(x, y + 1, 1, h, GPU_GRAY)
        self.vm_ptr.gpu:drawRect2D(x + w - 1, y + 1, 1, h, GPU_GRAY)
        self.vm_ptr.gpu:drawRect2D(x, y + h, w, 1, GPU_GRAY)
    else
        rl.clearBackground({0, 0, 0, 0})
        self.vm_ptr.gpu:camera2D(-1)

        if self.dialog_id ~= DialogID.SAVE_CART then
            local x: int32 = 4
            local y: int32 = 16
            local w: int32 = GPU_VSCREEN_W - 8
            local h: int32 = GPU_VSCREEN_H - 34
            self.vm_ptr.gpu:drawRect2D(x, y, w, 1, core.cursor_color)
            self.vm_ptr.gpu:drawRect2D(x, y + 1, 1, h, core.cursor_color)
            self.vm_ptr.gpu:drawRect2D(x + w - 1, y + 1, 1, h, core.cursor_color)
            self.vm_ptr.gpu:drawRect2D(x, y + h, w, 1, core.cursor_color)
        end

        self.dialog_ptr.draw(self, self.vm_ptr)
    end
end

function StateMachine:update(): void
    if self.queued_dialog ~= -1 then
        if (self.dialog_id == DialogID.NONE and self.queued_dialog ~= DialogID.NONE) or (self.dialog_id ~= DialogID.NONE and self.queued_dialog == DialogID.NONE) then
            self.animation_type = StateAnimation.DIALOG_OPENCLOSE
            self.anim_time = 0.0
            self.anim_beginning = self.dialog_size
            
            if self.queued_dialog == DialogID.NONE then
                self.anim_target = 0.0
            else
                self.anim_target = 1.0
            end
        end
        
        self.dialog_id = self.queued_dialog
        if self.dialog_id ~= DialogID.NONE then
            self.dialog_ptr = &self.dialogs[self.dialog_id]
        end
        self.queued_dialog = -1
    elseif self.queued_state ~= -1 then
        self.state_ptr.exit(self, self.vm_ptr)
        
        self.prev_state = self.state_id
        self.state_id = self.queued_state
        self.state_ptr = &self.states[self.state_id]

        self.state_ptr.enter(self, self.vm_ptr)
        
        self.queued_state = -1
        
        switch self.state_id do
            case StateID.MAIN then
                self.animation_type = StateAnimation.STATE_SWITCH
                self.anim_time = 0.0
                self.anim_beginning = self.facing_angle
                self.anim_target = 0.0
            case StateID.TRACKER then
                self.animation_type = StateAnimation.STATE_SWITCH
                self.anim_time = 0.0
                self.anim_beginning = self.facing_angle
                self.anim_target = 90.0
            case StateID.TEXTURE then
                self.animation_type = StateAnimation.STATE_SWITCH
                self.anim_time = 0.0
                self.anim_beginning = self.facing_angle
                self.anim_target = -90.0
        end
    end
end

function StateMachine:resetFileBrowser(start_path: string, mode: integer): void
    core.dialog_step = DialogStep.FILE_BROWSER
    core.browser_mode = mode
    if mode == FileBrowserMode.SAVE then
        for i = 0, < 65 do
            core.file_name[i] = '\0'_u8
        end
        core.dialog_val0 = 0 -- filename cursor position
        core.browser_input_mode = FileBrowserInputMode.SET_FILENAME
    else
        core.browser_input_mode = FileBrowserInputMode.SELECT_FILE_OR_DIR
    end

    if core.has_loaded_paths then
        rl.unloadDirectoryFiles(core.file_paths)
        core.has_loaded_paths = false
    end

    core.current_browser_path = start_path
	core.file_paths = rl.loadDirectoryFiles(start_path)
	core.has_loaded_paths = true
    core.browser_index = 0
end

function StateMachine:cleanup(): void
    for i = 0, < StateID.COUNT do
        local st: *State = &self.states[i]
        st.cleanup(self, self.vm_ptr)
    end

    if core.has_loaded_paths then
        rl.unloadDirectoryFiles(core.file_paths)
    end

    if core.has_loaded_image then
        rl.unloadImage(core.image_to_import)
    end

    if core.has_loaded_sample then
        rl.unloadWave(core.sample_to_import)
    end

    if core.has_loaded_model then
        rl.unloadModel(core.model_to_import)
    end
end
