require("e3d")

global StateID = @enum {
    BOOT = 0,
    MAIN,
    CODE,
    TEXTURE,
    MODEL,
    TRACKER,
    RUN,
    COUNT
}

global State <forwarddecl> = @record {}
global StateMachine <forwarddecl> = @record {}

global StateFunction: type = @function(*StateMachine, *e3d.EVM): void

State = @record {
    init: StateFunction,
    enter: StateFunction,
    exit: StateFunction,
    update: StateFunction,
    draw: StateFunction
}

StateMachine = @record {
    states: [StateID.COUNT]State,
    state_ptr: *State,
    vm_ptr: *e3d.EVM,
    state_id: integer,
    queued_state: integer,
    prev_state: integer
}

function StateMachine:initState(): void
    self.state_ptr.init(self, self.vm_ptr)
end

function StateMachine:updateState(): void
    self.state_ptr.update(self, self.vm_ptr)
end

function StateMachine:drawState(): void
    self.state_ptr.draw(self, self.vm_ptr)
end

function StateMachine:back(): void
    self.queued_state = self.prev_state
end

function StateMachine:init(vm: *e3d.EVM): void
    self.vm_ptr = vm

    for i = 0, < StateID.COUNT do
        local st: *State = &self.states[i]
        st.init(self, vm)
    end
    
    self.state_id = StateID.MAIN -- start with main state
    self.state_ptr = &self.states[self.state_id]
    self.queued_state = -1
    self.prev_state = self.state_id

    self.state_ptr.enter(self, vm)
end

function StateMachine:update(): void
    if self.queued_state ~= -1 then
        self.state_ptr.exit(self, self.vm_ptr)
        
        self.prev_state = self.state_id
        self.state_id = self.queued_state
        self.state_ptr = &self.states[self.state_id]

        self.state_ptr.enter(self, self.vm_ptr)
        
        self.queued_state = -1
    end
end
