require("filestream")
require("io")
require("string")
require("sequence")
require("hashmap")
require("stringbuilder")
require("memory")
require("allocators.default")
require("math")
require("coroutine")

require("util")
require("soundchip")
require("gpu")

global e3d = @record{}

-----------------------------
--                         --
--        CONSTANTS        --
--                         --
-----------------------------

--[[ VM logical memory map
	note: 1 vm word = 4 bytes

	SYSTEM MEMORY:
		HEAP                (8MiB         ) 0x00000000 - 0x007FFFFF (general purpose RAM)
		TEXMEM              (4MiB         ) 0x00800000 - 0x00BFFFFF (texture data (1024*1024, 32BPP))
		OBJMEM              (3MiB + 384KiB) 0x00C00000 - 0x00F5FFFF (mesh data (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
		AOBMEM              (8KiB         ) 0x00F60000 - 0x00F61FFF (audio output buffer (2048 16bit stereo audio samples))
		SYSMEM              (632KiB       ) 0x00F62000 - 0x00FFFFFF (system state registers)
			audio state     (1B           )                         (1 byte (track playing flags))
			track state     (72B          )                         (8 * 9 bytes (bpm, volume, pan, song id+pos, pattern id+pos, groove id+pos))
		WAVMEM              (7MiB         ) 0x01000000 - 0x016FFFFF (~1min 23s of audio wave data (22050hz, 16bit, stereo))
		SEQMEM              (256KiB       ) 0x01700000 - 0x0173FFFF (audio sequencer data)
			song data       (2KiB         )                         (256 * 8 bytes)
			pattern data    (80KiB        )                         (256 * 64 * 5 bytes (note, vol, instr, fx, arg))
			instrument data (2KiB + 768B  )                         (256 * 11 bytes (flags, sample start (24bit), sample end(24bit), attack, decay, sustain, release))
			groove data     (256B         )                         (16 * 16 bytes)
			unused          (???KiB + ???B)                         (unused)
		GLOBALS             (256KiB       ) 0x01740000 - 0x0177FFFF (vm global variables (65536 vm words))
		LOCALS              (256KiB       ) 0x01780000 - 0x017BFFFF (vm local variables (65536 vm words))
		ARGS                (256KiB       ) 0x017C0000 - 0x017FFFFF (vm function arguments (65536 vm words))
	CART ROM:
		TEXBANK[0-3]        (16MiB        ) 0x01800000 - 0x027FFFFF (4x texture sheets (1024*1024, 32BPP))
		OBJBANK[0-3]        (16MiB        ) 0x02800000 - 0x037FFFFF (4x mesh data buffers (32768 triangles; 36 bytes per vertex (pos, normal, uv, color)))
		WAVBANK[0-1]        (14MiB        ) 0x03800000 - 0x045FFFFF (2x wav data buffers (22050hz, 16bit, stereo))
		SEQBANK[0-7]        (2MiB         ) 0x04600000 - 0x047FFFFF (8x audio sequencer data buffers)
		ROM                 (16MiB        ) 0x04800000 - 0x057FFFFF (string data + user ROM)
	MEMORY CARD:
		MEMCARD             (256KiB       ) 0x05800000 - 0x0583FFFF (persistent save data (256KiB per registered cart ID))
]]

global e3d.VER_MAJOR <comptime> = 0
global e3d.VER_MINOR <comptime> = 0
global e3d.VER_PATCH <comptime> = 0

-- memory size and address constants
global e3d.SRC_SIZE            <comptime> = 1024*1024
global e3d.HEAP_SIZE           <comptime> = (1024*1024*8) -- 8MiB
global e3d.SYSMEM_SIZE         <comptime> = (632*1024) -- 632KiB
global e3d.GLOBALS_SIZE        <comptime> = 65536 -- 256KiB (65536 words)
global e3d.LOCALS_SIZE         <comptime> = 65536 -- 256KiB (65536 words)
global e3d.ARGS_SIZE           <comptime> = 65536 -- 256KiB (65536 words)
global e3d.TEXBANK_SIZE        <comptime> = (4*1024*1024)  --  16MiB
global e3d.OBJBANK_SIZE        <comptime> = ((16*1024*1024)///4) --  16MiB
global e3d.WAVBANK_SIZE        <comptime> = ((14*1024*1024)///2) --  14MiB
global e3d.SEQBANK_SIZE        <comptime> = (2*1024*1024)  --  2MiB
global e3d.ROM_SIZE            <comptime> = (16*1024*1024) --  16MiB
global e3d.OPSTACK_SIZE        <comptime> = 65536 -- 256KiB (65536 words)
global e3d.BYTECODE_SIZE       <comptime> = 65536 --  64KiB (65536 bytes)
global e3d.CALLSTACK_SIZE      <comptime> = 256
global e3d.API_FUNCS_SIZE      <comptime> = 65536
global e3d.INPUT_PLAYERS_COUNT <comptime> = 4

##[[
local mem_regions = {
	-- system memory
	{name='HEAP',    size=8 * 1024 * 1024},
	{name='TEXMEM',  size=GPU_TEXMEM_SIZE.value * 4},
	{name='OBJMEM',  size=GPU_OBJMEM_SIZE.value * 4},
	{name='AOBMEM',  size=SOUNDCHIP_AOBMEM_SIZE.value * 2},
	{name='SYSMEM',  size=632 * 1024},
	{name='WAVMEM',  size=SOUNDCHIP_WAVMEM_SIZE.value * 2},
	{name='SEQMEM',  size=SOUNDCHIP_SEQMEM_SIZE.value},
	{name='GLOBALS', size=65536 * 4},
	{name='LOCALS',  size=65536 * 4},
	{name='ARGS',    size=65536 * 4},

	-- cart data
	{name='TEXBANK', size=16 * 1024 * 1024},
	{name='OBJBANK', size=16 * 1024 * 1024},
	{name='WAVBANK', size=14 * 1024 * 1024},
	{name='SEQBANK', size= 2 * 1024 * 1024},
	{name='ROM',     size=16 * 1024 * 1024},

	-- memory card
	{name='MEMCARD', size=256 * 1024}
}
]]

-- global e3d.#|region.name..'_START_SIZE'|# <comptime> = #[region.size]#

## local mem_region_offset = 0
## for _ , region in ipairs(mem_regions) do
	global e3d.#|region.name..'_START_ADDR'|# <comptime> = #[mem_region_offset]#

	## mem_region_offset = mem_region_offset + region.size
	
	global e3d.#|region.name..'_MAX_ADDR'|# <comptime> = #[mem_region_offset - 1]#
## end

global e3d.RAM_MAX_ADDR <comptime> = #[mem_region_offset - 1]#
global e3d.NULL <comptime> = 0xFFFFFFFF

-- emulate a PS1-like controller
global e3d.ControllerButtons = @enum {
	UP = 0,
	DOWN,
	LEFT,
	RIGHT,
	TRIANGLE,
	CROSS,
	SQUARE,
	CIRCLE,
	L1,
	L2,
	R1,
	R2,
	SELECT,
	START,
	COUNT -- not an actual button; used to count the number of buttons
}

-- tokens used by the compiler (ecc.nelua)
global e3d.Token = @enum {
	INT_LITERAL = 128, -- start at 128 to avoid conflicts with ASCII chars
	FLOAT_LITERAL,
	STRING_LITERAL,
	VOID,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT_ID, -- struct type id
	STRING,
	STRUCT,
	FUNCTION,
	ENUM,
	ID,
	ELSE,
	IF,
	RETURN,
	BREAK,
	CONTINUE,
	SIZEOF,
	FOR,
	WHILE,
	VARARGS,
	LNOT,
	NOT,
	ASSIGN,
	COND,
	LOR,
	LAND,
	OR,
	XOR,
	AND,
	EQ,
	NE,
	LT,
	GT,
	LE,
	GE,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	ADD,
	SUB,
	MUL,
	DIV,
	MOD,
	ARROW,
	DOT,
	BRAK
}

-- opcodes used by the vm (evm.nelua) and emitted by the compiler (ecc.nelua)
global e3d.Opcode = @enum {
	GET_G = 0,
	GET_GX,
	SET_G,
	SET_GX,
	NEW_L,
	DEL_L,
	GET_L,
	GET_LX,
	SET_L,
	SET_LX,
	GET_A,
	GET_AX,
	SET_A,
	SET_AX,
	GET_M,
	GET_MX,
	SET_M,
	SET_MX,
	GET_S,
	SET_S,
	ADDROF_G,
	ADDROF_L,
	ADDROF_A,
	PUSH_ZERO,
	PUSH_ZEROF,
	PUSH_ONE,
	PUSH_ONEF,
	PUSH_CHAR,
	PUSH_INT,
	PUSH_FLOAT,
	PUSH_VEC2_ZERO,
	PUSH_VEC3_ZERO,
	PUSH_STRING,
	DISCARD,
	NOT,
	OR,
	XOR,
	AND,
	LSHIFT,
	RSHIFT,
	ARSHIFT,
	NEG,
	NEGF,
	NEGV,
	ADD,
	ADDF,
	ADDV,
	ADDP,
	SUB,
	SUBF,
	SUBV,
	SUBP,
	MUL,
	MULF,
	MULV,
	DIV,
	DIVU,
	DIVF,
	DIVV,
	MOD,
	MODU,
	MODF,
	LNOT,
	LNOTP,
	EQ,
	EQF,
	EQV,
	EQS,
	NE,
	NEF,
	NEV,
	NES,
	LTI,
	LTU,
	LTF,
	LTV,
	GTI,
	GTU,
	GTF,
	GTV,
	LEI,
	LEU,
	LEF,
	LEV,
	GEI,
	GEU,
	GEF,
	GEV,
	JUMP,
	JUMP_Z,
	JUMP_ZD,
	JUMP_NZD,
	JUMP_NULL,
	JUMP_NULLD,
	JUMP_NNULLD,
	CALL,
	CALL_PTR,
	RETURN,
	VARGP,
	FTOI,
	ITOF,
	ITOB, -- int to bool, used by || and && operators
	PTOB, -- pointer to bool, used by || and && operators
	API
}

-- 
global e3d.Class = @enum {
	KEYWORD = 0,
	API,
	CONSTANT,
	STRUCT,
	FUNCTION,
	MEMORY, -- only used when writing values into memory using pointers
	STRING, -- only used when writing characters to a string using indexing
	GLOBAL,
	ARG,
	LOCAL
}

global e3d.EVMType = @enum {
	VOID = 0,
	INT,
	FLOAT,
	VEC2,
	VEC3,
	STRUCT,
	STRING,
	FUNC_POINTER,
	POINTER = 16 -- repeatedly added to type id value to indicate pointer levels
}

-- vm multiplication opcode has several modes for multiplying different types
global e3d.MulVMode = @enum {
	INT_V2 = 0,
	INT_V3,
	FLOAT_V2,
	FLOAT_V3,
	V2_INT,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm division opcode has several modes for dividing different types
global e3d.DivVMode = @enum {
	V2_INT = 0,
	V2_FLOAT,
	V2_V2,
	V3_INT,
	V3_FLOAT,
	V3_V3
}

-- vm script hook function ids
global e3d.Hook = @enum {
	INIT = 0,
	UPDATE,
	DRAW,
	COUNT
}

global e3d.IOState = @enum {
	IDLE = 0,
	SAVING,
	LOADING
}

-------------------------
--                     --
--        TYPES        --
--                     --
-------------------------

global e3d.EVM <forwarddecl> = @record {}

global e3d.Identifier <forwarddecl> = @record {}

global e3d.APIFunction: type = @function(vm: *e3d.EVM): boolean

-- record used to represet an ERA-C string struct
global e3d.EVMString = @record {
	len: uint32, -- string length
	data: uint32 -- string data virtual address
}

-- record used to represet an ERA-C colaabb struct
global e3d.ColAABB = @record {
	type: uint32,
	position: rl.vector3,
	width: float32,
	height: float32,
	depth: float32
}

-- record that tracks data used by the vm when calling functions
global e3d.CallFrame = @record {
	pc: uinteger,
	lbp: uinteger,
	argc: uint16,
	vargc: uint16, -- remaining vararg word count for function
	vargp: uint16, -- vararg pointer
	vargf: boolean, -- vararg flag, true if the function for this frame is a varargs function
}

-- ERA-C struct metadata record used in the compiler
global e3d.Struct = @record {
	is_complete: boolean,
	size: uinteger,
	name: string,
	member_map: hashmap(string, uinteger),
	members: sequence(*e3d.Identifier)
}

-- 
global e3d.TypeInfo = @record {
	type_id: uinteger,
	structref: *e3d.Struct -- only used when base_type is e3d.EVMType.STRUCT
}

global e3d.LoopInfo = @record {
	loop_start: uinteger,
	loop_step: uinteger,
	loop_end: uinteger,
	break_count: uinteger,
	step_count: uinteger,
	del_l_count: uinteger,
	has_step: boolean
}

e3d.Identifier = @record {
	name: string,
	token: uinteger,
	class: uinteger,
	index: uinteger,
	varargs_index: uinteger, -- only used for varargs functions
	type_info: e3d.TypeInfo,
	is_array: boolean,
	is_varargs: boolean, -- only used for functions
	const_val: uint32, -- only used for constants
	const_valf: float32, -- only used for constants
	func: e3d.APIFunction, -- only used when registering api functions
	argdata: sequence(e3d.TypeInfo) -- only used to track function arguments
}

global e3d.Cart = @record {
	texbank: [e3d.TEXBANK_SIZE]rl.color,
	objbank: [e3d.OBJBANK_SIZE]util.IntFloat,
	wavbank: [e3d.WAVBANK_SIZE]BKFrame,
	seqbank: [e3d.SEQBANK_SIZE]uint8,
	rom: [e3d.ROM_SIZE]uint8,
}

global e3d.IOCallback: type = @function(*e3d.EVM, boolean): void

e3d.EVM = @record {
	-- vm vars
	heap: [e3d.HEAP_SIZE]uint8,
	globals: [e3d.GLOBALS_SIZE]util.IntFloat,
	locals: [e3d.GLOBALS_SIZE]util.IntFloat,
	args: [e3d.ARGS_SIZE]util.IntFloat,
	opstack: [e3d.OPSTACK_SIZE]util.IntFloat,
	bytecode: [e3d.BYTECODE_SIZE]uint8,
	callstack: [e3d.CALLSTACK_SIZE]e3d.CallFrame,
	api_funcs: [e3d.API_FUNCS_SIZE]e3d.APIFunction,
	sysmem: [e3d.SYSMEM_SIZE]uint8,
	cf: e3d.CallFrame,
	rom_len: uinteger,
	bytecode_len: uinteger,
	globals_len: uinteger,
	lsp: uinteger,
	asp: uinteger,
	ap: uinteger, -- ap for current function
	osp: uinteger,
	csp: uinteger,
	hook_addresses: [3]uint16,
	hook_flags: [3]boolean,
	current_hook: uinteger,
	
	-- compiler vars
	src: [e3d.SRC_SIZE]uint8,
	src_len: uinteger,
	src_index: uinteger,
	prev_src_index: uinteger,
	token: uinteger,
	token_val: uinteger,
	token_valf: float32,
	string_len: uinteger,
	prev_token: uinteger,
	prev_scope_size: uint16,
	line: uinteger,
	expr_type: e3d.TypeInfo,
	local_index: uinteger,
	mlcomment_level: uinteger,
	prev_opcode: uint8,
	has_id: boolean,
	skip_next_id_lookup: boolean,
	compile_err: boolean,
	current_id: *e3d.Identifier,
	current_id_name: string,
	current_func_id: *e3d.Identifier,
	struct_vec2: *e3d.Struct,
	struct_vec3: *e3d.Struct,
	struct_string: *e3d.Struct,
	sb: stringbuilder,
	keywords: hashmap(string, *e3d.Identifier),
	constants: hashmap(string, *e3d.Identifier),
	api_ids: hashmap(string, *e3d.Identifier),
	builtin_struct_ids: hashmap(string, *e3d.Identifier),
	struct_ids: hashmap(string, *e3d.Identifier),
	sym_tables: sequence(*hashmap(string, *e3d.Identifier)),
	scope_sizes: sequence(uinteger),
	loop_info_stack: sequence(e3d.LoopInfo),
	loop_break_stack: sequence(uint16),
	loop_step_stack: sequence(uint16),
	loop_del_l_stack: sequence(uint16),
	
	-- general vars
	cart: e3d.Cart,
	temp_cart: e3d.Cart, -- used for temp storage while saving cart data
	soundchip: SoundChip,
	gpu: GPU,
	error: string,
	init_time: float64,
	io_callback: e3d.IOCallback,
	io_co: coroutine,
	io_state: uint8,
	io_result: boolean
}

global e3d.btnmap: [e3d.ControllerButtons.COUNT * e3d.INPUT_PLAYERS_COUNT]cint

---------------------------------------
--                                   --
--        NAMESPACE FUNCTIONS        --
--                                   --
---------------------------------------

function e3d.setDefaultBtnmap(): void
	e3d.btnmap[e3d.ControllerButtons.UP]       = rl.keyboardKey.UP
	e3d.btnmap[e3d.ControllerButtons.DOWN]     = rl.keyboardKey.DOWN
	e3d.btnmap[e3d.ControllerButtons.LEFT]     = rl.keyboardKey.LEFT
	e3d.btnmap[e3d.ControllerButtons.RIGHT]    = rl.keyboardKey.RIGHT
	e3d.btnmap[e3d.ControllerButtons.TRIANGLE] = rl.keyboardKey.W
	e3d.btnmap[e3d.ControllerButtons.CROSS]    = rl.keyboardKey.S
	e3d.btnmap[e3d.ControllerButtons.SQUARE]   = rl.keyboardKey.A
	e3d.btnmap[e3d.ControllerButtons.CIRCLE]   = rl.keyboardKey.D
	e3d.btnmap[e3d.ControllerButtons.L1]       = rl.keyboardKey.Q
	e3d.btnmap[e3d.ControllerButtons.L2]       = rl.keyboardKey.ONE
	e3d.btnmap[e3d.ControllerButtons.R1]       = rl.keyboardKey.E
	e3d.btnmap[e3d.ControllerButtons.R2]       = rl.keyboardKey.THREE
	e3d.btnmap[e3d.ControllerButtons.SELECT]   = rl.keyboardKey.RIGHT_SHIFT
	e3d.btnmap[e3d.ControllerButtons.START]    = rl.keyboardKey.ENTER
end

function e3d.getBtnKeycode(btn: integer): cint
	return e3d.btnmap[btn]
end

function e3d.setBtnKeycode(btn: integer, keycode: cint): void
	e3d.btnmap[btn] = keycode
end
