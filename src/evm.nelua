require("io")
require("allocators.gc")
require("C.stdio")

require("zip")

require("api")

function EVM:getGlobal(i: uint16): IntFloat
	return self.globals[i]
end

function EVM:getGlobalI(i: uint16): int32
	return self.globals[i].i
end

function EVM:getGlobalU(i: uint16): uint32
	return self.globals[i].u
end

function EVM:getGlobalF(i: uint16): float32
	return self.globals[i].f
end

function EVM:getGlobalV2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	
	return v
end

function EVM:getGlobalV3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	v.z = self.globals[i + 2].f
	
	return v
end

function EVM:setGlobal(i: uint16, val: IntFloat): void
	self.globals[i] = val
end

function EVM:setGlobalI(i: uint16, val: int32): void
	self.globals[i].i = val
end

function EVM:setGlobalU(i: uint16, val: uint32): void
	self.globals[i].u = val
end

function EVM:setGlobalF(i: uint16, val: float32): void
	self.globals[i].f = val
end

function EVM:setGlobalV2(i: uint16, val: rl.vector2): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
end

function EVM:setGlobalV3(i: uint16, val: rl.vector3): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
	self.globals[i + 2].f = val.z
end

function EVM:getLocal(i: uint16): IntFloat
	return self.locals[self.cf.lbp + i]
end

function EVM:setLocal(i: uint16, val: IntFloat): void
	self.locals[self.cf.lbp + i] = val
end

function EVM:getArg(i: uint16): IntFloat
	return self.args[self.ap + i]
end

function EVM:getArgI(i: uint16): int32
	return self.args[self.ap + i].i
end

function EVM:getArgU(i: uint16): uint32
	return self.args[self.ap + i].u
end

function EVM:getArgF(i: uint16): float32
	return self.args[self.ap + i].f
end

function EVM:getArgV2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f

	return v
end

function EVM:getArgV3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f
	v.z = self.args[self.ap + i + 2].f

	return v
end

function EVM:getArgStr(i: uint16): EVMString
	local s: EVMString

	s.len = self.args[self.ap + i].u
	s.data = self.args[self.ap + i + 1].u

	return s
end

function EVM:getArgMat(i: uint16): rl.matrix
	return {
		self.args[self.ap + i].f,
		self.args[self.ap + i + 1].f,
		self.args[self.ap + i + 2].f,
		self.args[self.ap + i + 3].f,
		self.args[self.ap + i + 4].f,
		self.args[self.ap + i + 5].f,
		self.args[self.ap + i + 6].f,
		self.args[self.ap + i + 7].f,
		self.args[self.ap + i + 8].f,
		self.args[self.ap + i + 9].f,
		self.args[self.ap + i + 10].f,
		self.args[self.ap + i + 11].f,
		self.args[self.ap + i + 12].f,
		self.args[self.ap + i + 13].f,
		self.args[self.ap + i + 14].f,
		self.args[self.ap + i + 15].f
	}
end

function EVM:setArg(i: uint16, val: IntFloat): void
	self.args[self.ap + i] = val
end

function EVM:setArgI(i: uint16, val: int32): void
	self.args[self.ap + i].i = val
end

function EVM:setArgU(i: uint16, val: uint32): void
	self.args[self.ap + i].u = val
end

function EVM:setArgF(i: uint16, val: float32): void
	self.args[self.ap + i].f = val
end

function EVM:setArgV2(i: uint16, val: rl.vector2): void
	self.args[self.ap + i    ].f = val.x
	self.args[self.ap + i + 1].f = val.y
end

function EVM:setArgV3(i: uint16, val: rl.vector3): void
	self.args[self.ap + i    ].f = val.x
	self.args[self.ap + i + 1].f = val.y
	self.args[self.ap + i + 2].f = val.z
end

function EVM:setArgStr(i: uint16, val: EVMString): void
	self.args[self.ap + i    ].u = val.len
	self.args[self.ap + i + 1].u = val.data
end

function EVM:push(val: IntFloat): void
	self.opstack[self.osp] = val
	self.osp = self.osp + 1
end

function EVM:pushI(val: int32): void
	self.opstack[self.osp] = {i=val}
	self.osp = self.osp + 1
end

function EVM:pushU(val: uint32): void
	self.opstack[self.osp] = {u=val}
	self.osp = self.osp + 1
end

function EVM:pushF(val: float32): void
	self.opstack[self.osp] = {f=val}
	self.osp = self.osp + 1
end

function EVM:pushV2(val: rl.vector2): void
	self.opstack[self.osp    ] = {f=val.x}
	self.opstack[self.osp + 1] = {f=val.y}
	self.osp = self.osp + 2
end

function EVM:pushV3(val: rl.vector3): void
	self.opstack[self.osp    ] = {f=val.x}
	self.opstack[self.osp + 1] = {f=val.y}
	self.opstack[self.osp + 2] = {f=val.z}
	self.osp = self.osp + 3
end

function EVM:pushStr(val: EVMString): void
	self.opstack[self.osp    ] = {u=val.len}
	self.opstack[self.osp + 1] = {u=val.data}
	self.osp = self.osp + 2
end

function EVM:pushMat(val: rl.matrix): void
	self.opstack[self.osp    ].f = val.m0
	self.opstack[self.osp + 1].f = val.m4
	self.opstack[self.osp + 2].f = val.m8
	self.opstack[self.osp + 3].f = val.m12
	self.opstack[self.osp + 4].f = val.m1
	self.opstack[self.osp + 5].f = val.m5
	self.opstack[self.osp + 6].f = val.m9
	self.opstack[self.osp + 7].f = val.m13
	self.opstack[self.osp + 8].f = val.m2
	self.opstack[self.osp + 9].f = val.m6
	self.opstack[self.osp + 10].f = val.m10
	self.opstack[self.osp + 11].f = val.m14
	self.opstack[self.osp + 12].f = val.m3
	self.opstack[self.osp + 13].f = val.m7
	self.opstack[self.osp + 14].f = val.m11
	self.opstack[self.osp + 15].f = val.m15
	self.osp = self.osp + 16
end

function EVM:pop(): IntFloat
	self.osp = self.osp - 1
	return self.opstack[self.osp]
end

function EVM:popI(): int32
	self.osp = self.osp - 1
	return self.opstack[self.osp].i
end

function EVM:popU(): uint32
	self.osp = self.osp - 1
	return self.opstack[self.osp].u
end

function EVM:popF(): float32
	self.osp = self.osp - 1
	return self.opstack[self.osp].f
end

function EVM:popV2(): rl.vector2
	self.osp = self.osp - 2
	return {
		self.opstack[self.osp    ].f,
		self.opstack[self.osp + 1].f
	}
end

function EVM:popV3(): rl.vector3
	self.osp = self.osp - 3
	return {
		self.opstack[self.osp    ].f,
		self.opstack[self.osp + 1].f,
		self.opstack[self.osp + 2].f
	}
end

function EVM:popStr(): EVMString
	self.osp = self.osp - 2
	return {
		self.opstack[self.osp    ].u,
		self.opstack[self.osp + 1].u
	}
end

function EVM:resetHeap(): void
	self.heap_head.next = nilptr
	self.heap_head.address = 0
	self.heap_head.size = MEMORY_HEAP_SIZE_BYTES
	self.heap_head.used = false
end

function EVM:resetVM(reset_all: boolean): void
	self:resetHeap()

	self.cf = {}
	self.lsp = 0
	self.asp = 0
	self.ap = 0
	self.osp = 0
	self.csp = 0
	self.init_time = rl.getTime()
	self.memcard_initialized = false

	if reset_all then
		self.soundchip:resetSoundchip()
		self.soundchip:loadWavBank(0)
		self.soundchip:loadSeqBank(0)
		
		self.gpu:resetGPU()
		self.gpu:loadTexBank(0)
		self.gpu:loadObjBank(0)
	end

	math.randomseed()
end

function EVM:discard(n: uint16): void
	self.osp = self.osp - n
end

-- get one byte from the vm memory, does not do bounds or alignment checking!
function EVM:getMem8(addr: uint32): uint8
	if addr <= MEMORY_HEAP_MAX_ADDR then
		return self.heap[addr]
	elseif addr <= MEMORY_TEXMEM_MAX_ADDR then
		local col: *rl.color = &self.gpu.texmem[(addr - MEMORY_TEXMEM_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				return (@uint8)(col.r)
			case 1 then
				return (@uint8)(col.g)
			case 2 then
				return (@uint8)(col.b)
			case 3 then
				return (@uint8)(col.a)
			else
				-- should not happen
				return 0
		end
	elseif addr <= MEMORY_OBJMEM_MAX_ADDR then
		return util.getIntFloatBtye(&self.gpu.objmem, MEMORY_OBJMEM_START_ADDR, addr)
	elseif addr <= MEMORY_AOBMEM_MAX_ADDR then
		local frame: uint16 = self.soundchip.aobmem[(addr - MEMORY_AOBMEM_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= MEMORY_SYSMEM_MAX_ADDR then
		return self.sysmem[addr - MEMORY_SYSMEM_START_ADDR]
	elseif addr <= MEMORY_WAVMEM_MAX_ADDR then
		local frame: uint16 = self.soundchip.wavmem[(addr - MEMORY_WAVMEM_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= MEMORY_SEQMEM_MAX_ADDR then
		return self.soundchip.seqmem[addr - MEMORY_SEQMEM_START_ADDR]
	elseif addr <= MEMORY_GLOBALS_MAX_ADDR then
		return util.getIntFloatBtye(&self.globals, MEMORY_GLOBALS_START_ADDR, addr)
	elseif addr <= MEMORY_LOCALS_MAX_ADDR then
		return util.getIntFloatBtye(&self.locals, MEMORY_LOCALS_START_ADDR, addr)
	elseif addr <= MEMORY_ARGS_MAX_ADDR then
		return util.getIntFloatBtye(&self.args, MEMORY_ARGS_START_ADDR, addr)
	elseif addr <= MEMORY_TEXBANK_MAX_ADDR then
		local col: *rl.color = &self.cart.texbank[(addr - MEMORY_TEXBANK_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				return (@uint8)(col.r)
			case 1 then
				return (@uint8)(col.g)
			case 2 then
				return (@uint8)(col.b)
			case 3 then
				return (@uint8)(col.a)
			else
				-- should not happen
				return 0
		end
	elseif addr <= MEMORY_OBJBANK_MAX_ADDR then
		return util.getIntFloatBtye(&self.cart.objbank, MEMORY_OBJBANK_START_ADDR, addr)
	elseif addr <= MEMORY_OMPBANK_MAX_ADDR then
		return self.cart.ompbank[addr - MEMORY_OMPBANK_START_ADDR]
	elseif addr <= MEMORY_WMPBANK_MAX_ADDR then
		return self.cart.wmpbank[addr - MEMORY_WMPBANK_START_ADDR]
	elseif addr <= MEMORY_WAVBANK_MAX_ADDR then
		local frame: uint16 = self.cart.wavbank[(addr - MEMORY_WAVBANK_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= MEMORY_SEQBANK_MAX_ADDR then
		return self.cart.seqbank[addr - MEMORY_SEQBANK_START_ADDR]
	elseif addr <= MEMORY_ROM_MAX_ADDR then
		return self.cart.rom[addr - MEMORY_ROM_START_ADDR]
	elseif addr <= MEMORY_MEMCARD_MAX_ADDR then
		if self.memcard_initialized then
			return self.memcard[addr - MEMORY_MEMCARD_START_ADDR]
		else
			return 0
		end
	else
		return 0
	end
end

-- set one byte in the vm memory, does not do bounds or alignment checking!
function EVM:setMem8(addr: uint32, val: uint8): boolean
	if addr <= MEMORY_HEAP_MAX_ADDR then
		self.heap[addr] = val
	elseif addr <= MEMORY_TEXMEM_MAX_ADDR then
		local col: *rl.color = &self.gpu.texmem[(addr - MEMORY_TEXMEM_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				col.r = (@cuchar)(val)
			case 1 then
				col.g = (@cuchar)(val)
			case 2 then
				col.b = (@cuchar)(val)
			case 3 then
				col.a = (@cuchar)(val)
		end
		self.gpu.update_tex = true
	elseif addr <= MEMORY_OBJMEM_MAX_ADDR then
		util.setIntFloatByte(&self.gpu.objmem, MEMORY_OBJMEM_START_ADDR, addr, val)
	elseif addr <= MEMORY_AOBMEM_MAX_ADDR then
		local frame: *uint16 = (@*uint16)(&self.soundchip.aobmem[(addr - MEMORY_AOBMEM_START_ADDR) /// 2])
		local shift: uinteger = 8 * (addr & 1)
		$frame = ($frame & (0xFF00 >> shift)) | (val << 8) >> shift
	elseif addr <= MEMORY_SYSMEM_MAX_ADDR then
		addr = addr - MEMORY_SYSMEM_START_ADDR
		self.sysmem[addr] = val

		if addr >= MEMORY_LIGHTS_INDEX and addr < MEMORY_RENDER_STATE_INDEX then
			self.gpu.update_lights = true
		end
	elseif addr <= MEMORY_WAVMEM_MAX_ADDR then
		local frame: *uint16 = (@*uint16)(&self.soundchip.wavmem[(addr - MEMORY_WAVMEM_START_ADDR) /// 2])
		local shift: uinteger = 8 * (addr & 1)
		$frame = ($frame & (0xFF00 >> shift)) | (val << 8) >> shift
	elseif addr <= MEMORY_SEQMEM_MAX_ADDR then
		self.soundchip.seqmem[addr - MEMORY_SEQMEM_START_ADDR] = val
	elseif addr <= MEMORY_GLOBALS_MAX_ADDR then
		util.setIntFloatByte(&self.globals, MEMORY_GLOBALS_START_ADDR, addr, val)
	elseif addr <= MEMORY_LOCALS_MAX_ADDR then
		util.setIntFloatByte(&self.locals, MEMORY_LOCALS_START_ADDR, addr, val)
	elseif addr <= MEMORY_ARGS_MAX_ADDR then
		util.setIntFloatByte(&self.args, MEMORY_ARGS_START_ADDR, addr, val)
	elseif addr <= MEMORY_TEXBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_OMPBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_WMPBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_OBJBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_WAVBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_SEQBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_ROM_MAX_ADDR then
		return false
	elseif addr <= MEMORY_MEMCARD_MAX_ADDR then
		if self.memcard_initialized then
			self.memcard[addr - MEMORY_MEMCARD_START_ADDR] = val
		else
			return false
		end
	else
		return false
	end

	return true
end

-- get one word from the vm memory, does not do bounds or alignment checking!
function EVM:getMem32(addr: uint32): uint32
	if addr <= MEMORY_HEAP_MAX_ADDR then
		return ((@uint32)(self.heap[addr]) << 24) | ((@uint32)(self.heap[addr + 1]) << 16) | ((@uint32)(self.heap[addr + 2]) << 8) | (@uint32)(self.heap[addr + 3])
	elseif addr <= MEMORY_TEXMEM_MAX_ADDR then
		local col: rl.color = self.gpu.texmem[(addr - MEMORY_TEXMEM_START_ADDR) /// 4]
		return (((@uint32)(col.r) << 24) | ((@uint32)(col.g) << 16) | ((@uint32)(col.b) << 8) | (@uint32)(col.a))
	elseif addr <= MEMORY_OBJMEM_MAX_ADDR then
		return self.gpu.objmem[(addr - MEMORY_OBJMEM_START_ADDR) /// 4].u
	elseif addr <= MEMORY_AOBMEM_MAX_ADDR then
		local index: uinteger = (addr - MEMORY_AOBMEM_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.soundchip.aobmem[index])
		local frame1: uint32 = (@uint32)(self.soundchip.aobmem[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= MEMORY_SYSMEM_MAX_ADDR then
		addr = addr - MEMORY_SYSMEM_START_ADDR
		return ((@uint32)(self.sysmem[addr]) << 24) | ((@uint32)(self.sysmem[addr + 1]) << 16) | ((@uint32)(self.sysmem[addr + 2]) << 8) | (@uint32)(self.sysmem[addr + 3])
	elseif addr <= MEMORY_WAVMEM_MAX_ADDR then
		local index: uinteger = (addr - MEMORY_WAVMEM_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.soundchip.wavmem[index])
		local frame1: uint32 = (@uint32)(self.soundchip.wavmem[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= MEMORY_SEQMEM_MAX_ADDR then
		addr = addr - MEMORY_SEQMEM_START_ADDR
		return ((@uint32)(self.soundchip.seqmem[addr]) << 24) | ((@uint32)(self.soundchip.seqmem[addr + 1]) << 16) | ((@uint32)(self.soundchip.seqmem[addr + 2]) << 8) | (@uint32)(self.soundchip.seqmem[addr + 3])
	elseif addr <= MEMORY_GLOBALS_MAX_ADDR then
		return self.globals[(addr - MEMORY_GLOBALS_START_ADDR) /// 4].u
	elseif addr <= MEMORY_LOCALS_MAX_ADDR then
		return self.locals[(addr - MEMORY_LOCALS_START_ADDR) /// 4].u
	elseif addr <= MEMORY_ARGS_MAX_ADDR then
		return self.args[(addr - MEMORY_ARGS_START_ADDR) /// 4].u
	elseif addr <= MEMORY_TEXBANK_MAX_ADDR then
		local col: rl.color = self.cart.texbank[(addr - MEMORY_TEXBANK_START_ADDR) /// 4]
		return (((@uint32)(col.r) << 24) | ((@uint32)(col.g) << 16) | ((@uint32)(col.b) << 8) | (@uint32)(col.a))
	elseif addr <= MEMORY_OBJBANK_MAX_ADDR then
		return self.cart.objbank[(addr - MEMORY_OBJBANK_START_ADDR) /// 4].u
	elseif addr <= MEMORY_OMPBANK_MAX_ADDR then
		addr = addr - MEMORY_OMPBANK_START_ADDR
		return ((@uint32)(self.cart.ompbank[addr]) << 24) | ((@uint32)(self.cart.ompbank[addr + 1]) << 16) | ((@uint32)(self.cart.ompbank[addr + 2]) << 8) | (@uint32)(self.cart.ompbank[addr + 3])
	elseif addr <= MEMORY_WMPBANK_MAX_ADDR then
		addr = addr - MEMORY_WMPBANK_START_ADDR
		return ((@uint32)(self.cart.wmpbank[addr]) << 24) | ((@uint32)(self.cart.wmpbank[addr + 1]) << 16) | ((@uint32)(self.cart.wmpbank[addr + 2]) << 8) | (@uint32)(self.cart.wmpbank[addr + 3])
	elseif addr <= MEMORY_WAVBANK_MAX_ADDR then
		local index: uinteger = (addr - MEMORY_WAVBANK_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.cart.wavbank[index])
		local frame1: uint32 = (@uint32)(self.cart.wavbank[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= MEMORY_SEQBANK_MAX_ADDR then
		addr = addr - MEMORY_SEQBANK_START_ADDR
		return ((@uint32)(self.cart.seqbank[addr]) << 24) | ((@uint32)(self.cart.seqbank[addr + 1]) << 16) | ((@uint32)(self.cart.seqbank[addr + 2]) << 8) | (@uint32)(self.cart.seqbank[addr + 3])
	elseif addr <= MEMORY_ROM_MAX_ADDR then
		addr = addr - MEMORY_ROM_START_ADDR
		return ((@uint32)(self.cart.rom[addr]) << 24) | ((@uint32)(self.cart.rom[addr + 1]) << 16) | ((@uint32)(self.cart.rom[addr + 2]) << 8) | (@uint32)(self.cart.rom[addr + 3])
	elseif addr <= MEMORY_MEMCARD_MAX_ADDR then
		if self.memcard_initialized then
			addr = addr - MEMORY_MEMCARD_START_ADDR
			return ((@uint32)(self.memcard[addr]) << 24) | ((@uint32)(self.memcard[addr + 1]) << 16) | ((@uint32)(self.memcard[addr + 2]) << 8) | (@uint32)(self.memcard[addr + 3])
		else
			return 0
		end
	else
		return 0
	end
end

-- set one word in the vm memory, does not do bounds or alignment checking!
function EVM:setMem32(addr: uint32, val: uint32): boolean
	if addr <= MEMORY_HEAP_MAX_ADDR then
		self.heap[addr] = val >> 24
		self.heap[addr + 1] = (val & 0xFF0000) >> 16
		self.heap[addr + 2] = (val & 0x00FF00) >> 8
		self.heap[addr + 3] = val & 0xFF
	elseif addr <= MEMORY_TEXMEM_MAX_ADDR then
		local col: rl.color
		addr = (addr - MEMORY_TEXMEM_START_ADDR) /// 4
		col.r = val >> 24
		col.g = (val & 0xFF0000) >> 16
		col.b = (val & 0x00FF00) >> 8
		col.a = val & 0xFF
		self.gpu.texmem[addr] = col
		self.gpu.update_tex = true
	elseif addr <= MEMORY_OBJMEM_MAX_ADDR then
		self.gpu.objmem[(addr - MEMORY_OBJMEM_START_ADDR) /// 4].u = val
	elseif addr <= MEMORY_AOBMEM_MAX_ADDR then
		local frame0: uint16 = val >> 16
		local frame1: uint16 = val & 0xFFFF
		addr = (addr - MEMORY_AOBMEM_START_ADDR) /// 2
		self.soundchip.aobmem[addr] = frame0
		self.soundchip.aobmem[addr + 1] = frame1
	elseif addr <= MEMORY_SYSMEM_MAX_ADDR then
		addr = addr - MEMORY_SYSMEM_START_ADDR
		self.sysmem[addr] = val >> 24
		self.sysmem[addr + 1] = (val & 0xFF0000) >> 16
		self.sysmem[addr + 2] = (val & 0x00FF00) >> 8
		self.sysmem[addr + 3] = val & 0xFF

		if addr >= MEMORY_LIGHTS_INDEX and addr < MEMORY_RENDER_STATE_INDEX then
			self.gpu.update_lights = true
		end
	elseif addr <= MEMORY_WAVMEM_MAX_ADDR then
		local frame0: uint16 = val >> 16
		local frame1: uint16 = val & 0xFFFF
		addr = (addr - MEMORY_WAVMEM_START_ADDR) /// 2
		self.soundchip.wavmem[addr] = frame0
		self.soundchip.wavmem[addr + 1] = frame1
	elseif addr <= MEMORY_SEQMEM_MAX_ADDR then
		addr = addr - MEMORY_SEQMEM_START_ADDR
		self.soundchip.seqmem[addr] = val >> 24
		self.soundchip.seqmem[addr + 1] = (val & 0xFF0000) >> 16
		self.soundchip.seqmem[addr + 2] = (val & 0x00FF00) >> 8
		self.soundchip.seqmem[addr + 3] = val & 0xFF
	elseif addr <= MEMORY_GLOBALS_MAX_ADDR then
		self.globals[(addr - MEMORY_GLOBALS_START_ADDR) /// 4].u = val
	elseif addr <= MEMORY_LOCALS_MAX_ADDR then
		self.locals[(addr - MEMORY_LOCALS_START_ADDR) /// 4].u = val
	elseif addr <= MEMORY_ARGS_MAX_ADDR then
		self.args[(addr - MEMORY_ARGS_START_ADDR) /// 4].u = val
	elseif addr <= MEMORY_TEXBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_OBJBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_OMPBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_WMPBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_WAVBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_SEQBANK_MAX_ADDR then
		return false
	elseif addr <= MEMORY_ROM_MAX_ADDR then
		return false
	elseif addr <= MEMORY_MEMCARD_MAX_ADDR then
		if self.memcard_initialized then
			addr = addr - MEMORY_MEMCARD_START_ADDR
			self.memcard[addr] = val >> 24
			self.memcard[addr + 1] = (val & 0xFF0000) >> 16
			self.memcard[addr + 2] = (val & 0x00FF00) >> 8
			self.memcard[addr + 3] = val & 0xFF
		else
			return false
		end
	else
		return false
	end

	return true
end

function EVM:getMemColPoint(addr: uint32, point: *ColPoint): boolean
	-- address is already confirmed to be aligned

	--[[ memory layout
		 0-3  type
		 4-7  position.x
		 8-11 position.x
		12-15 position.x
	]]

	local intf: IntFloat

	if addr + 15 > MEMORY_MAX_ADDR then
		self.error = string.format("invalid word read address 0x%08X", addr)
		return false
	end

	intf.u = self:getMem32(addr + 4)
	point.position.x = intf.f
	intf.u = self:getMem32(addr + 8)
	point.position.y = intf.f
	intf.u = self:getMem32(addr + 12)
	point.position.z = intf.f

	return true
end

function EVM:getMemColAABB(addr: uint32, aabb: *ColAABB): boolean
	-- address is already confirmed to be aligned

	--[[ memory layout
		 0-3  type
		 4-7  position.x
		 8-11 position.x
		12-15 position.x
		16-19 width
		20-13 height
		24-27 depth
	]]

	local intf: IntFloat

	if addr + 27 > MEMORY_MAX_ADDR then
		self.error = string.format("invalid word read address 0x%08X", addr)
		return false
	end

	intf.u = self:getMem32(addr + 4)
	aabb.position.x = intf.f
	intf.u = self:getMem32(addr + 8)
	aabb.position.y = intf.f
	intf.u = self:getMem32(addr + 12)
	aabb.position.z = intf.f
	intf.u = self:getMem32(addr + 16)
	aabb.width = intf.f
	intf.u = self:getMem32(addr + 20)
	aabb.height = intf.f
	intf.u = self:getMem32(addr + 24)
	aabb.depth = intf.f

	return true
end

function EVM:getMemColSphere(addr: uint32, sphere: *ColSphere): boolean
	-- address is already confirmed to be aligned

	--[[ memory layout
		 0-3  type
		 4-7  position.x
		 8-11 position.x
		12-15 position.x
		16-19 radius
	]]

	local intf: IntFloat

	if addr + 19 > MEMORY_MAX_ADDR then
		self.error = string.format("invalid word read address 0x%08X", addr)
		return false
	end

	intf.u = self:getMem32(addr + 4)
	sphere.position.x = intf.f
	intf.u = self:getMem32(addr + 8)
	sphere.position.y = intf.f
	intf.u = self:getMem32(addr + 12)
	sphere.position.z = intf.f
	intf.u = self:getMem32(addr + 16)
	sphere.radius = intf.f

	return true
end

function EVM:getMemColCylinder(addr: uint32, cylinder: *ColCylinder): boolean
	-- address is already confirmed to be aligned

	--[[ memory layout
		 0-3  type
		 4-7  position.x
		 8-11 position.x
		12-15 position.x
		16-19 height
		20-23 radius
	]]

	local intf: IntFloat

	if addr + 23 > MEMORY_MAX_ADDR then
		self.error = string.format("invalid word read address 0x%08X", addr)
		return false
	end

	intf.u = self:getMem32(addr + 4)
	cylinder.position.x = intf.f
	intf.u = self:getMem32(addr + 8)
	cylinder.position.y = intf.f
	intf.u = self:getMem32(addr + 12)
	cylinder.position.z = intf.f
	intf.u = self:getMem32(addr + 16)
	cylinder.height = intf.f
	intf.u = self:getMem32(addr + 20)
	cylinder.radius = intf.f

	return true
end

function EVM:getMemColTriangle(addr: uint32, triangle: *ColTriangle): boolean
	-- address is already confirmed to be aligned

	--[[ memory layout
		 0-3  type
		 4-7  point1.x
		 8-11 point1.y
		12-15 point1.z
		16-19 point2.x
		20-23 point2.y
		24-27 point2.z
		28-31 point3.x
		32-35 point3.y
		36-39 point3.z
	]]

	local intf: IntFloat

	if addr + 39 > MEMORY_MAX_ADDR then
		self.error = string.format("invalid word read address 0x%08X", addr)
		return false
	end

	intf.u = self:getMem32(addr + 4)
	triangle.point1.x = intf.f
	intf.u = self:getMem32(addr + 8)
	triangle.point1.y = intf.f
	intf.u = self:getMem32(addr + 12)
	triangle.point1.z = intf.f
	intf.u = self:getMem32(addr + 16)
	triangle.point2.x = intf.f
	intf.u = self:getMem32(addr + 20)
	triangle.point2.y = intf.f
	intf.u = self:getMem32(addr + 24)
	triangle.point2.z = intf.f
	intf.u = self:getMem32(addr + 28)
	triangle.point3.x = intf.f
	intf.u = self:getMem32(addr + 32)
	triangle.point3.y = intf.f
	intf.u = self:getMem32(addr + 36)
	triangle.point3.z = intf.f

	return true
end

function EVM:getGlobals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.globals[start + i])
	end
end

function EVM:setGlobals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.globals[end_index - i] = self:pop()
	end
end

function EVM:getLocals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.locals[self.cf.lbp + start + i])
	end
end

function EVM:setLocals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.locals[self.cf.lbp + (end_index - i)] = self:pop()
	end
end

function EVM:getArgs(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.args[self.ap + start + i])
	end
end

function EVM:setArgs(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.args[self.ap + (end_index - i)] = self:pop()
	end
end

function EVM:pushArgs(n: uint16): void
	for i = 0, < n do
		self.args[self.asp + i] = self.opstack[(self.osp - n) + i]
	end
	self.asp = self.asp + n
	self.osp = self.osp - n
end

function EVM:pushCallframe(argc: uint16): void
	self.callstack[self.csp] = self.cf
	self.csp = self.csp + 1
	
	self.cf.lbp = self.lsp
	self.cf.argc = argc

	self.ap = self.asp - argc
end

function EVM:popCallframe(): void
	self.lsp = self.cf.lbp
	self.asp = self.asp - self.cf.argc
	
	self.csp = self.csp - 1
	self.cf = self.callstack[self.csp]
	
	self.ap = self.asp - self.cf.argc
end

function EVM:getAddressOfGlobal(index: uint16): uint32
	return MEMORY_GLOBALS_START_ADDR + (index * 4)
end

function EVM:getAddressOfLocal(index: uint16): uint32
	return MEMORY_LOCALS_START_ADDR + ((self.cf.lbp + index) * 4)
end

function EVM:getAddressOfArg(index: uint16): uint32
	return MEMORY_ARGS_START_ADDR + ((self.ap + index) * 4)
end

function EVM:next8(): uint8
	local v: uint8 = self.bytecode[self.cf.pc]

	self.cf.pc = self.cf.pc + 1

	return v
end

function EVM:next16(): uint16
	local v: uint16 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]

	self.cf.pc = self.cf.pc + 2

	return v
end

function EVM:next32(): uint32
	local v: uint32 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]
	v = (v << 8) | self.bytecode[self.cf.pc + 2]
	v = (v << 8) | self.bytecode[self.cf.pc + 3]

	self.cf.pc = self.cf.pc + 4

	return v
end

function EVM:nextF(): float32
	local v: IntFloat = {u=self:next32()}

	return v.f
end

function EVM:clearMemCard(): void
	memory.zero(&self.memcard[0], MEMORY_MEMCARD_SIZE_BYTES)
end

function EVM:saveMemCard(): boolean
	local filepath: string
	## if ccinfo.is_windows then
		filepath = core.memcards_directory .. "\\" .. self.memcard_id
	## elseif ccinfo.is_linux then
		filepath = core.memcards_directory .. "/" .. self.memcard_id
	## end

	local fp: *C.FILE = C.fopen(filepath, "wb")
	if fp == nilptr then
		return false
	end

	C.fwrite(&self.memcard[0], 1, MEMORY_MEMCARD_SIZE_BYTES, fp)
	C.fclose(fp)
	return true
end

function EVM:loadMemCard(new_id: string): boolean
	local new_card_filepath: string
	## if ccinfo.is_windows then
		new_card_filepath = core.memcards_directory .. "\\" .. new_id
	## elseif ccinfo.is_linux then
		new_card_filepath = core.memcards_directory .. "/" .. new_id
	## end

	if self.memcard_id ~= "" then
		if self.memcard_id ~= new_id then
			self:saveMemCard()
		else
			self.memcard_initialized = true
			return true
		end
	end

	if fs.isfile(new_card_filepath) then
		local fp: *C.FILE = C.fopen(new_card_filepath, "rb")
		if fp == nilptr then
			self.memcard_id = ""
			self.memcard_initialized = false
			self.error = string.format("failed to open memcard `%s`", new_id)
			return false
		end

		C.fread(&self.memcard[0], 1, MEMORY_MEMCARD_SIZE_BYTES, fp)
		C.fclose(fp)
	else
		self:clearMemCard()
	end

	self.memcard_id = new_id
	self.memcard_initialized = true
	return true
end

function EVM:dumpBytecode(): void
	local prev_cf: CallFrame = self.cf
	self.cf = {}
	
	local index: uint16
	while self.cf.pc < self.bytecode_len do
		local op: uint8 = self:next8()

		io.printf("0x%04X: ", self.cf.pc - 1)
		
		switch op do
			case Opcode.GET_G then
				index = self:next16()
				io.printf("GET_G %d\n", index)
			case Opcode.GET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_GX %d %d\n", index, n)
			case Opcode.SET_G then
				index = self:next16()
				io.printf("SET_G %d\n", index)
			case Opcode.SET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_GX %d %d\n", index, n)
			case Opcode.NEW_L then
				io.printf("NEW_L %d\n", self:next16())
			case Opcode.DEL_L then
				io.printf("DEL_L %d\n", self:next16())
			case Opcode.GET_L then
				index = self:next16()
				io.printf("GET_L %d\n", index)
			case Opcode.GET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_LX %d %d\n", index, n)
			case Opcode.SET_L then
				index = self:next16()
				io.printf("SET_L %d\n", index)
			case Opcode.SET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_LX %d %d\n", index, n)
			case Opcode.GET_A then
				index = self:next16()
				io.printf("GET_A %d\n", index)
			case Opcode.GET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_AX %d %d\n", index, n)
			case Opcode.SET_A then
				index = self:next16()
				io.printf("SET_A %d\n", index)
			case Opcode.SET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_AX %d %d\n", index, n)
			case Opcode.GET_M then
				index = self:next16()
				io.printf("GET_M %d\n", index)
			case Opcode.GET_MX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_MX %d %d\n", index, n)
			case Opcode.SET_M then
				index = self:next16()
				io.printf("SET_M %d\n", index)
			case Opcode.SET_MX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_MX %d %d\n", index, n)
			case Opcode.GET_S then
				io.printf("GET_S\n")
			case Opcode.SET_S then
				io.printf("SET_S\n")
			case Opcode.ADDROF_G then
				index = self:next16()
				io.printf("ADDROF_G %d\n", index)
			case Opcode.ADDROF_L then
				index = self:next16()
				io.printf("ADDROF_L %d\n", index)
			case Opcode.ADDROF_A then
				index = self:next16()
				io.printf("ADDROF_A %d\n", index)
			case Opcode.PUSH_ZERO then
				io.printf("PUSH_ZERO\n")
			case Opcode.PUSH_ZEROF then
				io.printf("PUSH_ZEROF\n")
			case Opcode.PUSH_ZERO_N then
				index = self:next16()
				io.printf("PUSH_ZERO_N %d\n", index)
			case Opcode.PUSH_ONE then
				io.printf("PUSH_ONE\n")
			case Opcode.PUSH_ONEF then
				io.printf("PUSH_ONEF\n")
			case Opcode.PUSH_CHAR then
				io.printf("PUSH_CHAR %d\n", self:next8())
			case Opcode.PUSH_INT then
				io.printf("PUSH_INT %d\n", (@int32)(self:next32()))
			case Opcode.PUSH_FLOAT then
				io.printf("PUSH_FLOAT %f\n", self:nextF())
			case Opcode.PUSH_VEC2_ZERO then
				io.printf("PUSH_VEC2_ZERO\n")
			case Opcode.PUSH_VEC2_UP then
				io.printf("PUSH_VEC2_UP\n")
			case Opcode.PUSH_VEC2_DOWN then
				io.printf("PUSH_VEC2_DOWN\n")
			case Opcode.PUSH_VEC2_LEFT then
				io.printf("PUSH_VEC2_LEFT\n")
			case Opcode.PUSH_VEC2_RIGHT then
				io.printf("PUSH_VEC2_RIGHT\n")
			case Opcode.PUSH_VEC3_ZERO then
				io.printf("PUSH_VEC3_ZERO\n")
			case Opcode.PUSH_VEC3_UP then
				io.printf("PUSH_VEC3_UP\n")
			case Opcode.PUSH_VEC3_DOWN then
				io.printf("PUSH_VEC3_DOWN\n")
			case Opcode.PUSH_VEC3_LEFT then
				io.printf("PUSH_VEC3_LEFT\n")
			case Opcode.PUSH_VEC3_RIGHT then
				io.printf("PUSH_VEC3_RIGHT\n")
			case Opcode.PUSH_VEC3_FORWARD then
				io.printf("PUSH_VEC3_FORWARD\n")
			case Opcode.PUSH_VEC3_BACK then
				io.printf("PUSH_VEC3_BACK\n")
			case Opcode.PUSH_STRING then
				index = self:next16()
				local addr: uint32 = self:next32()
				io.printf("PUSH_STRING %d 0x%08X\n", index, addr)
			case Opcode.SAVE_FPTR then
				io.printf("SAVE_FPTR\n")
			case Opcode.DISCARD then
				io.printf("DISCARD %d\n", self:next16())
			case Opcode.NOT then
				io.printf("NOT\n")
			case Opcode.OR then
				io.printf("OR\n")
			case Opcode.XOR then
				io.printf("XOR\n")
			case Opcode.AND then
				io.printf("AND\n")
			case Opcode.LSHIFT then
				io.printf("LSHIFT\n")
			case Opcode.RSHIFT then
				io.printf("RSHIFT\n")
			case Opcode.ARSHIFT then
				io.printf("ARSHIFT\n")
			case Opcode.NEG then
				io.printf("NEG\n")
			case Opcode.NEGF then
				io.printf("NEGF\n")
			case Opcode.NEGV then
				io.printf("NEGV %d\n", self:next8())
			case Opcode.ADD then
				io.printf("ADD\n")
			case Opcode.ADDF then
				io.printf("ADDF\n")
			case Opcode.ADDV then
				io.printf("ADDV %d\n", self:next8())
			case Opcode.ADDP then
				io.printf("ADDP %d\n", self:next16())
			case Opcode.SUB then
				io.printf("SUB\n")
			case Opcode.SUBF then
				io.printf("SUBF\n")
			case Opcode.SUBV then
				io.printf("SUBV %d\n", self:next8())
			case Opcode.SUBP then
				io.printf("SUBP %d\n", self:next16())
			case Opcode.MUL then
				io.printf("MUL\n")
			case Opcode.MULF then
				io.printf("MULF\n")
			case Opcode.MULV then
				io.printf("MULV %d\n", self:next8())
			case Opcode.DIV then
				io.printf("DIV\n")
			case Opcode.DIVU then
				io.printf("DIVU\n")
			case Opcode.DIVF then
				io.printf("DIVF\n")
			case Opcode.DIVV then
				io.printf("DIVV %d\n", self:next8())
			case Opcode.MOD then
				io.printf("MOD\n")
			case Opcode.MODU then
				io.printf("MODU\n")
			case Opcode.MODF then
				io.printf("MODF\n")
			case Opcode.LNOT then
				io.printf("LNOT\n")
			case Opcode.LNOTP then
				io.printf("LNOTP\n")
			case Opcode.LNOTFP then
				io.printf("LNOTFP\n")
			case Opcode.EQ then
				io.printf("EQ\n")
			case Opcode.EQF then
				io.printf("EQF\n")
			case Opcode.EQV then
				io.printf("EQV %d\n", self:next8())
			case Opcode.EQS then
				io.printf("EQS\n")
			case Opcode.NE then
				io.printf("NE\n")
			case Opcode.NEF then
				io.printf("NEF\n")
			case Opcode.NEV then
				io.printf("NEV %d\n", self:next8())
			case Opcode.NES then
				io.printf("NES\n")
			case Opcode.LTI then
				io.printf("LTI\n")
			case Opcode.LTU then
				io.printf("LTU\n")
			case Opcode.LTF then
				io.printf("LTF\n")
			case Opcode.LTV then
				io.printf("LTV %d\n", self:next8())
			case Opcode.GTI then
				io.printf("GTI\n")
			case Opcode.GTU then
				io.printf("GTU\n")
			case Opcode.GTF then
				io.printf("GTF\n")
			case Opcode.GTV then
				io.printf("GTV %d\n", self:next8())
			case Opcode.LEI then
				io.printf("LEI\n")
			case Opcode.LEU then
				io.printf("LEU\n")
			case Opcode.LEF then
				io.printf("LEF\n")
			case Opcode.LEV then
				io.printf("LEV %d\n", self:next8())
			case Opcode.GEI then
				io.printf("GEI\n")
			case Opcode.GEU then
				io.printf("GEU\n")
			case Opcode.GEF then
				io.printf("GEF\n")
			case Opcode.GEV then
				io.printf("GEV %d\n", self:next8())
			case Opcode.JUMP then
				io.printf("JUMP 0x%04X\n", self:next16())
			case Opcode.JUMP_Z then
				io.printf("JUMP_Z 0x%04X\n", self:next16())
			case Opcode.JUMP_ZD then
				io.printf("JUMP_ZD 0x%04X\n", self:next16())
			case Opcode.JUMP_NZD then
				io.printf("JUMP_NZD 0x%04X\n", self:next16())
			case Opcode.JUMP_NULL then
				io.printf("JUMP_NULL 0x%04X\n", self:next16())
			case Opcode.JUMP_NULLD then
				io.printf("JUMP_NULLD 0x%04X\n", self:next16())
			case Opcode.JUMP_NNULLD then
				io.printf("JUMP_NNULLD 0x%04X\n", self:next16())
			case Opcode.JUMP_FPNULL then
				io.printf("JUMP_FPNULL 0x%04X\n", self:next16())
			case Opcode.JUMP_FPNULLD then
				io.printf("JUMP_FPNULLD 0x%04X\n", self:next16())
			case Opcode.JUMP_FPNNULLD then
				io.printf("JUMP_FPNNULLD 0x%04X\n", self:next16())
			case Opcode.CALL then
				index = self:next16()
				local argc: uint16 = self:next16()
				io.printf("CALL 0x%04X %d\n", index, argc)
			case Opcode.CALL_FPTR then
				index = self:next16()
				io.printf("CALL_FPTR %d\n", index)
			case Opcode.CALL_SAVED_FPTR then
				index = self:next16()
				io.printf("CALL_SAVED_FPTR %d\n", index)
			case Opcode.RETURN then
				io.printf("RETURN\n")
			case Opcode.VARGP then
				index = self:next16()
				io.printf("VARGP %d\n", index)
			case Opcode.FTOI then
				io.printf("FTOI\n")
			case Opcode.ITOF then
				io.printf("ITOF\n")
			case Opcode.ITOB then
				io.printf("ITOB\n")
			case Opcode.PTOB then
				io.printf("PTOB\n")
			case Opcode.FPTOB then
				io.printf("FPTOB\n")
			case Opcode.API then
				index = self:next16()
				local argc: uint16 = self:next16()
				io.printf("API 0x%04X %d\n", index, argc)
			else
				-- invalid opcode
				io.printf("!!! INVALID OPCODE !!!\n")
				self.cf = prev_cf
				return
		end
	end

	self.cf = prev_cf
end

function EVM:run(max_cycles: uint64): boolean
	local index: uint16
	local running: boolean = true

	while running do
		local op: uint8 = self:next8()

		switch op do
			case Opcode.GET_G then
				index = self:next16()
				self:push(self:getGlobal(index))
			case Opcode.GET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getGlobals(index, n)
			case Opcode.SET_G then
				index = self:next16()
				self:setGlobal(index, self:pop())
			case Opcode.SET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setGlobals(index, n)
			case Opcode.NEW_L then
				self.lsp = self.lsp + self:next16()

				if self.lsp > MEMORY_LOCALS_SIZE_ELEMENTS then
					self.error = string.format("local variable stack limit exceeded by %d word(s)", self.lsp - MEMORY_LOCALS_SIZE_ELEMENTS)
					return false
				end
			case Opcode.DEL_L then
				self.lsp = self.lsp - self:next16()
			case Opcode.GET_L then
				index = self:next16()
				self:push(self:getLocal(index))
			case Opcode.GET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getLocals(index, n)
			case Opcode.SET_L then
				index = self:next16()
				self:setLocal(index, self:pop())
			case Opcode.SET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setLocals(index, n)
			case Opcode.GET_A then
				index = self:next16()
				self:push(self:getArg(index))
			case Opcode.GET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getArgs(index, n)
			case Opcode.SET_A then
				index = self:next16()
				self:setArg(index, self:pop())
			case Opcode.SET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setArgs(index, n)
			case Opcode.GET_M then
				index = self:next16() -- offset in words
				local ptr: int32 = self:popI()
				local v: uint32

				if ptr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid word read address 0x%08X", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("misaligned word read address 0x%08X", ptr)
					return false
				end
				
				self:pushU(self:getMem32((@uint32)(ptr + (@int32)(index) * 4)))
			case Opcode.GET_MX then
				index = self:next16() -- offset in words
				local size: uint16 = self:next16()
				local ptr: int32 = self:popI()

				if ptr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid word read address 0x%08X", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("misaligned word read address 0x%08X", ptr)
					return false
				end

				local start: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				for i = 0, < size do
					local addr: uint32 = start + i * 4

					if addr > MEMORY_MAX_ADDR then
						self.error = string.format("invalid word read address 0x%08X", addr)
						return false
					end
					
					self:pushU(self:getMem32(addr))
				end
			case Opcode.SET_M then
				index = self:next16() -- offset in words
				local v: uint32 = self:popU()
				local ptr: int32 = self:popI()

				if ptr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid word write address 0x%08X", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("misaligned word write address 0x%08X", ptr)
					return false
				end
				
				if not self:setMem32((@uint32)(ptr + (@int32)(index) * 4), v) then
					self.error = string.format("cannot write word to ROM address 0x%08X", ptr)
					return false
				end
			case Opcode.SET_MX then
				-- stack:
				-- > osp
				-- struct (size words)
				-- ptr
				index = self:next16() -- offset in words
				local size: uint16 = self:next16()
				local ptr: int32 = self.opstack[(self.osp - 1) - size].i

				if ptr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid word read address 0x%08X", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("misaligned word read address 0x%08X", ptr)
					return false
				end

				local start_addr: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				local struct_start: uinteger = self.osp - size
				for i = 0, < size do
					local mem_addr: uint32 = start_addr + i * 4
					local struct_word_index: uint32 = struct_start + i

					if mem_addr > MEMORY_MAX_ADDR then
						self.error = string.format("invalid word read address 0x%08X", mem_addr)
						return false
					end
					
					self:setMem32(mem_addr, self.opstack[struct_word_index].u)
				end

				self.osp = (self.osp - 1) - size -- pop ptr and struct from stack
			case Opcode.GET_S then
				local i: uint32 = self:popU()
				local s: EVMString = self:popStr()

				local addr: uint32 = s.data + i

				if addr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid byte read address 0x%08X", addr)
					return false
				end
			
				self:pushU(self:getMem8(addr))
			case Opcode.SET_S then
				local c: uint8 = (@uint8)(self:popU() & 0xFF)
				local i: uint32 = self:popU()
				local s: EVMString = self:popStr()

				local addr: uint32 = s.data + i

				if addr > MEMORY_MAX_ADDR then
					self.error = string.format("invalid byte write address 0x%08X", addr)
					return false
				end
			
				if not self:setMem8(addr, c) then
					self.error = string.format("cannot write byte to ROM address 0x%08X", addr)
					return false
				end
			case Opcode.ADDROF_G then
				index = self:next16()
				self:pushU(self:getAddressOfGlobal(index))
			case Opcode.ADDROF_L then
				index = self:next16()
				self:pushU(self:getAddressOfLocal(index))
			case Opcode.ADDROF_A then
				index = self:next16()
				self:pushU(self:getAddressOfArg(index))
			case Opcode.PUSH_ZERO then
				self:pushU(0)
			case Opcode.PUSH_ZEROF then
				self:pushF(0.0)
			case Opcode.PUSH_ZERO_N then
				index = self:next16()
				for i = 0, < index do
					self:pushU(0)
				end
			case Opcode.PUSH_ONE then
				self:pushU(1)
			case Opcode.PUSH_ONEF then
				self:pushF(1.0)
			case Opcode.PUSH_CHAR then
				self:pushU((@uint32)(self:next8()))
			case Opcode.PUSH_INT then
				self:pushI((@int32)(self:next32()))
			case Opcode.PUSH_FLOAT then
				self:pushF(self:nextF())
			case Opcode.PUSH_VEC2_ZERO then
				self:pushV2({0.0, 0.0})
			case Opcode.PUSH_VEC2_ONE then
				self:pushV2({1.0, 1.0})
			case Opcode.PUSH_VEC2_UP then
				self:pushV2({0.0, -1.0})
			case Opcode.PUSH_VEC2_DOWN then
				self:pushV2({0.0, 1.0})
			case Opcode.PUSH_VEC2_LEFT then
				self:pushV2({-1.0, 0.0})
			case Opcode.PUSH_VEC2_RIGHT then
				self:pushV2({1.0, 0.0})
			case Opcode.PUSH_VEC3_ZERO then
				self:pushV3({0.0, 0.0, 0.0})
			case Opcode.PUSH_VEC3_ONE then
				self:pushV3({1.0, 1.0, 1.0})
			case Opcode.PUSH_VEC3_UP then
				self:pushV3({0.0, 1.0, 0.0})
			case Opcode.PUSH_VEC3_DOWN then
				self:pushV3({0.0, -1.0, 0.0})
			case Opcode.PUSH_VEC3_LEFT then
				self:pushV3({-1.0, 0.0, 0.0})
			case Opcode.PUSH_VEC3_RIGHT then
				self:pushV3({1.0, 0.0, 0.0})
			case Opcode.PUSH_VEC3_FORWARD then
				self:pushV3({0.0, 0.0, -1.0})
			case Opcode.PUSH_VEC3_BACK then
				self:pushV3({0.0, 0.0, 1.0})
			case Opcode.PUSH_STRING then
				index = self:next16()
				local addr: uint32 = self:next32()
				self:pushStr({index, addr})
			case Opcode.SAVE_FPTR then
				self.saved_fptr = self:popU()
			case Opcode.DISCARD then
				self:discard(self:next16())
			case Opcode.NOT then
				self:pushU(~self:popU())
			case Opcode.OR then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a | b)
			case Opcode.XOR then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a ~ b)
			case Opcode.AND then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a & b)
			case Opcode.LSHIFT then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a << b)
			case Opcode.RSHIFT then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a >> b)
			case Opcode.ARSHIFT then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a >>> b)
			case Opcode.NEG then
				self:pushI(-self:popI())
			case Opcode.NEGF then
				self:pushF(-self:popF())
			case Opcode.NEGV then
				index = (@uint16)(self:next8())
				if index == 0 then
					local v: rl.vector2 = self:popV2()
					self:pushV2({-v.x,-v.y})
				else
					local v: rl.vector3 = self:popV3()
					self:pushV3({-v.x,-v.y,-v.z})
				end
			case Opcode.ADD then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a + b)
			case Opcode.ADDF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a + b)
			case Opcode.ADDV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 + vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
							a.x + b.x,
							a.y + b.y})
					case 1 then -- vec3 + vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
							a.x + b.x,
							a.y + b.y,
							a.z + b.z})
				end
			case Opcode.ADDP then
				index = self:next16() -- size of type pointed to (in words)
				local v: int32 = self:popI()
				local p: int32 = self:popI()
				self:pushI(p + (v * (index * 4)))
			case Opcode.SUB then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a - b)
			case Opcode.SUBF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a - b)
			case Opcode.SUBV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 - vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
							a.x - b.x,
							a.y - b.y})
					case 1 then -- vec3 - vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
							a.x - b.x,
							a.y - b.y,
							a.z - b.z})
				end
			case Opcode.SUBP then
				index = self:next16() -- size of type pointed to (in words)
				local v: int32 = self:popI()
				local p: int32 = self:popI()
				self:pushI(p - (v * (index * 4)))
			case Opcode.MUL then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a * b)
			case Opcode.MULF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a * b)
			case Opcode.MULV then
				index = (@uint16)(self:next8())
				switch index do
					case MulVMode.INT_V2 then
						local a: rl.vector2 = self:popV2()
						local b: int32 = self:popI()
						self:pushV2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case MulVMode.INT_V3 then
						local a: rl.vector3 = self:popV3()
						local b: int32 = self:popI()
						self:pushV3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case MulVMode.FLOAT_V2 then
						local a: rl.vector2 = self:popV2()
						local b: float32 = self:popF()
						self:pushV2({
								a.x * b,
								a.y * b
							}
						)
					case MulVMode.FLOAT_V3 then
						local a: rl.vector3 = self:popV3()
						local b: float32 = self:popF()
						self:pushV3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case MulVMode.V2_INT then
						local b: int32 = self:popI()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case MulVMode.V2_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * b,
								a.y * b
							}
						)
					case MulVMode.V2_V2 then
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * b.x,
								a.y * b.y
							}
						)
					case MulVMode.V3_INT then
						local b: int32 = self:popI()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case MulVMode.V3_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case MulVMode.V3_V3 then
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * b.x,
								a.y * b.y,
								a.z * b.z
							}
						)
				end
			case Opcode.DIV then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a /// b)
			case Opcode.DIVU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a /// b)
			case Opcode.DIVF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a / b)
			case Opcode.DIVV then
				index = (@uint16)(self:next8())
				switch index do
					case DivVMode.V2_INT then
						local b: int32 = self:popI()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / (@float32)(b),
								a.y / (@float32)(b)
							}
						)
					case DivVMode.V2_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / b,
								a.y / b
							}
						)
					case DivVMode.V2_V2 then
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / b.x,
								a.y / b.y
							}
						)
					case DivVMode.V3_INT then
						local b: int32 = self:popI()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / (@float32)(b),
								a.y / (@float32)(b),
								a.z / (@float32)(b)
							}
						)
					case DivVMode.V3_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / b,
								a.y / b,
								a.z / b
							}
						)
					case DivVMode.V3_V3 then
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / b.x,
								a.y / b.y,
								a.z / b.z
							}
						)
				end
			case Opcode.MOD then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a %%% b)
			case Opcode.MODU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a %%% b)
			case Opcode.MODF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(math.fmod(a, b))
			case Opcode.LNOT then
				local v: uint32 = self:popU()
				self:pushU(v == 0 and 1 or 0)
			case Opcode.LNOTP then
				local v: uint32 = self:popU()
				self:pushU(v > MEMORY_MAX_ADDR and 1 or 0)
			case Opcode.LNOTFP then
				local v: uint32 = self:popU()
				local tag: uint32 = v & 0xF0000000
				local addr: uint32 = v & 0x0FFFFFFF
				local valid: boolean = false

				if addr <= 0xFFFF then
					if tag == 0x10000000 and self.funcmap:has(addr) then
						valid = true
					elseif tag == 0x20000000 and self.api_funcs[addr] ~= nilptr then
						valid = true
					end
				end

				self:pushU(not valid and 1 or 0)
			case Opcode.EQ then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a == b) and 1 or 0)
			case Opcode.EQF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a == b) and 1 or 0)
			case Opcode.EQV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushU((a.x == b.x and a.y == b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushU((a.x == b.x and a.y == b.y and a.z == b.z) and 1 or 0)
				end
			case Opcode.EQS then
				local b: EVMString = self:popStr()
				local a: EVMString = self:popStr()

				if a.len ~= b.len then
					-- strings have different lengths, cannot be equal
					self:pushU(0)
				else
					if a.data == b.data then
						-- strings have same length and data address, equal
						self:pushU(1)
					else
						-- strings have same length but different data addresses,
						-- we must compare characters
						local a_addr: uint32 = a.data
						local b_addr: uint32 = b.data
						local result: uint32 = 1

						for i = 0, < a.len do
							local ac: uint8
							local bc: uint8

							if a_addr > MEMORY_MAX_ADDR then
								self.error = string.format("invalid byte read address 0x%08X during string comparison", a_addr)
								return false
							end
						
							ac = self:getMem8(a_addr)

							if b_addr > MEMORY_MAX_ADDR then
								self.error = string.format("invalid byte read address 0x%08X during string comparison", b_addr)
								return false
							end
						
							bc = self:getMem8(b_addr)

							if ac ~= bc then
								result = 0
								break
							end

							a_addr = a_addr + 1
							b_addr = b_addr + 1
						end

						self:pushU(result)
					end
				end
			case Opcode.NE then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a ~= b) and 1 or 0)
			case Opcode.NEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a ~= b) and 1 or 0)
			case Opcode.NEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushU((a.x ~= b.x and a.y ~= b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushU((a.x ~= b.x and a.y ~= b.y and a.z ~= b.z) and 1 or 0)
				end
			case Opcode.NES then
				local b: EVMString = self:popStr()
				local a: EVMString = self:popStr()

				if a.len ~= b.len then
					-- strings have different lengths, cannot be equal
					self:pushU(1)
				else
					if a.data == b.data then
						-- strings have same length and data address, equal
						self:pushU(0)
					else
						-- strings have same length but different data addresses,
						-- we must compare characters
						local a_addr: uint32 = a.data
						local b_addr: uint32 = b.data
						local result: uint32 = 0

						for i = 0, < a.len do
							local ac: uint8
							local bc: uint8

							if a_addr > MEMORY_MAX_ADDR then
								self.error = string.format("invalid byte read address 0x%08X during string comparison", a_addr)
								return false
							end
						
							ac = self:getMem8(a_addr)

							if b_addr > MEMORY_MAX_ADDR then
								self.error = string.format("invalid byte read address 0x%08X during string comparison", b_addr)
								return false
							end
						
							bc = self:getMem8(b_addr)

							if ac ~= bc then
								result = 1
								break
							end

							a_addr = a_addr + 1
							b_addr = b_addr + 1
						end

						self:pushU(result)
					end
				end
			case Opcode.LTI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a < b) and 1 or 0)
			case Opcode.LTU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a < b) and 1 or 0)
			case Opcode.LTF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a < b) and 1 or 0)
			case Opcode.LTV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 < vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y < b.y) and 1 or 0)
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 < vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z < b.z) and 1 or 0)
							else
								self:pushU((a.y < b.y) and 1 or 0)
							end
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
				end
			case Opcode.GTI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a > b) and 1 or 0)
			case Opcode.GTU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a > b) and 1 or 0)
			case Opcode.GTF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a > b) and 1 or 0)
			case Opcode.GTV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 > vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y > b.y) and 1 or 0)
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 > vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z > b.z) and 1 or 0)
							else
								self:pushU((a.y > b.y) and 1 or 0)
							end
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
				end
			case Opcode.LEI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a <= b) and 1 or 0)
			case Opcode.LEU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a <= b) and 1 or 0)
			case Opcode.LEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a <= b) and 1 or 0)
			case Opcode.LEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 <= vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y <= b.y) and 1 or 0)
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 <= vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z <= b.z) and 1 or 0)
							else
								self:pushU((a.y < b.y) and 1 or 0)
							end
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
				end
			case Opcode.GEI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a >= b) and 1 or 0)
			case Opcode.GEU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a >= b) and 1 or 0)
			case Opcode.GEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a >= b) and 1 or 0)
			case Opcode.GEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 >= vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y >= b.y) and 1 or 0)
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 >= vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z >= b.z) and 1 or 0)
							else
								self:pushU((a.y > b.y) and 1 or 0)
							end
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
				end
			case Opcode.JUMP then
				index = self:next16()
				self.cf.pc = index
			case Opcode.JUMP_Z then
				index = self:next16()
				local v: uint32 = self:popU()

				if v == 0 then
					self.cf.pc = index
				end
			case Opcode.JUMP_ZD then
				-- jump if zero but only discard value if branch is not taken
				-- used by && operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u

				if v == 0 then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 0
				else
					self.osp = self.osp - 1
				end
			case Opcode.JUMP_NZD then
				-- jump if not zero but only discard value if branch is not taken
				-- used by || operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				
				if v ~= 0 then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 1
				else
					self.osp = self.osp - 1
				end
			case Opcode.JUMP_NULL then
				index = self:next16()
				local v: uint32 = self:popU()

				if v > MEMORY_MAX_ADDR then
					self.cf.pc = index
				end
			case Opcode.JUMP_NULLD then
				-- jump if null but only discard value if branch is not taken
				-- used by && operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u

				if v > MEMORY_MAX_ADDR then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 0
				else
					self.osp = self.osp - 1
				end
			case Opcode.JUMP_NNULLD then
				-- jump if not null but only discard value if branch is not taken
				-- used by || operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				
				if v <= MEMORY_MAX_ADDR then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 1
				else
					self.osp = self.osp - 1
				end
			case Opcode.JUMP_FPNULL then
				index = self:next16()
				local v: uint32 = self:popU()
				local tag: uint32 = v & 0xF0000000
				local addr: uint32 = v & 0x0FFFFFFF
				local valid: boolean = false

				if addr <= 0xFFFF then
					if tag == 0x10000000 and self.funcmap:has(addr) then
						valid = true
					elseif tag == 0x20000000 and self.api_funcs[addr] ~= nilptr then
						valid = true
					end
				end

				if not valid then
					self.cf.pc = index
				end
			case Opcode.JUMP_FPNULLD then
				-- jump if fptr null but only discard value if branch is not taken
				-- used by && operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				local tag: uint32 = v & 0xF0000000
				local addr: uint32 = v & 0x0FFFFFFF
				local valid: boolean = false

				if addr <= 0xFFFF then
					if tag == 0x10000000 and self.funcmap:has(addr) then
						valid = true
					elseif tag == 0x20000000 and self.api_funcs[addr] ~= nilptr then
						valid = true
					end
				end

				if not valid then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 0
				else
					self.osp = self.osp - 1
				end
			case Opcode.JUMP_FPNNULLD then
				-- jump if fptr not null but only discard value if branch is not taken
				-- used by || operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				local tag: uint32 = v & 0xF0000000
				local addr: uint32 = v & 0x0FFFFFFF
				local valid: boolean = false

				if addr <= 0xFFFF then
					if tag == 0x10000000 and self.funcmap:has(addr) then
						valid = true
					elseif tag == 0x20000000 and self.api_funcs[addr] ~= nilptr then
						valid = true
					end
				end

				if valid then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 1
				else
					self.osp = self.osp - 1
				end
			case Opcode.CALL then
				if self.csp >= EVM_CALLSTACK_SIZE then
					self.error = "callstack overflow"
					return false
				end

				index = self:next16()
				local argc: uint16 = self:next16()

				if self.asp + argc >= MEMORY_ARGS_SIZE_ELEMENTS then
					self.error = "argstack overflow"
					return false
				end

				self:pushArgs(argc)
				self:pushCallframe(argc)
				self.cf.pc = index
			case Opcode.CALL_FPTR then
				index = self:next16()
				local addr: uint32 = self:popU()

				if addr & 0x0FFFFFFF > 0xFFFF then
					self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
					return false
				end

				if addr & 0xF0000000 == 0x10000000 then
					if self.csp >= EVM_CALLSTACK_SIZE then
						self.error = "callstack overflow"
						return false
					end
	
					if self.asp + index >= MEMORY_ARGS_SIZE_ELEMENTS then
						self.error = "argstack overflow"
						return false
					end

					if not self.funcmap:has(addr & 0xFFFF) then
						self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
						return false
					end
	
					self:pushArgs(index)
					self:pushCallframe(index)
					self.cf.pc = addr & 0xFFFF
				elseif addr & 0xF0000000 == 0x20000000 then
					local func: APIFunction = self.api_funcs[addr & 0xFFFF]
					if func ~= nilptr then
						if self.csp >= EVM_CALLSTACK_SIZE then
							self.error = "callstack overflow"
							return false
						end

						if self.asp + index >= MEMORY_ARGS_SIZE_ELEMENTS then
							self.error = "argstack overflow"
							return false
						end

						self:pushArgs(index)
						self:pushCallframe(index)
						if not func(self) then
							self:popCallframe()
							return false
						end
						self:popCallframe()
					else
						self.error = string.format("attempt to call unregistered API function at index %d", addr & 0xFFFF)
						return false
					end
				else
					self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
					return false
				end
			case Opcode.CALL_SAVED_FPTR then
				index = self:next16()
				local addr: uint32 = self.saved_fptr

				if addr & 0x0FFFFFFF > 0xFFFF then
					self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
					return false
				end

				if addr & 0xF0000000 == 0x10000000 then
					if self.csp >= EVM_CALLSTACK_SIZE then
						self.error = "callstack overflow"
						return false
					end
	
					if self.asp + index >= MEMORY_ARGS_SIZE_ELEMENTS then
						self.error = "argstack overflow"
						return false
					end

					if not self.funcmap:has(addr & 0xFFFF) then
						self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
						return false
					end
	
					self:pushArgs(index)
					self:pushCallframe(index)
					self.cf.pc = addr & 0xFFFF
				elseif addr & 0xF0000000 == 0x20000000 then
					local func: APIFunction = self.api_funcs[addr & 0xFFFF]
					if func ~= nilptr then
						if self.csp >= EVM_CALLSTACK_SIZE then
							self.error = "callstack overflow"
							return false
						end

						if self.asp + index >= MEMORY_ARGS_SIZE_ELEMENTS then
							self.error = "argstack overflow"
							return false
						end

						self:pushArgs(index)
						self:pushCallframe(index)
						if not func(self) then
							self:popCallframe()
							return false
						end
						self:popCallframe()
					else
						self.error = string.format("attempt to call unregistered API function at index %d", addr & 0xFFFF)
						return false
					end
				else
					self.error = string.format("attempt to call invalid function pointer 0x%08X", addr)
					return false
				end
			case Opcode.RETURN then
				-- if returning from first function call, halt the program
				if self.csp == 1 then
					return true
				else
					self:popCallframe()
				end
			case Opcode.VARGP then
				index = self:next16()
				self.cf.vargp = self.ap + index
				self.cf.vargc = self.cf.argc - index
				self.cf.vargf = true
			case Opcode.FTOI then
				self:pushI((@int32)(self:popF()))
			case Opcode.ITOF then
				self:pushF((@float32)(self:popI()))
			case Opcode.ITOB then
				self:pushU(self:popU() ~= 0 and 1 or 0)
			case Opcode.PTOB then
				self:pushU(self:popU() <= MEMORY_MAX_ADDR and 1 or 0)
			case Opcode.FPTOB then
				local raw_addr: uint32 = self:popU()
				local tag: uint32 = raw_addr & 0xF0000000
				local addr: uint32 = raw_addr & 0x0FFFFFFF
				local result: uint32 = 0

				if addr <= 0xFFFF then
					if tag == 0x10000000 and self.funcmap:has(addr) then
						result = 1
					elseif tag == 0x20000000 and self.api_funcs[addr] ~= nilptr then
						result = 1
					end
				end

				self:pushU(result)
			case Opcode.API then
				index = self:next16()
				local argc: uint16 = self:next16()
				local func: APIFunction = self.api_funcs[index]
				if func ~= nilptr then
					if self.csp >= EVM_CALLSTACK_SIZE then
						self.error = "callstack overflow"
						return false
					end

					if self.asp + argc >= MEMORY_ARGS_SIZE_ELEMENTS then
						self.error = "argstack overflow"
						return false
					end

					self:pushArgs(argc)
					self:pushCallframe(argc)
					if not func(self) then
						self:popCallframe()
						return false
					end
					self:popCallframe()
				else
					self.error = string.format("attempt to call unregistered API function at index %d", index)
					return false
				end
			else
				-- invalid opcode
				self.error = string.format("attempt to execute invalid opcode %d", op)
				return false
		end

		if self.cf.pc >= self.bytecode_len then
			running = false
		end

		self.cycle_count = self.cycle_count + 1
		if self.cycle_count > max_cycles then
			self.error = string.format("vm cycle limit exceeded")
			return false
		end
	end
	
	return true
end

function EVM:callHook(hook: integer): boolean
	if self.hook_flags[hook] then
		self.current_hook = hook
		self.cf.pc = self.hook_addresses[hook]

		local argc: uint16 = 0
		if self.current_hook == Hook.UPDATE then
			self:pushF(rl.getFrameTime())
			self:pushArgs(1)
			argc = 1
		end

		self:pushCallframe(argc)
		local result: boolean = self:run(VM_MAX_CYCLES)
		self:popCallframe()

		if self.current_hook == Hook.DRAW then
			rlgl.drawRenderBatchActive()
		end

		return result
	end
	return true
end

function EVM:loadSourceFile(filename: string): boolean
	local sfs, err, errcode = filestream.open(filename)
	if not sfs:isopen() then
		self.error = string.format("failed to open script file: %s", err)
		return false
	end
	
	-- read file line-by-line into src_lines
	core:clearSrc()
	for data in sfs:lines() do
		-- get new line
		local line: sequence(uint8) = core:getNewLine()

		-- fill line
		line:clear() -- remove terminator
		for i = 1, <= #data do
			line:push(data[i])
		end
		line:push('\0'_u8)

		-- add line to src_lines
		core.src_lines:push(line)
	end

	core.current_line = core.src_lines[1]

	sfs:close()

	return true
end

local function isLittleEndian(): boolean
	local x: uint32 <volatile> = 0x01234567
	local p: *uint8 = (@*uint8)(&x)
	return $p == 0x67
end

local function byteSwapCartData(cart: *Cart): void
	local p: *[0]uint8 = (@*[0]uint8)(&cart.texbank)

	-- byteswap texbank
	for i: uint64 = 0, < MEMORY_TEXBANK_SIZE_ELEMENTS do
		local byte_index: uint64 = i * 4

		p[byte_index], p[byte_index + 3] = p[byte_index + 3], p[byte_index]
		p[byte_index + 1], p[byte_index + 2] = p[byte_index + 2], p[byte_index + 1]
	end

	-- byteswap objbank
	p = (@*[0]uint8)(&cart.objbank)
	for i: uint64 = 0, < MEMORY_OBJBANK_SIZE_ELEMENTS do
		local byte_index: uint64 = i * 4

		p[byte_index], p[byte_index + 3] = p[byte_index + 3], p[byte_index]
		p[byte_index + 1], p[byte_index + 2] = p[byte_index + 2], p[byte_index + 1]
	end

	-- byteswap wavbank
	p = (@*[0]uint8)(&cart.wavbank)
	for i: uint64 = 0, < MEMORY_WAVBANK_SIZE_ELEMENTS do
		local byte_index: uint64 = i * 2
		p[byte_index], p[byte_index + 1] = p[byte_index + 1], p[byte_index]
	end
end

function EVM:saveCart(filename: string): boolean
	local close_entry: boolean = false
	local err: cint
	local zip: *zip_t = zip_openwitherror(filename, 3, 'w'_u8, &err)
	if zip == nilptr then
		self.error = string.format("failed to save cart: (error code %d)", err)
		return false
	end
	defer
		if close_entry then
			zip_entry_close(zip)
		end

		zip_close(zip)
	end

	-- memcpy cart data to temp_cart
	memory.copy(&self.temp_cart.texbank, &self.cart.texbank, MEMORY_TEXBANK_SIZE_BYTES)
	memory.copy(&self.temp_cart.objbank, &self.cart.objbank, MEMORY_OBJMEM_SIZE_BYTES)
	memory.copy(&self.temp_cart.ompbank, &self.cart.ompbank, MEMORY_OMPBANK_SIZE_BYTES)
	memory.copy(&self.temp_cart.wmpbank, &self.cart.wmpbank, MEMORY_WMPBANK_SIZE_BYTES)
	memory.copy(&self.temp_cart.wavbank, &self.cart.wavbank, MEMORY_WAVBANK_SIZE_BYTES)
	memory.copy(&self.temp_cart.seqbank, &self.cart.seqbank, MEMORY_SEQBANK_SIZE_BYTES)
	memory.copy(&self.temp_cart.rom, &self.cart.rom, MEMORY_ROM_SIZE_BYTES)

	-- byteswap data if little endian
	if isLittleEndian() then
		byteSwapCartData(&self.temp_cart)
	end

	local size: isize
	
	-- write src.ec
	err = zip_entry_open(zip, "src.ec")
	if err == ZIP_OK then
		close_entry = true

		for i = 1, <= #core.src_lines do
			local line: sequence(uint8) = core.src_lines[i]

			-- get pointer to line data
			local ptr: *[0]uint8 = (@span(uint8))(line).data

			if i < #core.src_lines then
				line[#line] = '\n'_u8 -- replace terminator with newline
				err = zip_entry_write(zip, ptr, #line)
				line[#line] = '\0'_u8 -- restore terminator
			else
				err = zip_entry_write(zip, ptr, #line - 1) -- don't save the terminator to the file
			end
			if err ~= ZIP_OK then
				self.error = string.format("failed to save src.ec to cart: (error code %d)", err)
				return false
			end
		end

		zip_entry_close(zip)
		close_entry = false
	else
		self.error = string.format("failed to save src.ec to cart: (error code %d)", err)
		return false
	end

	-- write texbank.bin
	err = zip_entry_open(zip, "texbank.bin")
	if err == ZIP_OK then
		close_entry = true

		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.texbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_TEXBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save texbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save texbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write objbank.bin
	err = zip_entry_open(zip, "objbank.bin")
	if err == ZIP_OK then
		close_entry = true
		
		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.objbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_OBJBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save objbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save objbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write ompbank.bin
	err = zip_entry_open(zip, "ompbank.bin")
	if err == ZIP_OK then
		close_entry = true
		
		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.ompbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_OMPBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save ompbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save ompbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write wmpbank.bin
	err = zip_entry_open(zip, "wmpbank.bin")
	if err == ZIP_OK then
		close_entry = true
		
		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.wmpbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_WMPBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save wmpbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save wmpbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write wavbank.bin
	err = zip_entry_open(zip, "wavbank.bin")
	if err == ZIP_OK then
		close_entry = true
		
		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.wavbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_WAVBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save wavbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save wavbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write seqbank.bin
	err = zip_entry_open(zip, "seqbank.bin")
	if err == ZIP_OK then
		close_entry = true
		
		local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.temp_cart.seqbank[0])
		err = zip_entry_write(zip, bank_ptr, MEMORY_SEQBANK_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save seqbank.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save seqbank.bin to cart: (error code %d)", err)
		return false
	end

	-- write rom.bin
	err = zip_entry_open(zip, "rom.bin")
	if err == ZIP_OK then
		close_entry = true

		err = zip_entry_write(zip, &self.temp_cart.rom, MEMORY_ROM_SIZE_BYTES)
		if err == ZIP_OK then
			zip_entry_close(zip)
			close_entry = false
		else
			self.error = string.format("failed to save rom.bin to cart: (error code %d)", err)
			return false
		end
	else
		self.error = string.format("failed to save rom.bin to cart: (error code %d)", err)
		return false
	end

	return true
end

function EVM:loadCart(filename: string): boolean
	local close_entry: boolean = false
	local err: cint
	local zip: *zip_t = zip_openwitherror(filename, 0, 'r'_u8, &err)
	if zip == nilptr then
		self.error = string.format("failed to load cart: (error code %d)", err)
		return false
	end
	defer
		if close_entry then
			zip_entry_close(zip)
		end

		zip_close(zip)
	end

	local size: isize

	-- read src.ec
	core:clearSrc()
	err = zip_entry_open(zip, "src.ec")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load src.ec from cart: (error code %d)", err)
			return false
		elseif size > EVM_SRC_SIZE then
			self.error = string.format("failed to load src.ec from cart: 1 MiB limit exceeded.")
			return false
		else
			-- allocate text buffer if needed
			if core.text_buffer == nilptr then
				core.text_buffer = (@*[0]uint8)(gc_allocator:alloc(1024 * 1024, GCFlags.LEAF))
			end

			-- read all text into buffer
			local bytes_read: clong = zip_entry_noallocread(zip, core.text_buffer, size)
			zip_entry_close(zip)
			close_entry = false
			
			-- split text buffer into src lines
			local line: sequence(uint8) = core:getNewLine()
			line:clear() -- remove terminator
			local c: uint8 = '\0'_u8
			for i = 0, < bytes_read do
				c = core.text_buffer[i]

				if c == '\n'_u8 or c == '\0'_u8 then
					line:push('\0'_u8)
					core.src_lines:push(line)
					
					if i ~= bytes_read - 1 then
						line = core:getNewLine()
						line:clear() -- remove terminator
					end
				else
					line:push(c)
				end
			end

			if c ~= '\n'_u8 and c ~= '\0'_u8 then
				line:push('\0'_u8)
				core.src_lines:push(line)
			end

			core.current_line = core.src_lines[1]
		end
	end

	-- read texbank.bin
	local bank_ptr: *[0]uint8 = (@*[0]uint8)(&self.cart.texbank[0])
	err = zip_entry_open(zip, "texbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load texbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_TEXBANK_SIZE_BYTES then
			self.error = "failed to load texbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_TEXBANK_SIZE_BYTES)
	end

	-- read objbank.bin
	bank_ptr = (@*[0]uint8)(&self.cart.objbank[0])
	err = zip_entry_open(zip, "objbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load objbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_OBJBANK_SIZE_BYTES then
			self.error = "failed to load objbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_OBJBANK_SIZE_BYTES)
	end

	-- read ompbank.bin
	bank_ptr = (@*[0]uint8)(&self.cart.ompbank[0])
	err = zip_entry_open(zip, "ompbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)
		
		if size < 0 then
			self.error = string.format("failed to load ompbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_OMPBANK_SIZE_BYTES then
			self.error = "failed to load ompbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_OMPBANK_SIZE_BYTES)
	end

	-- read wmpbank.bin
	bank_ptr = (@*[0]uint8)(&self.cart.wmpbank[0])
	err = zip_entry_open(zip, "wmpbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load wmpbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_WMPBANK_SIZE_BYTES then
			self.error = "failed to load wmpbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_WMPBANK_SIZE_BYTES)
	end

	-- read wavbank.bin
	bank_ptr = (@*[0]uint8)(&self.cart.wavbank[0])
	err = zip_entry_open(zip, "wavbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load wavbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_WAVBANK_SIZE_BYTES then
			self.error = "failed to load wavbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_WAVBANK_SIZE_BYTES)
	end

	-- read seqbank.bin
	bank_ptr = (@*[0]uint8)(&self.cart.seqbank[0])
	err = zip_entry_open(zip, "seqbank.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load seqbank.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_SEQBANK_SIZE_BYTES then
			self.error = "failed to load seqbank.bin from cart: size limit exceeded"
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, bank_ptr, size)
			
			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear bank
		memory.set(bank_ptr, 0, MEMORY_SEQBANK_SIZE_BYTES)
	end

	-- read rom.bin
	err = zip_entry_open(zip, "rom.bin")
	if err == ZIP_OK then
		close_entry = true
		size = zip_entry_size(zip)

		if size < 0 then
			self.error = string.format("failed to load rom.bin from cart: (error code %d)", err)
			return false
		elseif size > MEMORY_ROM_SIZE_BYTES then
			self.error = string.format("failed to load rom.bin from cart: 16 MiB limit exceeded.")
			return false
		else
			local bytes_read: clong = zip_entry_noallocread(zip, &self.cart.rom, size)
			self.rom_len = bytes_read

			zip_entry_close(zip)
			close_entry = false
		end
	else
		-- clear ROM
		memory.set(&self.cart.rom, 0, MEMORY_ROM_SIZE_BYTES)
		self.rom_len = 0
	end

	if isLittleEndian() then
		byteSwapCartData(&self.cart)
	end

	return true
end

function EVM:heapAlloc(size: uint32): uint32
	if size == 0 or size > MEMORY_HEAP_SIZE_ELEMENTS then
		return MEMORY_NULL
	end
	
	-- get size aligned to 4 bytes
	size = (((size + 4) - 1) /// 4) * 4

	local current: *HeapBlock = self.heap_head
	while current ~= nilptr do
		if not current.used then
			if current.size > size then
				-- split block
				local new_block: *HeapBlock = new(@HeapBlock)
				new_block.next = current.next
				new_block.address = current.address + size
				new_block.size = current.size - size
				new_block.used = false

				current.size = size
				current.next = new_block
				current.used = true
				return current.address
			elseif current.size == size then
				current.used = true
				return current.address
			end
		end

		current = current.next
	end

	return MEMORY_NULL
end

function EVM:heapFree(ptr: uint32): void
	if ptr > MEMORY_MAX_ADDR then
		return
	end

	local prev: *HeapBlock = nilptr
	local current: *HeapBlock = self.heap_head
	while current ~= nilptr do
		local next: *HeapBlock = current.next

		if current.address == ptr then
			if current.used then
				current.used = false

				-- coalesce neighboring free heap blocks if needed
				local merge_flags: uinteger = 0
				if prev ~= nilptr and not prev.used then
					merge_flags = merge_flags | 0b10
				end

				if next ~= nilptr and not next.used then
					merge_flags = merge_flags | 0b01
				end

				switch merge_flags do
					case 0b01 then -- merge next only
						current.size = current.size + next.size
						current.next = next.next

						next.next = nilptr
					case 0b10 then -- merge prev only
						prev.size = prev.size + current.size
						prev.next = current.next

						current.next = nilptr
					case 0b11 then -- merge both prev and next
						prev.size = prev.size + current.size + next.size
						prev.next = next.next

						current.next = nilptr
						next.next = nilptr
				end
			end

			return
		end

		prev = current
		current = current.next
	end
end

function EVM:heapRealloc(ptr: uint32, size: uint32): uint32
	local new_ptr: uint32 = self:heapAlloc(size)
	if new_ptr == MEMORY_NULL then
		return MEMORY_NULL
	elseif ptr == MEMORY_NULL then
		return new_ptr
	else
		-- get old block
		local old_block: *HeapBlock = self.heap_head
		while old_block ~= nilptr do
			if old_block.address == ptr then
				break
			end
			old_block = old_block.next
		end

		if old_block ~= nilptr then
			local copy_size: uint32 = size
			if size > old_block.size then
				copy_size = old_block.size
			end

			memory.copy(&self.heap[new_ptr], &self.heap[old_block.address], copy_size)
			self:heapFree(ptr)
		end

		return new_ptr
	end
end

function EVM:printHeapBlocks(): void
	local current: *HeapBlock = self.heap_head
	local i: integer = 0
	while current ~= nilptr do
		io.printf("block %d: next: %p, addr: 0x%08X, size: %d, used: %s\n", i, current.next, current.address, current.size, current.used and "true" or "false")
		current = current.next
		i = i + 1
	end
end

function EVM:__gc(): void
	self.soundchip:cleanup()
	self.gpu:cleanup()
end

global function newVM(): *EVM
	local vm: *EVM = new(@EVM)

	vm:registerBuiltins()
	vm:registerAPI()
	
	vm.gpu:init(&vm.sysmem, &vm.cart.texbank, &vm.cart.objbank, &vm.cart.ompbank)
	vm.soundchip:init(&vm.sysmem, &vm.cart.wavbank, &vm.cart.seqbank, &vm.cart.wmpbank)

	vm.heap_head = new(@HeapBlock)

	vm:resetVM(false)

	vm.memcard_id = ""

	return vm
end
