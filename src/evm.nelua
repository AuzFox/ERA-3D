require("C.stdio")
require("api")

function e3d.EVM:getGlobal(i: uint16): e3d.EVMValue
	return self.globals[i]
end

function e3d.EVM:getGlobalI(i: uint16): int32
	return self.globals[i].i
end

function e3d.EVM:getGlobalU(i: uint16): uint32
	return self.globals[i].u
end

function e3d.EVM:getGlobalF(i: uint16): float32
	return self.globals[i].f
end

function e3d.EVM:getGlobalV2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	
	return v
end

function e3d.EVM:getGlobalV3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	v.z = self.globals[i + 2].f
	
	return v
end

function e3d.EVM:setGlobal(i: uint16, val: e3d.EVMValue): void
	self.globals[i] = val
end

function e3d.EVM:setGlobalI(i: uint16, val: int32): void
	self.globals[i].i = val
end

function e3d.EVM:setGlobalU(i: uint16, val: uint32): void
	self.globals[i].u = val
end

function e3d.EVM:setGlobalF(i: uint16, val: float32): void
	self.globals[i].f = val
end

function e3d.EVM:setGlobalV2(i: uint16, val: rl.vector2): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
end

function e3d.EVM:setGlobalV3(i: uint16, val: rl.vector3): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
	self.globals[i + 2].f = val.z
end

function e3d.EVM:getLocal(i: uint16): e3d.EVMValue
	return self.locals[self.cf.lbp + i]
end

function e3d.EVM:setLocal(i: uint16, val: e3d.EVMValue): void
	self.locals[self.cf.lbp + i] = val
end

function e3d.EVM:getArg(i: uint16): e3d.EVMValue
	return self.args[self.ap + i]
end

function e3d.EVM:getArgI(i: uint16): int32
	return self.args[self.ap + i].i
end

function e3d.EVM:getArgU(i: uint16): uint32
	return self.args[self.ap + i].u
end

function e3d.EVM:getArgF(i: uint16): float32
	return self.args[self.ap + i].f
end

function e3d.EVM:getArgV2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f

	return v
end

function e3d.EVM:getArgV3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f
	v.z = self.args[self.ap + i + 2].f

	return v
end

function e3d.EVM:getArgStr(i: uint16): e3d.EVMString
	local s: e3d.EVMString

	s.len = self.args[self.ap + i].u
	s.data = self.args[self.ap + i + 1].u

	return s
end

function e3d.EVM:setArg(i: uint16, val: e3d.EVMValue): void
	self.args[self.ap + i] = val
end

function e3d.EVM:setArgI(i: uint16, val: int32): void
	self.args[self.ap + i].i = val
end

function e3d.EVM:setArgU(i: uint16, val: uint32): void
	self.args[self.ap + i].u = val
end

function e3d.EVM:setArgF(i: uint16, val: float32): void
	self.args[self.ap + i].f = val
end

function e3d.EVM:setArgV2(i: uint16, val: rl.vector2): void
	self.args[self.ap + i    ].f = val.x
	self.args[self.ap + i + 1].f = val.y
end

function e3d.EVM:setArgV3(i: uint16, val: rl.vector3): void
	self.args[self.ap + i    ].f = val.x
	self.args[self.ap + i + 1].f = val.y
	self.args[self.ap + i + 2].f = val.z
end

function e3d.EVM:setArgStr(i: uint16, val: e3d.EVMString): void
	self.args[self.ap + i    ].u = val.len
	self.args[self.ap + i + 1].u = val.data
end

function e3d.EVM:push(val: e3d.EVMValue): void
	self.opstack[self.osp] = val
	self.osp = self.osp + 1
end

function e3d.EVM:pushI(val: int32): void
	self.opstack[self.osp] = {i=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushU(val: uint32): void
	self.opstack[self.osp] = {u=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushF(val: float32): void
	self.opstack[self.osp] = {f=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushV2(val: rl.vector2): void
	self.opstack[self.osp    ] = {f=val.x}
	self.opstack[self.osp + 1] = {f=val.y}
	self.osp = self.osp + 2
end

function e3d.EVM:pushV3(val: rl.vector3): void
	self.opstack[self.osp    ] = {f=val.x}
	self.opstack[self.osp + 1] = {f=val.y}
	self.opstack[self.osp + 2] = {f=val.z}
	self.osp = self.osp + 3
end

function e3d.EVM:pushStr(val: e3d.EVMString): void
	self.opstack[self.osp    ] = {u=val.len}
	self.opstack[self.osp + 1] = {u=val.data}
	self.osp = self.osp + 2
end

function e3d.EVM:pop(): e3d.EVMValue
	self.osp = self.osp - 1
	return self.opstack[self.osp]
end

function e3d.EVM:popI(): int32
	self.osp = self.osp - 1
	return self.opstack[self.osp].i
end

function e3d.EVM:popU(): uint32
	self.osp = self.osp - 1
	return self.opstack[self.osp].u
end

function e3d.EVM:popF(): float32
	self.osp = self.osp - 1
	return self.opstack[self.osp].f
end

function e3d.EVM:popV2(): rl.vector2
	self.osp = self.osp - 2
	return {
		self.opstack[self.osp    ].f,
		self.opstack[self.osp + 1].f
	}
end

function e3d.EVM:popV3(): rl.vector3
	self.osp = self.osp - 3
	return {
		self.opstack[self.osp    ].f,
		self.opstack[self.osp + 1].f,
		self.opstack[self.osp + 2].f
	}
end

function e3d.EVM:popStr(): e3d.EVMString
	self.osp = self.osp - 2
	return {
		self.opstack[self.osp    ].u,
		self.opstack[self.osp + 1].u
	}
end

function e3d.EVM:resetVM(reset_all: boolean): void
	-- TODO: free all vm program memory, clear ram?

	self.cf = {}
	self.lsp = 0
	self.asp = 0
	self.ap = 0
	self.osp = 0
	self.csp = 0
	self.init_time = rl.getTime()

	if reset_all then
		self.soundchip:resetSoundchip()
		self.gpu:resetGPU()
	end

	math.randomseed()
end

function e3d.EVM:discard(n: uint16): void
	self.osp = self.osp - n
end

local function getIntFloatBtye(array: *[0]IntFloat, segment_start: uint32, addr: uint32): uint8
	return (@uint8)((array[(addr - segment_start) /// 4].u >> (8 * (3 - (addr & 0b11)))) & 0xFF)
end

local function setIntFloatByte(array: *[0]IntFloat, segment_start: uint32, addr: uint32, val: uint8): void
	local shift: uinteger = 8 * (3 - (addr & 0b11))
	local v: *IntFloat = &array[(addr - segment_start) /// 4]
	v.u = (v.u & (0xFF000000 >> shift)) | (((@uint32)(val) << 24) >> shift)
end

local function getEVMValueBtye(array: *[0]e3d.EVMValue, segment_start: uint32, addr: uint32): uint8
	return (@uint8)((array[(addr - segment_start) /// 4].u >> (8 * (3 - (addr & 0b11)))) & 0xFF)
end

local function setEVMValueByte(array: *[0]e3d.EVMValue, segment_start: uint32, addr: uint32, val: uint8): void
	local shift: uinteger = 8 * (3 - (addr & 0b11))
	local v: *e3d.EVMValue = &array[(addr - segment_start) /// 4]
	v.u = (v.u & (0xFF000000 >> shift)) | (((@uint32)(val) << 24) >> shift)
end

-- get one byte from the vm memory, does not do bounds or alignment checking!
function e3d.EVM:getMem8(addr: uint32): uint8
	if addr <= e3d.HEAP_MAX_ADDR then
		return self.heap[addr]
	elseif addr <= e3d.TMEM_MAX_ADDR then
		local col: *rl.color = &self.gpu.tmem[(addr - e3d.TMEM_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				return (@uint8)(col.r)
			case 1 then
				return (@uint8)(col.g)
			case 2 then
				return (@uint8)(col.b)
			case 3 then
				return (@uint8)(col.a)
			else
				-- should not happen
				return 0
		end
	elseif addr <= e3d.OMEM_MAX_ADDR then
		return getIntFloatBtye(&self.gpu.omem, e3d.OMEM_START_ADDR, addr)
	elseif addr <= e3d.AMEM_MAX_ADDR then
		local frame: uint16 = self.soundchip.amem[(addr - e3d.AMEM_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= e3d.UNUSED_MAX_ADDR then
		return 0
	elseif addr <= e3d.WMEM_MAX_ADDR then
		local frame: uint16 = self.soundchip.wmem[(addr - e3d.WMEM_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= e3d.SMEM_MAX_ADDR then
		return self.soundchip.smem[addr - e3d.SMEM_START_ADDR]
	elseif addr <= e3d.GLOBALS_MAX_ADDR then
		return getEVMValueBtye(&self.globals, e3d.GLOBALS_START_ADDR, addr)
	elseif addr <= e3d.LOCALS_MAX_ADDR then
		return getEVMValueBtye(&self.locals, e3d.LOCALS_START_ADDR, addr)
	elseif addr <= e3d.ARGS_MAX_ADDR then
		return getEVMValueBtye(&self.args, e3d.ARGS_START_ADDR, addr)
	elseif addr <= e3d.TBANK_MAX_ADDR then
		local col: *rl.color = &self.cart.tbank[(addr - e3d.TBANK_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				return (@uint8)(col.r)
			case 1 then
				return (@uint8)(col.g)
			case 2 then
				return (@uint8)(col.b)
			case 3 then
				return (@uint8)(col.a)
			else
				-- should not happen
				return 0
		end
	elseif addr <= e3d.OBANK_MAX_ADDR then
		return getEVMValueBtye(&self.cart.obank, e3d.OBANK_START_ADDR, addr)
	elseif addr <= e3d.WBANK_MAX_ADDR then
		local frame: uint16 = self.cart.wbank[(addr - e3d.WBANK_START_ADDR) /// 2]
		return (@uint8)((frame >> (8 * (addr & 1))) & 0xFF)
	elseif addr <= e3d.SBANK_MAX_ADDR then
		return self.cart.sbank[addr - e3d.SBANK_START_ADDR]
	elseif addr <= e3d.ROM_MAX_ADDR then
		return self.cart.rom[addr - e3d.ROM_START_ADDR]
	elseif addr <= e3d.MEMCARD_MAX_ADDR then
		return 0
	else
		return 0
	end
end

-- set one byte in the vm memory, does not do bounds or alignment checking!
function e3d.EVM:setMem8(addr: uint32, val: uint8): boolean
	if addr <= e3d.HEAP_MAX_ADDR then
		self.heap[addr] = val
	elseif addr <= e3d.TMEM_MAX_ADDR then
		local col: *rl.color = &self.gpu.tmem[(addr - e3d.TMEM_START_ADDR) /// 4]

		switch addr & 0b11 do
			case 0 then
				col.r = (@cuchar)(val)
			case 1 then
				col.g = (@cuchar)(val)
			case 2 then
				col.b = (@cuchar)(val)
			case 3 then
				col.a = (@cuchar)(val)
		end
		self.gpu.update_tex = true
	elseif addr <= e3d.OMEM_MAX_ADDR then
		setIntFloatByte(&self.gpu.omem, e3d.OMEM_START_ADDR, addr, val)
	elseif addr <= e3d.AMEM_MAX_ADDR then
		local frame: *uint16 = (@*uint16)(&self.soundchip.amem[(addr - e3d.AMEM_START_ADDR) /// 2])
		local shift: uinteger = 8 * (addr & 1)
		$frame = ($frame & (0xFF00 >> shift)) | (val << 8) >> shift
	elseif addr <= e3d.UNUSED_MAX_ADDR then
		return true
	elseif addr <= e3d.WMEM_MAX_ADDR then
		local frame: *uint16 = (@*uint16)(&self.soundchip.wmem[(addr - e3d.WMEM_START_ADDR) /// 2])
		local shift: uinteger = 8 * (addr & 1)
		$frame = ($frame & (0xFF00 >> shift)) | (val << 8) >> shift
	elseif addr <= e3d.SMEM_MAX_ADDR then
		self.soundchip.smem[addr - e3d.SMEM_START_ADDR] = val
	elseif addr <= e3d.GLOBALS_MAX_ADDR then
		setEVMValueByte(&self.globals, e3d.GLOBALS_START_ADDR, addr, val)
	elseif addr <= e3d.LOCALS_MAX_ADDR then
		setEVMValueByte(&self.locals, e3d.LOCALS_START_ADDR, addr, val)
	elseif addr <= e3d.ARGS_MAX_ADDR then
		setEVMValueByte(&self.args, e3d.ARGS_START_ADDR, addr, val)
	elseif addr <= e3d.TBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.OBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.WBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.SBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.ROM_MAX_ADDR then
		return false
	elseif addr <= e3d.MEMCARD_MAX_ADDR then
		return true
	else
		return false
	end

	return true
end

-- get one word from the vm memory, does not do bounds or alignment checking!
function e3d.EVM:getMem32(addr: uint32): uint32
	if addr <= e3d.HEAP_MAX_ADDR then
		return ((@uint32)(self.heap[addr]) << 24) | ((@uint32)(self.heap[addr + 1]) << 16) | ((@uint32)(self.heap[addr + 2]) << 8) | (@uint32)(self.heap[addr + 3])
	elseif addr <= e3d.TMEM_MAX_ADDR then
		local col: rl.color = self.gpu.tmem[(addr - e3d.TMEM_START_ADDR) /// 4]
		return (((@uint32)(col.r) << 24) | ((@uint32)(col.g) << 16) | ((@uint32)(col.b) << 8) | (@uint32)(col.a))
	elseif addr <= e3d.OMEM_MAX_ADDR then
		return self.gpu.omem[(addr - e3d.OMEM_START_ADDR) /// 4].u
	elseif addr <= e3d.AMEM_MAX_ADDR then
		local index: uinteger = (addr - e3d.AMEM_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.soundchip.amem[index])
		local frame1: uint32 = (@uint32)(self.soundchip.amem[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= e3d.UNUSED_MAX_ADDR then
		return 0
	elseif addr <= e3d.WMEM_MAX_ADDR then
		local index: uinteger = (addr - e3d.WMEM_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.soundchip.wmem[index])
		local frame1: uint32 = (@uint32)(self.soundchip.wmem[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= e3d.SMEM_MAX_ADDR then
		addr = addr - e3d.SMEM_START_ADDR
		return ((@uint32)(self.soundchip.smem[addr]) << 24) | ((@uint32)(self.soundchip.smem[addr + 1]) << 16) | ((@uint32)(self.soundchip.smem[addr + 2]) << 8) | (@uint32)(self.soundchip.smem[addr + 3])
	elseif addr <= e3d.GLOBALS_MAX_ADDR then
		return self.globals[(addr - e3d.GLOBALS_START_ADDR) /// 4].u
	elseif addr <= e3d.LOCALS_MAX_ADDR then
		return self.locals[(addr - e3d.LOCALS_START_ADDR) /// 4].u
	elseif addr <= e3d.ARGS_MAX_ADDR then
		return self.args[(addr - e3d.ARGS_START_ADDR) /// 4].u
	elseif addr <= e3d.TBANK_MAX_ADDR then
		local col: rl.color = self.cart.tbank[(addr - e3d.TBANK_START_ADDR) /// 4]
		return (((@uint32)(col.r) << 24) | ((@uint32)(col.g) << 16) | ((@uint32)(col.b) << 8) | (@uint32)(col.a))
	elseif addr <= e3d.OBANK_MAX_ADDR then
		return self.cart.obank[(addr - e3d.OBANK_START_ADDR) /// 4].u
	elseif addr <= e3d.WBANK_MAX_ADDR then
		local index: uinteger = (addr - e3d.WBANK_START_ADDR) /// 2
		local frame0: uint32 = (@uint32)(self.cart.wbank[index])
		local frame1: uint32 = (@uint32)(self.cart.wbank[index + 1])
		return (frame0 << 16) | frame1
	elseif addr <= e3d.SBANK_MAX_ADDR then
		addr = addr - e3d.SBANK_START_ADDR
		return ((@uint32)(self.cart.sbank[addr]) << 24) | ((@uint32)(self.cart.sbank[addr + 1]) << 16) | ((@uint32)(self.cart.sbank[addr + 2]) << 8) | (@uint32)(self.cart.sbank[addr + 3])
	elseif addr <= e3d.ROM_MAX_ADDR then
		addr = addr - e3d.ROM_START_ADDR
		return ((@uint32)(self.cart.rom[addr]) << 24) | ((@uint32)(self.cart.rom[addr + 1]) << 16) | ((@uint32)(self.cart.rom[addr + 2]) << 8) | (@uint32)(self.cart.rom[addr + 3])
	elseif addr <= e3d.MEMCARD_MAX_ADDR then
		return 0
	else
		return 0
	end
end

-- set one word in the vm memory, does not do bounds or alignment checking!
function e3d.EVM:setMem32(addr: uint32, val: uint32): boolean
	if addr <= e3d.HEAP_MAX_ADDR then
		self.heap[addr] = val >> 24
		self.heap[addr + 1] = (val & 0xFF0000) >> 16
		self.heap[addr + 2] = (val & 0x00FF00) >> 8
		self.heap[addr + 3] = val & 0xFF
	elseif addr <= e3d.TMEM_MAX_ADDR then
		local col: rl.color
		addr = (addr - e3d.TMEM_START_ADDR) /// 4
		col.r = val >> 24
		col.g = (val & 0xFF0000) >> 16
		col.b = (val & 0x00FF00) >> 8
		col.a = val & 0xFF
		self.gpu.tmem[addr] = col
		self.gpu.update_tex = true
	elseif addr <= e3d.OMEM_MAX_ADDR then
		self.gpu.omem[(addr - e3d.OMEM_START_ADDR) /// 4].u = val
	elseif addr <= e3d.AMEM_MAX_ADDR then
		local frame0: uint16 = val >> 16
		local frame1: uint16 = val & 0xFFFF
		addr = (addr - e3d.AMEM_START_ADDR) /// 2
		self.soundchip.amem[addr] = frame0
		self.soundchip.amem[addr + 1] = frame1
	elseif addr <= e3d.UNUSED_MAX_ADDR then
		return true
	elseif addr <= e3d.WMEM_MAX_ADDR then
		local frame0: uint16 = val >> 16
		local frame1: uint16 = val & 0xFFFF
		addr = (addr - e3d.WMEM_START_ADDR) /// 2
		self.soundchip.wmem[addr] = frame0
		self.soundchip.wmem[addr + 1] = frame1
	elseif addr <= e3d.SMEM_MAX_ADDR then
		addr = addr - e3d.SMEM_START_ADDR
		self.soundchip.smem[addr] = val >> 24
		self.soundchip.smem[addr + 1] = (val & 0xFF0000) >> 16
		self.soundchip.smem[addr + 2] = (val & 0x00FF00) >> 8
		self.soundchip.smem[addr + 3] = val & 0xFF
	elseif addr <= e3d.GLOBALS_MAX_ADDR then
		self.globals[(addr - e3d.GLOBALS_START_ADDR) /// 4].u = val
	elseif addr <= e3d.LOCALS_MAX_ADDR then
		self.locals[(addr - e3d.LOCALS_START_ADDR) /// 4].u = val
	elseif addr <= e3d.ARGS_MAX_ADDR then
		self.args[(addr - e3d.ARGS_START_ADDR) /// 4].u = val
	elseif addr <= e3d.TBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.OBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.WBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.SBANK_MAX_ADDR then
		return false
	elseif addr <= e3d.ROM_MAX_ADDR then
		return false
	elseif addr <= e3d.MEMCARD_MAX_ADDR then
		return true
	else
		return false
	end

	return true
end

function e3d.EVM:getGlobals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.globals[start + i])
	end
end

function e3d.EVM:setGlobals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.globals[end_index - i] = self:pop()
	end
end

function e3d.EVM:getLocals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.locals[self.cf.lbp + start + i])
	end
end

function e3d.EVM:setLocals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.locals[self.cf.lbp + (end_index - i)] = self:pop()
	end
end

function e3d.EVM:getArgs(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.args[self.ap + start + i])
	end
end

function e3d.EVM:setArgs(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.args[self.ap + (end_index - i)] = self:pop()
	end
end

function e3d.EVM:pushArgs(n: uint16): void
	for i = 0, < n do
		self.args[self.asp + i] = self.opstack[(self.osp - n) + i]
	end
	self.asp = self.asp + n
	self.osp = self.osp - n
end

function e3d.EVM:pushCallframe(argc: uint16): void
	self.callstack[self.csp] = self.cf
	self.csp = self.csp + 1
	
	self.cf.lbp = self.lsp
	self.cf.argc = argc

	self.ap = self.asp - argc
end

function e3d.EVM:popCallframe(): void
	self.lsp = self.cf.lbp
	self.asp = self.asp - self.cf.argc
	
	self.csp = self.csp - 1
	self.cf = self.callstack[self.csp]
	
	self.ap = self.asp - self.cf.argc
end

function e3d.EVM:getAddressOfGlobal(index: uint16): uint32
	return e3d.GLOBALS_START_ADDR + (index * 4)
end

function e3d.EVM:getAddressOfLocal(index: uint16): uint32
	return e3d.LOCALS_START_ADDR + ((self.cf.lbp + index) * 4)
end

function e3d.EVM:getAddressOfArg(index: uint16): uint32
	return e3d.ARGS_START_ADDR + ((self.ap + index) * 4)
end

function e3d.EVM:next8(): uint8
	local v: uint8 = self.bytecode[self.cf.pc]

	self.cf.pc = self.cf.pc + 1

	return v
end

function e3d.EVM:next16(): uint16
	local v: uint16 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]

	self.cf.pc = self.cf.pc + 2

	return v
end

function e3d.EVM:next32(): uint32
	local v: uint32 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]
	v = (v << 8) | self.bytecode[self.cf.pc + 2]
	v = (v << 8) | self.bytecode[self.cf.pc + 3]

	self.cf.pc = self.cf.pc + 4

	return v
end

function e3d.EVM:nextF(): float32
	local v: e3d.EVMValue = {u=self:next32()}

	return v.f
end

function e3d.EVM:dumpBytecode(): void
	local prev_cf: e3d.CallFrame = self.cf
	self.cf = {}
	
	local index: uint16
	while self.cf.pc < self.bytecode_len do
		local op: uint8 = self:next8()

		io.printf("0x%04X: ", self.cf.pc - 1)
		
		switch op do
			case e3d.Opcode.GET_G then
				index = self:next16()
				io.printf("GET_G %d\n", index)
			case e3d.Opcode.GET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_GX %d %d\n", index, n)
			case e3d.Opcode.SET_G then
				index = self:next16()
				io.printf("SET_G %d\n", index)
			case e3d.Opcode.SET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_GX %d %d\n", index, n)
			case e3d.Opcode.NEW_L then
				io.printf("NEW_L %d\n", self:next16())
			case e3d.Opcode.DEL_L then
				io.printf("DEL_L %d\n", self:next16())
			case e3d.Opcode.GET_L then
				index = self:next16()
				io.printf("GET_L %d\n", index)
			case e3d.Opcode.GET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_LX %d %d\n", index, n)
			case e3d.Opcode.SET_L then
				index = self:next16()
				io.printf("SET_L %d\n", index)
			case e3d.Opcode.SET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_LX %d %d\n", index, n)
			case e3d.Opcode.GET_A then
				index = self:next16()
				io.printf("GET_A %d\n", index)
			case e3d.Opcode.GET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_AX %d %d\n", index, n)
			case e3d.Opcode.SET_A then
				index = self:next16()
				io.printf("SET_A %d\n", index)
			case e3d.Opcode.SET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_AX %d %d\n", index, n)
			case e3d.Opcode.GET_M then
				index = self:next16()
				io.printf("GET_M %d\n", index)
			case e3d.Opcode.GET_MX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("GET_MX %d %d\n", index, n)
			case e3d.Opcode.SET_M then
				index = self:next16()
				io.printf("SET_M %d\n", index)
			case e3d.Opcode.SET_MX then
				index = self:next16()
				local n: uint16 = self:next16()
				io.printf("SET_MX %d %d\n", index, n)
			case e3d.Opcode.GET_S then
				io.printf("GET_S\n")
			case e3d.Opcode.SET_S then
				io.printf("SET_S\n")
			case e3d.Opcode.ADDROF_G then
				index = self:next16()
				io.printf("ADDROF_G %d\n", index)
			case e3d.Opcode.ADDROF_L then
				index = self:next16()
				io.printf("ADDROF_L %d\n", index)
			case e3d.Opcode.ADDROF_A then
				index = self:next16()
				io.printf("ADDROF_A %d\n", index)
			case e3d.Opcode.PUSH_ZERO then
				io.printf("PUSH_ZERO\n")
			case e3d.Opcode.PUSH_ZEROF then
				io.printf("PUSH_ZEROF\n")
			case e3d.Opcode.PUSH_ONE then
				io.printf("PUSH_ONE\n")
			case e3d.Opcode.PUSH_ONEF then
				io.printf("PUSH_ONEF\n")
			case e3d.Opcode.PUSH_CHAR then
				io.printf("PUSH_CHAR %d\n", self:next8())
			case e3d.Opcode.PUSH_INT then
				io.printf("PUSH_INT %d\n", (@int32)(self:next32()))
			case e3d.Opcode.PUSH_FLOAT then
				io.printf("PUSH_FLOAT %f\n", self:nextF())
			case e3d.Opcode.PUSH_VEC2_ZERO then
				io.printf("PUSH_VEC2_ZERO\n")
			case e3d.Opcode.PUSH_VEC3_ZERO then
				io.printf("PUSH_VEC3_ZERO\n")
			case e3d.Opcode.PUSH_STRING then
				index = self:next16()
				local addr: uint32 = self:next32()
				io.printf("PUSH_STRING %d 0x%08X\n", index, addr)
			case e3d.Opcode.DISCARD then
				io.printf("DISCARD %d\n", self:next16())
			case e3d.Opcode.NOT then
				io.printf("NOT\n")
			case e3d.Opcode.OR then
				io.printf("OR\n")
			case e3d.Opcode.XOR then
				io.printf("XOR\n")
			case e3d.Opcode.AND then
				io.printf("AND\n")
			case e3d.Opcode.LSHIFT then
				io.printf("LSHIFT\n")
			case e3d.Opcode.RSHIFT then
				io.printf("RSHIFT\n")
			case e3d.Opcode.ARSHIFT then
				io.printf("ARSHIFT\n")
			case e3d.Opcode.NEG then
				io.printf("NEG\n")
			case e3d.Opcode.NEGF then
				io.printf("NEGF\n")
			case e3d.Opcode.NEGV then
				io.printf("NEGV %d\n", self:next8())
			case e3d.Opcode.ADD then
				io.printf("ADD\n")
			case e3d.Opcode.ADDF then
				io.printf("ADDF\n")
			case e3d.Opcode.ADDV then
				io.printf("ADDV %d\n", self:next8())
			case e3d.Opcode.ADDP then
				io.printf("ADDP %d\n", self:next16())
			case e3d.Opcode.SUB then
				io.printf("SUB\n")
			case e3d.Opcode.SUBF then
				io.printf("SUBF\n")
			case e3d.Opcode.SUBV then
				io.printf("SUBV %d\n", self:next8())
			case e3d.Opcode.SUBP then
				io.printf("SUBP %d\n", self:next16())
			case e3d.Opcode.MUL then
				io.printf("MUL\n")
			case e3d.Opcode.MULF then
				io.printf("MULF\n")
			case e3d.Opcode.MULV then
				io.printf("MULV %d\n", self:next8())
			case e3d.Opcode.DIV then
				io.printf("DIV\n")
			case e3d.Opcode.DIVU then
				io.printf("DIVU\n")
			case e3d.Opcode.DIVF then
				io.printf("DIVF\n")
			case e3d.Opcode.DIVV then
				io.printf("DIVV %d\n", self:next8())
			case e3d.Opcode.MOD then
				io.printf("MOD\n")
			case e3d.Opcode.MODU then
				io.printf("MODU\n")
			case e3d.Opcode.MODF then
				io.printf("MODF\n")
			case e3d.Opcode.LNOT then
				io.printf("LNOT\n")
			case e3d.Opcode.LNOTP then
				io.printf("LNOTP\n")
			case e3d.Opcode.EQ then
				io.printf("EQ\n")
			case e3d.Opcode.EQF then
				io.printf("EQF\n")
			case e3d.Opcode.EQV then
				io.printf("EQV %d\n", self:next8())
			case e3d.Opcode.EQS then
				io.printf("EQS\n")
			case e3d.Opcode.NE then
				io.printf("NE\n")
			case e3d.Opcode.NEF then
				io.printf("NEF\n")
			case e3d.Opcode.NEV then
				io.printf("NEV %d\n", self:next8())
			case e3d.Opcode.NES then
				io.printf("NES\n")
			case e3d.Opcode.LTI then
				io.printf("LTI\n")
			case e3d.Opcode.LTU then
				io.printf("LTU\n")
			case e3d.Opcode.LTF then
				io.printf("LTF\n")
			case e3d.Opcode.LTV then
				io.printf("LTV %d\n", self:next8())
			case e3d.Opcode.GTI then
				io.printf("GTI\n")
			case e3d.Opcode.GTU then
				io.printf("GTU\n")
			case e3d.Opcode.GTF then
				io.printf("GTF\n")
			case e3d.Opcode.GTV then
				io.printf("GTV %d\n", self:next8())
			case e3d.Opcode.LEI then
				io.printf("LEI\n")
			case e3d.Opcode.LEU then
				io.printf("LEU\n")
			case e3d.Opcode.LEF then
				io.printf("LEF\n")
			case e3d.Opcode.LEV then
				io.printf("LEV %d\n", self:next8())
			case e3d.Opcode.GEI then
				io.printf("GEI\n")
			case e3d.Opcode.GEU then
				io.printf("GEU\n")
			case e3d.Opcode.GEF then
				io.printf("GEF\n")
			case e3d.Opcode.GEV then
				io.printf("GEV %d\n", self:next8())
			case e3d.Opcode.JUMP then
				io.printf("JUMP 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_Z then
				io.printf("JUMP_Z 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_ZD then
				io.printf("JUMP_ZD 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_NZD then
				io.printf("JUMP_NZD 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_NULL then
				io.printf("JUMP_NULL 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_NULLD then
				io.printf("JUMP_NULLD 0x%04X\n", self:next16())
			case e3d.Opcode.JUMP_NNULLD then
				io.printf("JUMP_NNULLD 0x%04X\n", self:next16())
			case e3d.Opcode.CALL then
				index = self:next16()
				local argc: uint16 = self:next16()
				io.printf("CALL 0x%04X %d\n", index, argc)
			case e3d.Opcode.CALL_PTR then
				io.printf("CALL_PTR\n")
			case e3d.Opcode.RETURN then
				io.printf("RETURN\n")
			case e3d.Opcode.VARGP then
				index = self:next16()
				io.printf("VARGP %d\n", index)
			case e3d.Opcode.FTOI then
				io.printf("FTOI\n")
			case e3d.Opcode.ITOF then
				io.printf("ITOF\n")
			case e3d.Opcode.ITOB then
				io.printf("ITOB\n")
			case e3d.Opcode.PTOB then
				io.printf("PTOB\n")
			case e3d.Opcode.API then
				index = self:next16()
				local argc: uint16 = self:next16()
				io.printf("API 0x%04X %d\n", index, argc)
			else
				-- invalid opcode
				io.printf("!!! INVALID OPCODE !!!\n")
				self.cf = prev_cf
				return
		end
	end

	self.cf = prev_cf
end

function e3d.EVM:run(cycles: uinteger): boolean
	local index: uint16
	local running: boolean = true

	while running do
		local op: uint8 = self:next8()

		switch op do
			case e3d.Opcode.GET_G then
				index = self:next16()
				self:push(self:getGlobal(index))
			case e3d.Opcode.GET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getGlobals(index, n)
			case e3d.Opcode.SET_G then
				index = self:next16()
				self:setGlobal(index, self:pop())
			case e3d.Opcode.SET_GX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setGlobals(index, n)
			case e3d.Opcode.NEW_L then
				self.lsp = self.lsp + self:next16()

				if self.lsp > e3d.LOCALS_SIZE then
					self.error = string.format("RUNTIME ERROR: local variable stack limit exceeded by %d word(s)\n", self.lsp - e3d.LOCALS_SIZE)
					return false
				end
			case e3d.Opcode.DEL_L then
				self.lsp = self.lsp - self:next16()
			case e3d.Opcode.GET_L then
				index = self:next16()
				self:push(self:getLocal(index))
			case e3d.Opcode.GET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getLocals(index, n)
			case e3d.Opcode.SET_L then
				index = self:next16()
				self:setLocal(index, self:pop())
			case e3d.Opcode.SET_LX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setLocals(index, n)
			case e3d.Opcode.GET_A then
				index = self:next16()
				self:push(self:getArg(index))
			case e3d.Opcode.GET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:getArgs(index, n)
			case e3d.Opcode.SET_A then
				index = self:next16()
				self:setArg(index, self:pop())
			case e3d.Opcode.SET_AX then
				index = self:next16()
				local n: uint16 = self:next16()
				self:setArgs(index, n)
			case e3d.Opcode.GET_M then
				index = self:next16() -- offset in words
				local ptr: int32 = self:popI()
				local v: uint32

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end
				
				self:pushU(self:getMem32((@uint32)(ptr + (@int32)(index) * 4)))
			case e3d.Opcode.GET_MX then
				index = self:next16() -- offset in words
				local size: uint16 = self:next16()
				local ptr: int32 = self:popI()

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end

				local start: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				for i = 0, < size do
					local addr: uint32 = start + i * 4

					if addr > e3d.RAM_MAX_ADDR then
						self.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", addr)
						return false
					end
					
					self:pushU(self:getMem32(addr))
				end
			case e3d.Opcode.SET_M then
				index = self:next16() -- offset in words
				local v: uint32 = self:popU()
				local ptr: int32 = self:popI()

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid word write address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("RUNTIME ERROR: misaligned word write address 0x%08X\n", ptr)
					return false
				end
				
				if not self:setMem32((@uint32)(ptr + (@int32)(index) * 4), v) then
					self.error = string.format("RUNTIME ERROR: cannot write word to ROM address 0x%08X\n", ptr)
					return false
				end
			case e3d.Opcode.SET_MX then
				-- stack:
				-- > osp
				-- struct (size words)
				-- ptr
				index = self:next16() -- offset in words
				local size: uint16 = self:next16()
				local ptr: int32 = self.opstack[(self.osp - 1) - size].i

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("RUNTIME ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end

				local start_addr: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				local struct_start: uinteger = self.osp - size
				for i = 0, < size do
					local mem_addr: uint32 = start_addr + i * 4
					local struct_word_index: uint32 = struct_start + i

					if mem_addr > e3d.RAM_MAX_ADDR then
						self.error = string.format("RUNTIME ERROR: invalid word read address 0x%08X\n", mem_addr)
						return false
					end
					
					self:setMem32(mem_addr, self.opstack[struct_word_index].u)
				end

				self.osp = (self.osp - 1) - size -- pop ptr and struct from stack
			case e3d.Opcode.GET_S then
				local i: uint32 = self:popU()
				local s: e3d.EVMString = self:popStr()

				local addr: uint32 = s.data + i

				if addr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X\n", addr)
					return false
				end
			
				self:pushU(self:getMem8(addr))
			case e3d.Opcode.SET_S then
				local c: uint8 = (@uint8)(self:popU() & 0xFF)
				local i: uint32 = self:popU()
				local s: e3d.EVMString = self:popStr()

				local addr: uint32 = s.data + i

				if addr > e3d.RAM_MAX_ADDR then
					self.error = string.format("RUNTIME ERROR: invalid byte write address 0x%08X\n", addr)
					return false
				end
			
				if not self:setMem8(addr, c) then
					self.error = string.format("RUNTIME ERROR: cannot write byte to ROM address 0x%08X\n", addr)
					return false
				end
			case e3d.Opcode.ADDROF_G then
				index = self:next16()
				self:pushU(self:getAddressOfGlobal(index))
			case e3d.Opcode.ADDROF_L then
				index = self:next16()
				self:pushU(self:getAddressOfLocal(index))
			case e3d.Opcode.ADDROF_A then
				index = self:next16()
				self:pushU(self:getAddressOfArg(index))
			case e3d.Opcode.PUSH_ZERO then
				self:pushU(0)
			case e3d.Opcode.PUSH_ZEROF then
				self:pushF(0.0)
			case e3d.Opcode.PUSH_ONE then
				self:pushU(1)
			case e3d.Opcode.PUSH_ONEF then
				self:pushF(1.0)
			case e3d.Opcode.PUSH_CHAR then
				self:pushU((@uint32)(self:next8()))
			case e3d.Opcode.PUSH_INT then
				self:pushI((@int32)(self:next32()))
			case e3d.Opcode.PUSH_FLOAT then
				self:pushF(self:nextF())
			case e3d.Opcode.PUSH_VEC2_ZERO then
				self:pushV2({0,0})
			case e3d.Opcode.PUSH_VEC3_ZERO then
				self:pushV3({0,0,0})
			case e3d.Opcode.PUSH_STRING then
				index = self:next16()
				local addr: uint32 = self:next32()
				self:pushStr({index, addr})
			case e3d.Opcode.DISCARD then
				self:discard(self:next16())
			case e3d.Opcode.NOT then
				self:pushU(~self:popU())
			case e3d.Opcode.OR then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a | b)
			case e3d.Opcode.XOR then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a ~ b)
			case e3d.Opcode.AND then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a & b)
			case e3d.Opcode.LSHIFT then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a << b)
			case e3d.Opcode.RSHIFT then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a >> b)
			case e3d.Opcode.ARSHIFT then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a >>> b)
			case e3d.Opcode.NEG then
				self:pushI(-self:popI())
			case e3d.Opcode.NEGF then
				self:pushF(-self:popF())
			case e3d.Opcode.NEGV then
				index = (@uint16)(self:next8())
				if index == 0 then
					local v: rl.vector2 = self:popV2()
					self:pushV2({-v.x,-v.y})
				else
					local v: rl.vector3 = self:popV3()
					self:pushV3({-v.x,-v.y,-v.z})
				end
			case e3d.Opcode.ADD then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a + b)
			case e3d.Opcode.ADDF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a + b)
			case e3d.Opcode.ADDV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 + vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
							a.x + b.x,
							a.y + b.y})
					case 1 then -- vec3 + vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
							a.x + b.x,
							a.y + b.y,
							a.z + b.z})
				end
			case e3d.Opcode.ADDP then
				index = self:next16() -- size of type pointed to (in words)
				local v: int32 = self:popI()
				local p: int32 = self:popI()
				self:pushI(p + (v * (index * 4)))
			case e3d.Opcode.SUB then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a - b)
			case e3d.Opcode.SUBF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a - b)
			case e3d.Opcode.SUBV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 - vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
							a.x - b.x,
							a.y - b.y})
					case 1 then -- vec3 - vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
							a.x - b.x,
							a.y - b.y,
							a.z - b.z})
				end
			case e3d.Opcode.SUBP then
				index = self:next16() -- size of type pointed to (in words)
				local v: int32 = self:popI()
				local p: int32 = self:popI()
				self:pushI(p - (v * (index * 4)))
			case e3d.Opcode.MUL then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a * b)
			case e3d.Opcode.MULF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a * b)
			case e3d.Opcode.MULV then
				index = (@uint16)(self:next8())
				switch index do
					case e3d.MulVMode.INT_V2 then
						local a: rl.vector2 = self:popV2()
						local b: int32 = self:popI()
						self:pushV2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case e3d.MulVMode.INT_V3 then
						local a: rl.vector3 = self:popV3()
						local b: int32 = self:popI()
						self:pushV3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case e3d.MulVMode.FLOAT_V2 then
						local a: rl.vector2 = self:popV2()
						local b: float32 = self:popF()
						self:pushV2({
								a.x * b,
								a.y * b
							}
						)
					case e3d.MulVMode.FLOAT_V3 then
						local a: rl.vector3 = self:popV3()
						local b: float32 = self:popF()
						self:pushV3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case e3d.MulVMode.V2_INT then
						local b: int32 = self:popI()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case e3d.MulVMode.V2_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * b,
								a.y * b
							}
						)
					case e3d.MulVMode.V2_V2 then
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x * b.x,
								a.y * b.y
							}
						)
					case e3d.MulVMode.V3_INT then
						local b: int32 = self:popI()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case e3d.MulVMode.V3_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case e3d.MulVMode.V3_V3 then
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x * b.x,
								a.y * b.y,
								a.z * b.z
							}
						)
				end
			case e3d.Opcode.DIV then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a /// b)
			case e3d.Opcode.DIVU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a /// b)
			case e3d.Opcode.DIVF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(a / b)
			case e3d.Opcode.DIVV then
				index = (@uint16)(self:next8())
				switch index do
					case e3d.DivVMode.V2_INT then
						local b: int32 = self:popI()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / (@float32)(b),
								a.y / (@float32)(b)
							}
						)
					case e3d.DivVMode.V2_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / b,
								a.y / b
							}
						)
					case e3d.DivVMode.V2_V2 then
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushV2({
								a.x / b.x,
								a.y / b.y
							}
						)
					case e3d.DivVMode.V3_INT then
						local b: int32 = self:popI()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / (@float32)(b),
								a.y / (@float32)(b),
								a.z / (@float32)(b)
							}
						)
					case e3d.DivVMode.V3_FLOAT then
						local b: float32 = self:popF()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / b,
								a.y / b,
								a.z / b
							}
						)
					case e3d.DivVMode.V3_V3 then
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushV3({
								a.x / b.x,
								a.y / b.y,
								a.z / b.z
							}
						)
				end
			case e3d.Opcode.MOD then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushI(a %%% b)
			case e3d.Opcode.MODU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU(a %%% b)
			case e3d.Opcode.MODF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushF(math.fmod(a, b))
			case e3d.Opcode.LNOT then
				local v: uint32 = self:popU()
				self:pushU(v == 0 and 1 or 0)
			case e3d.Opcode.LNOTP then
				local v: uint32 = self:popU()
				self:pushU(v > e3d.RAM_MAX_ADDR and 1 or 0)
			case e3d.Opcode.EQ then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a == b) and 1 or 0)
			case e3d.Opcode.EQF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a == b) and 1 or 0)
			case e3d.Opcode.EQV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushU((a.x == b.x and a.y == b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushU((a.x == b.x and a.y == b.y and a.z == b.z) and 1 or 0)
				end
			case e3d.Opcode.EQS then
				local b: e3d.EVMString = self:popStr()
				local a: e3d.EVMString = self:popStr()

				if a.len ~= b.len then
					-- strings have different lengths, cannot be equal
					self:pushU(0)
				else
					if a.data == b.data then
						-- strings have same length and data address, equal
						self:pushU(1)
					else
						-- strings have same length but different data addresses,
						-- we must compare characters
						local a_addr: uint32 = a.data
						local b_addr: uint32 = b.data
						local result: uint32 = 1

						for i = 0, < a.len do
							local ac: uint8
							local bc: uint8

							if a_addr > e3d.RAM_MAX_ADDR then
								self.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X during string comparison\n", a_addr)
								return false
							end
						
							ac = self:getMem8(a_addr)

							if b_addr > e3d.RAM_MAX_ADDR then
								self.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X during string comparison\n", b_addr)
								return false
							end
						
							bc = self:getMem8(b_addr)

							if ac ~= bc then
								result = 0
								break
							end

							a_addr = a_addr + 1
							b_addr = b_addr + 1
						end

						self:pushU(result)
					end
				end
			case e3d.Opcode.NE then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a ~= b) and 1 or 0)
			case e3d.Opcode.NEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a ~= b) and 1 or 0)
			case e3d.Opcode.NEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						self:pushU((a.x ~= b.x and a.y ~= b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						self:pushU((a.x ~= b.x and a.y ~= b.y and a.z ~= b.z) and 1 or 0)
				end
			case e3d.Opcode.NES then
				local b: e3d.EVMString = self:popStr()
				local a: e3d.EVMString = self:popStr()

				if a.len ~= b.len then
					-- strings have different lengths, cannot be equal
					self:pushU(1)
				else
					if a.data == b.data then
						-- strings have same length and data address, equal
						self:pushU(0)
					else
						-- strings have same length but different data addresses,
						-- we must compare characters
						local a_addr: uint32 = a.data
						local b_addr: uint32 = b.data
						local result: uint32 = 0

						for i = 0, < a.len do
							local ac: uint8
							local bc: uint8

							if a_addr > e3d.RAM_MAX_ADDR then
								self.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X during string comparison\n", a_addr)
								return false
							end
						
							ac = self:getMem8(a_addr)

							if b_addr > e3d.RAM_MAX_ADDR then
								self.error = string.format("RUNTIME ERROR: invalid byte read address 0x%08X during string comparison\n", b_addr)
								return false
							end
						
							bc = self:getMem8(b_addr)

							if ac ~= bc then
								result = 1
								break
							end

							a_addr = a_addr + 1
							b_addr = b_addr + 1
						end

						self:pushU(result)
					end
				end
			case e3d.Opcode.LTI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a < b) and 1 or 0)
			case e3d.Opcode.LTU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a < b) and 1 or 0)
			case e3d.Opcode.LTF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a < b) and 1 or 0)
			case e3d.Opcode.LTV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 < vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y < b.y) and 1 or 0)
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 < vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z < b.z) and 1 or 0)
							else
								self:pushU((a.y < b.y) and 1 or 0)
							end
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.GTI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a > b) and 1 or 0)
			case e3d.Opcode.GTU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a > b) and 1 or 0)
			case e3d.Opcode.GTF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a > b) and 1 or 0)
			case e3d.Opcode.GTV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 > vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y > b.y) and 1 or 0)
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 > vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z > b.z) and 1 or 0)
							else
								self:pushU((a.y > b.y) and 1 or 0)
							end
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.LEI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a <= b) and 1 or 0)
			case e3d.Opcode.LEU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a <= b) and 1 or 0)
			case e3d.Opcode.LEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a <= b) and 1 or 0)
			case e3d.Opcode.LEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 <= vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y <= b.y) and 1 or 0)
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 <= vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z <= b.z) and 1 or 0)
							else
								self:pushU((a.y < b.y) and 1 or 0)
							end
						else
							self:pushU((a.x < b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.GEI then
				local b: int32 = self:popI()
				local a: int32 = self:popI()
				self:pushU((a >= b) and 1 or 0)
			case e3d.Opcode.GEU then
				local b: uint32 = self:popU()
				local a: uint32 = self:popU()
				self:pushU((a >= b) and 1 or 0)
			case e3d.Opcode.GEF then
				local b: float32 = self:popF()
				local a: float32 = self:popF()
				self:pushU((a >= b) and 1 or 0)
			case e3d.Opcode.GEV then
				index = (@uint16)(self:next8())
				switch index do
					case 0 then -- vec2 >= vec2
						local b: rl.vector2 = self:popV2()
						local a: rl.vector2 = self:popV2()
						if a.x == b.x then
							self:pushU((a.y >= b.y) and 1 or 0)
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 >= vec3
						local b: rl.vector3 = self:popV3()
						local a: rl.vector3 = self:popV3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushU((a.z >= b.z) and 1 or 0)
							else
								self:pushU((a.y > b.y) and 1 or 0)
							end
						else
							self:pushU((a.x > b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.JUMP then
				index = self:next16()
				self.cf.pc = index
			case e3d.Opcode.JUMP_Z then
				index = self:next16()
				local v: uint32 = self:popU()

				if v == 0 then
					self.cf.pc = index
				end
			case e3d.Opcode.JUMP_ZD then
				-- jump if zero but only discard value if branch is not taken
				-- used by && operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u

				if v == 0 then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 0
				else
					self.osp = self.osp - 1
				end
			case e3d.Opcode.JUMP_NZD then
				-- jump if not zero but only discard value if branch is not taken
				-- used by || operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				
				if v ~= 0 then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 1
				else
					self.osp = self.osp - 1
				end
			case e3d.Opcode.JUMP_NULL then
				index = self:next16()
				local v: uint32 = self:popU()

				if v > e3d.RAM_MAX_ADDR then
					self.cf.pc = index
				end
			case e3d.Opcode.JUMP_NULLD then
				-- jump if null but only discard value if branch is not taken
				-- used by && operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u

				if v > e3d.RAM_MAX_ADDR then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 0
				else
					self.osp = self.osp - 1
				end
			case e3d.Opcode.JUMP_NNULLD then
				-- jump if not null but only discard value if branch is not taken
				-- used by || operator
				index = self:next16()
				local v: uint32 = self.opstack[self.osp - 1].u
				
				if v <= e3d.RAM_MAX_ADDR then
					self.cf.pc = index
					self.opstack[self.osp - 1].u = 1
				else
					self.osp = self.osp - 1
				end
			case e3d.Opcode.CALL then
				if self.csp >= e3d.CALLSTACK_SIZE then
					self.error = "RUNTIME ERROR: callstack overflow\n"
					return false
				end

				index = self:next16()
				local argc: uint16 = self:next16()

				if self.asp + argc >= e3d.ARGS_SIZE then
					self.error = "RUNTIME ERROR: argstack overflow\n"
					return false
				end

				self:pushArgs(argc)
				self:pushCallframe(argc)
				self.cf.pc = index
			case e3d.Opcode.CALL_PTR then
				local addr: uint32 = self:popU()
				if addr < e3d.BYTECODE_SIZE then
					self:pushCallframe(0)
					self.cf.pc = addr
				else
					self.error = string.format("RUNTIME ERROR: invalid call address 0x%08X\n", addr)
					return false
				end
			case e3d.Opcode.RETURN then
				-- if returning from first function call, halt the program
				if self.csp == 1 then
					return true
				else
					self:popCallframe()
				end
			case e3d.Opcode.VARGP then
				index = self:next16()
				self.cf.vargp = self.ap + index
				self.cf.vargc = self.cf.argc - index
				self.cf.vargf = true
			case e3d.Opcode.FTOI then
				self:pushI((@int32)(self:popF()))
			case e3d.Opcode.ITOF then
				self:pushF((@float32)(self:popI()))
			case e3d.Opcode.ITOB then
				self:pushU(self:popU() ~= 0 and 1 or 0)
			case e3d.Opcode.PTOB then
				self:pushU(self:popU() <= e3d.RAM_MAX_ADDR and 1 or 0)
			case e3d.Opcode.API then
				index = self:next16()
				local argc: uint16 = self:next16()
				local func: e3d.APIFunction = self.api_funcs[index]
				if func ~= nilptr then
					if self.csp >= e3d.CALLSTACK_SIZE then
						self.error = "RUNTIME ERROR: callstack overflow\n"
						return false
					end

					if self.asp + argc >= e3d.ARGS_SIZE then
						self.error = "RUNTIME ERROR: argstack overflow\n"
						return false
					end

					self:pushArgs(argc)
					self:pushCallframe(argc)
					if not func(self) then
						self:popCallframe()
						return false
					end
					self:popCallframe()
				else
					self.error = string.format("RUNTIME ERROR: attempt to call unregistered API function at index %d\n", index)
					return false
				end
			else
				-- invalid opcode
				self.error = string.format("RUNTIME ERROR: attempt to execute invalid opcode %d\n", op)
				return false
		end

		if self.cf.pc >= self.bytecode_len then
			running = false
		elseif cycles > 0 then
			cycles = cycles - 1
			running = cycles > 0
		end
	end
	
	return true
end

function e3d.EVM:callHook(hook: integer): boolean
	if self.hook_flags[hook] then
		self.current_hook = hook
		self.cf.pc = self.hook_addresses[hook]

		local argc: uint16 = 0
		if self.current_hook == e3d.Hook.UPDATE then
			self:pushF(rl.getFrameTime())
			self:pushArgs(1)
			argc = 1
		end

		self:pushCallframe(argc)
		local result: boolean = self:run(0)
		self:popCallframe()

		if self.current_hook == e3d.Hook.DRAW then
			rlgl.drawRenderBatchActive()
		end

		return result
	end
	return true
end

local function isLittleEndian(): boolean
	local x: uint32 <volatile> = 0x01234567
	local p: *uint8 = (@*uint8)(&x)
	return $p == 0x67
end

local function byteSwapCartData(cart: *e3d.Cart): void
	local p: *[0]uint8 = (@*[0]uint8)(&cart.tbank)
	local p2: *[0]uint8 = (@*[0]uint8)(&cart.obank)
	for i: uint64 = 0, < 4*1024*1024 do
		local byte_index: uint64 = i * 4

		p[byte_index], p[byte_index + 3] = p[byte_index + 3], p[byte_index]
		p[byte_index + 1], p[byte_index + 2] = p[byte_index + 2], p[byte_index + 1]

		p2[byte_index], p2[byte_index + 3] = p2[byte_index + 3], p2[byte_index]
		p2[byte_index + 1], p2[byte_index + 2] = p2[byte_index + 2], p2[byte_index + 1]
	end

	p = (@*[0]uint8)(&cart.wbank)
	for i: uint64 = 0, < 7*1024*1024 do
		local byte_index: uint64 = i * 2
		p[byte_index], p[byte_index + 1] = p[byte_index + 1], p[byte_index]
	end
end

function e3d.EVM:saveCart(filename: string): boolean
	local header: [16]uint8 = {
		'E'_u8,
		'R'_u8,
		'A'_u8,
		'3'_u8,
		'D'_u8,
		'R'_u8,
		'O'_u8,
		'M'_u8,
		(@uint8)(e3d.VER_MAJOR >> 8),
		(@uint8)(e3d.VER_MAJOR & 0xFF),
		(@uint8)(e3d.VER_MINOR),
		(@uint8)(e3d.VER_PATCH),
		(@uint8)(self.src_len >> 24),
		(@uint8)(self.src_len >> 16),
		(@uint8)(self.src_len >> 8),
		(@uint8)(self.src_len & 0xFF),
	}
	local result: csize
	local file: *C.FILE = C.fopen(filename, "wb")
	if file == nilptr then
		self.error = "failed to open file\n"
		return false
	end
	defer
		C.fclose(file)
	end

	-- memcpy cart data to temp_cart
	memory.copy(&self.temp_cart.tbank, &self.cart.tbank, 16*1024*1024)
	memory.copy(&self.temp_cart.obank, &self.cart.obank, 16*1024*1024)
	memory.copy(&self.temp_cart.wbank, &self.cart.wbank, 14*1024*1024)
	memory.copy(&self.temp_cart.sbank, &self.cart.sbank, 2*1024*1024)
	memory.copy(&self.temp_cart.rom, &self.cart.rom, 16*1024*1024)

	-- byteswap data if little endian
	if isLittleEndian() then
		byteSwapCartData(&self.temp_cart)
	end

	-- write data to file
	result = C.fwrite(&header, 1, 16, file)
	if result ~= 16 then
		self.error = "failed to write header\n"
		return false
	end

	result = C.fwrite(&self.src, 1, self.src_len, file)
	if result ~= self.src_len then
		self.error = "failed to write src\n"
		return false
	end

	result = C.fwrite(&self.temp_cart.tbank, 4, 4*1024*1024, file)
	if result ~= 4*1024*1024 then
		self.error = "failed to write tbank data\n"
		return false
	end

	result = C.fwrite(&self.temp_cart.obank, 4, 4*1024*1024, file)
	if result ~= 4*1024*1024 then
		self.error = "failed to write obank data\n"
		return false
	end

	result = C.fwrite(&self.temp_cart.wbank, 2, 7*1024*1024, file)
	if result ~= 7*1024*1024 then
		self.error = "failed to write wbank data\n"
		return false
	end

	result = C.fwrite(&self.temp_cart.sbank, 1, 2*1024*1024, file)
	if result ~= 2*1024*1024 then
		self.error = "failed to write sbank data\n"
		return false
	end

	result = C.fwrite(&self.temp_cart.rom, 1, 16*1024*1024, file)
	if result ~= 16*1024*1024 then
		self.error = "failed to write rom data\n"
		return false
	end

	return true
end

function e3d.EVM:loadCart(filename: string): boolean
	--[[ .E3D CART FORMAT
		HEADER:
			"ERA3DROM" magic header  (8 bytes)
			version number           (4 bytes)
				major (uint16)
				minor (uint8)
				patch (uint8)
			src length               (4 bytes)
		ROM DATA:
			source code (plain text) (??? bytes)
			ROM banks                (64 MiB)
	]]

	local expected_header: [8]uint8 = {
		'E'_u8,
		'R'_u8,
		'A'_u8,
		'3'_u8,
		'D'_u8,
		'R'_u8,
		'O'_u8,
		'M'_u8
	}
	local header: [16]uint8
	local result: csize
	local file: *C.FILE = C.fopen(filename, "rb")
	if file == nilptr then
		self.error = "failed to open file\n"
		return false
	end
	defer
		C.fclose(file)
	end

	-- read data

	result = C.fread(&header, 1, 16, file)
	if result ~= 16 then
		self.error = "failed to read header\n"
		return false
	end

	for i = 0, < 8 do
		if header[i] ~= expected_header[i] then
			self.error = "invalid header\n"
			return false
		end
	end

	-- check version
	local ver_major: uint16 = ((@uint16)(header[8]) << 8) | (@uint16)(header[9])
	if ver_major < e3d.VER_MAJOR then
		self.error = "cannot load cart made using incompatible past version of ERA-3D\n"
		return false
	elseif ver_major > e3d.VER_MAJOR then
		self.error = "cannot load cart made using incompatible future version of ERA-3D\n"
		return false
	end

	self.src_len = ((@uint32)(header[12]) << 24) | ((@uint32)(header[13]) << 16) | ((@uint32)(header[14]) << 8) | (@uint32)(header[15])

	if self.src_len > e3d.SRC_SIZE then
		self.error = "invalid src length\n"
		return false
	end

	result = C.fread(&self.src, 1, self.src_len, file)
	if result ~= self.src_len then
		self.error = "failed to read src\n"
		return false
	end

	result = C.fread(&self.cart.tbank, 4, 4*1024*1024, file)
	if result ~= 4*1024*1024 then
		self.error = "failed to read tbank data\n"
		return false
	end

	result = C.fread(&self.cart.obank, 4, 4*1024*1024, file)
	if result ~= 4*1024*1024 then
		self.error = "failed to read obank data\n"
		return false
	end

	result = C.fread(&self.cart.wbank, 2, 7*1024*1024, file)
	if result ~= 7*1024*1024 then
		self.error = "failed to read wbank data\n"
		return false
	end

	result = C.fread(&self.cart.sbank, 1, 2*1024*1024, file)
	if result ~= 2*1024*1024 then
		self.error = "failed to read sbank data\n"
		return false
	end

	result = C.fread(&self.cart.rom, 1, 16*1024*1024, file)
	if result ~= 16*1024*1024 then
		self.error = "failed to read rom data\n"
		return false
	end

	-- swap bytes
	if isLittleEndian() then
		byteSwapCartData(&self.cart)
	end

	-- load cart ROM banks into system memory
	memory.copy(&self.gpu.tmem, &self.cart.tbank, 4*1024*1024)
	memory.copy(&self.gpu.omem, &self.cart.obank, (3*1024*1024) + (384*1024))
	memory.copy(&self.soundchip.wmem, &self.cart.wbank, 7*1024*1024)
	memory.copy(&self.soundchip.smem, &self.cart.sbank, 256*1024)

	rl.updateTexture(self.gpu.gfx_texture, &self.gpu.tmem)

	return true
end

function e3d.EVM:loadData(src_file: string, tex_file: string): boolean
	local sfs, err, errcode = filestream.open(src_file)
	if not sfs:isopen() then
		self.error = string.format("failed to open file `%s`: %s (error code: %d)\n", src_file, err, errcode)
		return false
	end

	local data: string, err, errcode = sfs:read("a")
	self.src_len = #data
	memory.copy(&self.src, data.data, self.src_len)

	sfs:close()

	if tex_file ~= "" then
		local img: rl.image = rl.loadImage(tex_file)
		if img.format ~= rl.pixelFormat.UNCOMPRESSED_R8G8B8A8 then
			rl.imageFormat(&img, rl.pixelFormat.UNCOMPRESSED_R8G8B8A8)
		end
		memory.copy(&self.cart.tbank, img.data, 1024 * 1024 * #rl.color)
		rl.unloadImage(img)
	end

	return true
end

function e3d.EVM:__gc(): void
	self.soundchip:cleanup()
	self.gpu:cleanup()
end

function e3d.newVM(): *e3d.EVM
	local vm: *e3d.EVM = new(@e3d.EVM)

	vm:registerAPI()
	vm:registerBuiltins()
	
	vm.gpu:init()
	vm.soundchip:init()
	vm:resetVM(false)
	return vm
end
