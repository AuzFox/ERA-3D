require("api")

function e3d.EVM:get_global(i: uint16): e3d.EVMValue
	return self.globals[i]
end

function e3d.EVM:get_globali(i: uint16): int32
	return self.globals[i].i
end

function e3d.EVM:get_globalu(i: uint16): uint32
	return self.globals[i].u
end

function e3d.EVM:get_globalf(i: uint16): float32
	return self.globals[i].f
end

function e3d.EVM:get_globalv2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	
	return v
end

function e3d.EVM:get_globalv3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.globals[i].f
	v.y = self.globals[i + 1].f
	v.z = self.globals[i + 2].f
	
	return v
end

function e3d.EVM:set_global(i: uint16, val: e3d.EVMValue): void
	self.globals[i] = val
end

function e3d.EVM:set_globali(i: uint16, val: int32): void
	self.globals[i].i = val
end

function e3d.EVM:set_globalu(i: uint16, val: uint32): void
	self.globals[i].u = val
end

function e3d.EVM:set_globalf(i: uint16, val: float32): void
	self.globals[i].f = val
end

function e3d.EVM:set_globalv2(i: uint16, val: rl.vector2): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
end

function e3d.EVM:set_globalv3(i: uint16, val: rl.vector3): void
	self.globals[i].f = val.x
	self.globals[i + 1].f = val.y
	self.globals[i + 2].f = val.z
end

function e3d.EVM:get_local(i: uint16): e3d.EVMValue
	return self.locals[self.cf.lbp + i]
end

function e3d.EVM:set_local(i: uint16, val: e3d.EVMValue): void
	self.locals[self.cf.lbp + i] = val
end

function e3d.EVM:get_arg(i: uint16): e3d.EVMValue
	return self.args[self.ap + i]
end

function e3d.EVM:get_argi(i: uint16): int32
	return self.args[self.ap + i].i
end

function e3d.EVM:get_argu(i: uint16): uint32
	return self.args[self.ap + i].u
end

function e3d.EVM:get_argf(i: uint16): float32
	return self.args[self.ap + i].f
end

function e3d.EVM:get_argv2(i: uint16): rl.vector2
	local v: rl.vector2

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f

	return v
end

function e3d.EVM:get_argv3(i: uint16): rl.vector3
	local v: rl.vector3

	v.x = self.args[self.ap + i].f
	v.y = self.args[self.ap + i + 1].f
	v.z = self.args[self.ap + i + 2].f

	return v
end

function e3d.EVM:set_arg(i: uint16, val: e3d.EVMValue): void
	self.args[self.ap + i] = val
end

function e3d.EVM:set_argi(i: uint16, val: int32): void
	self.args[self.ap + i].i = val
end

function e3d.EVM:set_argu(i: uint16, val: uint32): void
	self.args[self.ap + i].u = val
end

function e3d.EVM:set_argf(i: uint16, val: float32): void
	self.args[self.ap + i].f = val
end

function e3d.EVM:set_argv2(i: uint16, val: rl.vector2): void
	self.args[self.ap + i].f = val.x
	self.args[self.ap + i + 1].f = val.y
end

function e3d.EVM:set_argv3(i: uint16, val: rl.vector3): void
	self.args[self.ap + i].f = val.x
	self.args[self.ap + i + 1].f = val.y
	self.args[self.ap + i + 2].f = val.z
end

function e3d.EVM:push(val: e3d.EVMValue): void
	self.opstack[self.osp] = val
	self.osp = self.osp + 1
end

function e3d.EVM:pushi(val: int32): void
	self.opstack[self.osp] = {i=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushu(val: uint32): void
	self.opstack[self.osp] = {u=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushf(val: float32): void
	self.opstack[self.osp] = {f=val}
	self.osp = self.osp + 1
end

function e3d.EVM:pushv2(val: rl.vector2): void
	self:pushf(val.x)
	self:pushf(val.y)
end

function e3d.EVM:pushv3(val: rl.vector3): void
	self:pushf(val.x)
	self:pushf(val.y)
	self:pushf(val.z)
end

function e3d.EVM:pop(): e3d.EVMValue
	self.osp = self.osp - 1
	return self.opstack[self.osp]
end

function e3d.EVM:popi(): int32
	self.osp = self.osp - 1
	return self.opstack[self.osp].i
end

function e3d.EVM:popu(): uint32
	self.osp = self.osp - 1
	return self.opstack[self.osp].u
end

function e3d.EVM:popf(): float32
	self.osp = self.osp - 1
	return self.opstack[self.osp].f
end

function e3d.EVM:popv2(): rl.vector2
	local v: rl.vector2
	v.y = self:popf()
	v.x = self:popf()
	return v
end

function e3d.EVM:popv3(): rl.vector3
	local v: rl.vector3
	v.z = self:popf()
	v.y = self:popf()
	v.x = self:popf()
	return v
end

function e3d.EVM:reset(reset_gpu: boolean): void
	-- TODO: free all vm program memory, clear ram

	self.cf = {}
	self.lsp = 0
	self.asp = 0
	self.ap = 0
	self.osp = 0
	self.csp = 0
	self.init_time = rl.getTime()

	if reset_gpu then
		self.gpu:reset()
	end

	math.randomseed()
end

-- get one word from the vm RAM, does not do bounds or alignment checking!
function e3d.EVM:_get_ramw(addr: uint32): uint32
	if addr < e3d.TMEM_START_ADDR then
		-- heap
		return ((@uint32)(self.heap[addr]) << 24) | ((@uint32)(self.heap[addr + 1]) << 16) | ((@uint32)(self.heap[addr + 2]) << 8) | (@uint32)(self.heap[addr + 3])
	elseif addr < e3d.GLOBALS_START_ADDR then
		-- tmem
		local col: rl.color = self.tmem[(addr - e3d.TMEM_START_ADDR) /// 4]
		return (((@uint32)(col.r) << 24) | ((@uint32)(col.g) << 16) | ((@uint32)(col.b) << 8) | (@uint32)(col.a))
	elseif addr < e3d.LOCALS_START_ADDR then
		-- globals
		return self.globals[(addr - e3d.GLOBALS_START_ADDR) /// 4].u
	elseif addr < e3d.ARGS_START_ADDR then
		-- locals
		return self.locals[(addr - e3d.LOCALS_START_ADDR) /// 4].u
	elseif addr < e3d.ROM_START_ADDR then
		-- args
		return self.args[(addr - e3d.ARGS_START_ADDR) /// 4].u
	else
		-- rom
		addr = (addr - e3d.ROM_START_ADDR) /// 4
		return ((@uint32)(self.rom[addr]) << 24) | ((@uint32)(self.rom[addr + 1]) << 16) | ((@uint32)(self.rom[addr + 2]) << 8) | (@uint32)(self.rom[addr + 3])
	end
end

-- set one word in the vm RAM, does not do bounds or alignment checking!
function e3d.EVM:_set_ramw(addr: uint32, val: uint32): boolean
	if addr < e3d.TMEM_START_ADDR then
		-- heap
		self.heap[addr] = val >> 24
		self.heap[addr + 1] = (val & 0xFF0000) >> 16
		self.heap[addr + 2] = (val & 0x00FF00) >> 8
		self.heap[addr + 3] = val & 0xFF
	elseif addr < e3d.GLOBALS_START_ADDR then
		-- tmem
		local col: rl.color
		addr = (addr - e3d.TMEM_START_ADDR) /// 4
		col.r = val >> 24
		col.g = (val & 0xFF0000) >> 16
		col.b = (val & 0x00FF00) >> 8
		col.a = val & 0xFF
		self.tmem[addr] = col
		self.gpu.update_tex = true
	elseif addr < e3d.LOCALS_START_ADDR then
		-- globals
		self.globals[(addr - e3d.GLOBALS_START_ADDR) /// 4].u = val
	elseif addr < e3d.ARGS_START_ADDR then
		-- locals
		self.locals[(addr - e3d.LOCALS_START_ADDR) /// 4].u = val
	elseif addr < e3d.ROM_START_ADDR then
		-- args
		self.args[(addr - e3d.ARGS_START_ADDR) /// 4].u = val
	else
		-- rom, can't write here!
		return false
	end

	return true
end

function e3d.EVM:_get_globals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.globals[start + i])
	end
end

function e3d.EVM:_set_globals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.globals[end_index - i] = self:pop()
	end
end

function e3d.EVM:_get_locals(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.locals[self.cf.lbp + start + i])
	end
end

function e3d.EVM:_set_locals(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.locals[self.cf.lbp + (end_index - i)] = self:pop()
	end
end

function e3d.EVM:_get_args(start: uint16, n: uint16): void
	for i = 0, < n do
		self:push(self.args[self.ap + start + i])
	end
end

function e3d.EVM:_set_args(start: uint16, n: uint16): void
	-- values are popped in reverse order
	local end_index: uint16 = start + n - 1
	
	for i = 0, < n do
		self.args[self.ap + (end_index - i)] = self:pop()
	end
end

function e3d.EVM:_push_args(n: uint16): void
	for i = 0, < n do
		self.args[self.asp + i] = self.opstack[(self.osp - n) + i]
	end
	self.asp = self.asp + n
	self.osp = self.osp - n
end

function e3d.EVM:_push_callframe(argc: uint16): void
	self.callstack[self.csp] = self.cf
	self.csp = self.csp + 1
	
	self.cf.lbp = self.lsp
	self.cf.argc = argc

	self.ap = self.asp - argc
end

function e3d.EVM:_pop_callframe(): void
	self.lsp = self.cf.lbp
	self.asp = self.asp - self.cf.argc
	
	self.csp = self.csp - 1
	self.cf = self.callstack[self.csp]
	
	self.ap = self.asp - self.cf.argc
end

function e3d.EVM:_address_of_global(index: uint16): uint32
	return e3d.GLOBALS_START_ADDR + (index * 4)
end

function e3d.EVM:_address_of_local(index: uint16): uint32
	return e3d.LOCALS_START_ADDR + ((self.cf.lbp + index) * 4)
end

function e3d.EVM:_address_of_arg(index: uint16): uint32
	return e3d.ARGS_START_ADDR + ((self.ap + index) * 4)
end

function e3d.EVM:_bytecode_next8(): uint8
	local v: uint8 = self.bytecode[self.cf.pc]

	self.cf.pc = self.cf.pc + 1

	return v
end

function e3d.EVM:_bytecode_next16(): uint16
	local v: uint16 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]

	self.cf.pc = self.cf.pc + 2

	return v
end

function e3d.EVM:_bytecode_next32(): uint32
	local v: uint32 = self.bytecode[self.cf.pc]
	v = (v << 8) | self.bytecode[self.cf.pc + 1]
	v = (v << 8) | self.bytecode[self.cf.pc + 2]
	v = (v << 8) | self.bytecode[self.cf.pc + 3]

	self.cf.pc = self.cf.pc + 4

	return v
end

function e3d.EVM:_bytecode_nextf(): float32
	local v: e3d.EVMValue = {u=self:_bytecode_next32()}

	return v.f
end

function e3d.EVM:_bytecode_nextv2(): rl.vector2
	local x: float32 = self:_bytecode_nextf()
	local y: float32 = self:_bytecode_nextf()

	return {x, y}
end

function e3d.EVM:_bytecode_nextv3(): rl.vector3
	local x: float32 = self:_bytecode_nextf()
	local y: float32 = self:_bytecode_nextf()
	local z: float32 = self:_bytecode_nextf()

	return {x, y, z}
end

function e3d.EVM:_dump_bytecode(): void
	local prev_cf: e3d.CallFrame = self.cf
	self.cf = {}
	
	local index: uint16
	while self.cf.pc < self.bytecode_len do
		local op: uint8 = self:_bytecode_next8()

		io.printf("0x%04X: ", self.cf.pc - 1)
		
		switch op do
			case e3d.Opcode.GET_G then
				index = self:_bytecode_next16()
				io.printf("GET_G %d\n", index)
			case e3d.Opcode.GET_GX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("GET_GX %d %d\n", index, n)
			case e3d.Opcode.SET_G then
				index = self:_bytecode_next16()
				io.printf("SET_G %d\n", index)
			case e3d.Opcode.SET_GX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("SET_GX %d %d\n", index, n)
			case e3d.Opcode.NEW_L then
				io.printf("NEW_L %d\n", self:_bytecode_next16())
			case e3d.Opcode.DEL_L then
				io.printf("DEL_L %d\n", self:_bytecode_next16())
			case e3d.Opcode.GET_L then
				index = self:_bytecode_next16()
				io.printf("GET_L %d\n", index)
			case e3d.Opcode.GET_LX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("GET_LX %d %d\n", index, n)
			case e3d.Opcode.SET_L then
				index = self:_bytecode_next16()
				io.printf("SET_L %d\n", index)
			case e3d.Opcode.SET_LX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("SET_LX %d %d\n", index, n)
			case e3d.Opcode.GET_A then
				index = self:_bytecode_next16()
				io.printf("GET_A %d\n", index)
			case e3d.Opcode.GET_AX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("GET_AX %d %d\n", index, n)
			case e3d.Opcode.SET_A then
				index = self:_bytecode_next16()
				io.printf("SET_A %d\n", index)
			case e3d.Opcode.SET_AX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("SET_AX %d %d\n", index, n)
			case e3d.Opcode.GET_M then
				index = self:_bytecode_next16()
				io.printf("GET_M %d\n", index)
			case e3d.Opcode.GET_MX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("GET_MX %d %d\n", index, n)
			case e3d.Opcode.SET_M then
				index = self:_bytecode_next16()
				io.printf("SET_M %d\n", index)
			case e3d.Opcode.SET_MX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				io.printf("SET_MX %d %d\n", index, n)
			case e3d.Opcode.ADDROF_G then
				index = self:_bytecode_next16()
				io.printf("ADDROF_G %d\n", index)
			case e3d.Opcode.ADDROF_L then
				index = self:_bytecode_next16()
				io.printf("ADDROF_L %d\n", index)
			case e3d.Opcode.ADDROF_A then
				index = self:_bytecode_next16()
				io.printf("ADDROF_A %d\n", index)
			case e3d.Opcode.PUSH_ZERO then
				io.printf("PUSH_ZERO\n")
			case e3d.Opcode.PUSH_ONE then
				io.printf("PUSH_ONE\n")
			case e3d.Opcode.PUSH_CHAR then
				io.printf("PUSH_CHAR %d\n", self:_bytecode_next8())
			case e3d.Opcode.PUSH_INT then
				io.printf("PUSH_INT %d\n", (@int32)(self:_bytecode_next32()))
			case e3d.Opcode.PUSH_FLOAT then
				io.printf("PUSH_FLOAT %f\n", self:_bytecode_nextf())
			case e3d.Opcode.PUSH_VEC2_ZERO then
				io.printf("PUSH_VEC2_ZERO\n")
			case e3d.Opcode.PUSH_VEC3_ZERO then
				io.printf("PUSH_VEC3_ZERO\n")
			case e3d.Opcode.BIN_NOT then
				io.printf("BIN_NOT\n")
			case e3d.Opcode.BIN_OR then
				io.printf("BIN_OR\n")
			case e3d.Opcode.BIN_XOR then
				io.printf("BIN_XOR\n")
			case e3d.Opcode.BIN_AND then
				io.printf("BIN_AND\n")
			case e3d.Opcode.BIN_LSHIFT then
				io.printf("BIN_LSHIFT\n")
			case e3d.Opcode.BIN_RSHIFT then
				io.printf("BIN_RSHIFT\n")
			case e3d.Opcode.BIN_ARSHIFT then
				io.printf("BIN_ARSHIFT\n")
			case e3d.Opcode.NEG then
				io.printf("NEG\n")
			case e3d.Opcode.NEGF then
				io.printf("NEGF\n")
			case e3d.Opcode.NEGV then
				io.printf("NEGV %d\n", self:_bytecode_next8())
			case e3d.Opcode.ADD then
				io.printf("ADD\n")
			case e3d.Opcode.ADDF then
				io.printf("ADDF\n")
			case e3d.Opcode.ADDV then
				io.printf("ADDV %d\n", self:_bytecode_next8())
			case e3d.Opcode.ADDP then
				io.printf("ADDP %d\n", self:_bytecode_next16())
			case e3d.Opcode.SUB then
				io.printf("SUB\n")
			case e3d.Opcode.SUBF then
				io.printf("SUBF\n")
			case e3d.Opcode.SUBV then
				io.printf("SUBV %d\n", self:_bytecode_next8())
			case e3d.Opcode.SUBP then
				io.printf("SUBP %d\n", self:_bytecode_next16())
			case e3d.Opcode.MUL then
				io.printf("MUL\n")
			case e3d.Opcode.MULF then
				io.printf("MULF\n")
			case e3d.Opcode.MULV then
				io.printf("MULV %d\n", self:_bytecode_next8())
			case e3d.Opcode.DIV then
				io.printf("DIV\n")
			case e3d.Opcode.DIVU then
				io.printf("DIVU\n")
			case e3d.Opcode.DIVF then
				io.printf("DIVF\n")
			case e3d.Opcode.DIVV then
				io.printf("DIVV %d\n", self:_bytecode_next8())
			case e3d.Opcode.MOD then
				io.printf("MOD\n")
			case e3d.Opcode.MODU then
				io.printf("MODU\n")
			case e3d.Opcode.MODF then
				io.printf("MODF\n")
			case e3d.Opcode.LOGIC_NOT then
				io.printf("LOGIC_NOT\n")
			case e3d.Opcode.LOGIC_OR then
				io.printf("LOGIC_OR\n")
			case e3d.Opcode.LOGIC_AND then
				io.printf("LOGIC_AND\n")
			case e3d.Opcode.EQ then
				io.printf("EQ\n")
			case e3d.Opcode.EQF then
				io.printf("EQF\n")
			case e3d.Opcode.EQV then
				io.printf("EQV %d\n", self:_bytecode_next8())
			case e3d.Opcode.NE then
				io.printf("NE\n")
			case e3d.Opcode.NEF then
				io.printf("NEF\n")
			case e3d.Opcode.NEV then
				io.printf("NEV %d\n", self:_bytecode_next8())
			case e3d.Opcode.LTI then
				io.printf("LTI\n")
			case e3d.Opcode.LTU then
				io.printf("LTU\n")
			case e3d.Opcode.LTF then
				io.printf("LTF\n")
			case e3d.Opcode.LTV then
				io.printf("LTV %d\n", self:_bytecode_next8())
			case e3d.Opcode.GTI then
				io.printf("GTI\n")
			case e3d.Opcode.GTU then
				io.printf("GTU\n")
			case e3d.Opcode.GTF then
				io.printf("GTF\n")
			case e3d.Opcode.GTV then
				io.printf("GTV %d\n", self:_bytecode_next8())
			case e3d.Opcode.LEI then
				io.printf("LEI\n")
			case e3d.Opcode.LEU then
				io.printf("LEU\n")
			case e3d.Opcode.LEF then
				io.printf("LEF\n")
			case e3d.Opcode.LEV then
				io.printf("LEV %d\n", self:_bytecode_next8())
			case e3d.Opcode.GEI then
				io.printf("GEI\n")
			case e3d.Opcode.GEU then
				io.printf("GEU\n")
			case e3d.Opcode.GEF then
				io.printf("GEF\n")
			case e3d.Opcode.GEV then
				io.printf("GEV %d\n", self:_bytecode_next8())
			case e3d.Opcode.JUMP then
				io.printf("JUMP 0x%04X\n", self:_bytecode_next16())
			case e3d.Opcode.JUMP_Z then
				io.printf("JUMP_Z 0x%04X\n", self:_bytecode_next16())
			case e3d.Opcode.CALL then
				index = self:_bytecode_next16()
				local argc: uint16 = self:_bytecode_next16()
				io.printf("CALL 0x%04X %d\n", index, argc)
			case e3d.Opcode.CALL_PTR then
				io.printf("CALL_PTR\n")
			case e3d.Opcode.RETURN then
				io.printf("RETURN\n")
			case e3d.Opcode.FTOI then
				io.printf("FTOI\n")
			case e3d.Opcode.ITOF then
				io.printf("ITOF\n")
			case e3d.Opcode.API then
				index = self:_bytecode_next16()
				local argc: uint16 = self:_bytecode_next16()
				io.printf("API 0x%04X %d\n", index, argc)
			else
				-- invalid opcode
				io.printf("!!! INVALID OPCODE !!!\n")
				self.cf = prev_cf
				return
		end
	end

	self.cf = prev_cf
end

function e3d.EVM:run(cycles: uinteger): boolean
	local index: uint16
	local running: boolean = true

	while running do
		local op: uint8 = self:_bytecode_next8()

		switch op do
			case e3d.Opcode.GET_G then
				index = self:_bytecode_next16()
				self:push(self:get_global(index))
			case e3d.Opcode.GET_GX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_get_globals(index, n)
			case e3d.Opcode.SET_G then
				index = self:_bytecode_next16()
				self:set_global(index, self:pop())
			case e3d.Opcode.SET_GX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_set_globals(index, n)
			case e3d.Opcode.NEW_L then
				self.lsp = self.lsp + self:_bytecode_next16()
			case e3d.Opcode.DEL_L then
				self.lsp = self.lsp - self:_bytecode_next16()
			case e3d.Opcode.GET_L then
				index = self:_bytecode_next16()
				self:push(self:get_local(index))
			case e3d.Opcode.GET_LX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_get_locals(index, n)
			case e3d.Opcode.SET_L then
				index = self:_bytecode_next16()
				self:set_local(index, self:pop())
			case e3d.Opcode.SET_LX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_set_locals(index, n)
			case e3d.Opcode.GET_A then
				index = self:_bytecode_next16()
				self:push(self:get_arg(index))
			case e3d.Opcode.GET_AX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_get_args(index, n)
			case e3d.Opcode.SET_A then
				index = self:_bytecode_next16()
				self:set_arg(index, self:pop())
			case e3d.Opcode.SET_AX then
				index = self:_bytecode_next16()
				local n: uint16 = self:_bytecode_next16()
				self:_set_args(index, n)
			case e3d.Opcode.GET_M then
				index = self:_bytecode_next16() -- offset in words
				local ptr: int32 = self:popi()
				local status: integer
				local v: uint32

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end
				
				self:pushu(self:_get_ramw((@uint32)(ptr + (@int32)(index) * 4)))
			case e3d.Opcode.GET_MX then
				index = self:_bytecode_next16() -- offset in words
				local size: uint16 = self:_bytecode_next16()
				local ptr: int32 = self:popi()

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end

				local start: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				for i = 0, < size do
					local addr: uint32 = start + i * 4

					if addr > e3d.RAM_MAX_ADDR then
						self.error = string.format("ERROR: invalid word read address 0x%08X\n", addr)
						return false
					end
					
					self:pushu(self:_get_ramw(addr))
				end
			case e3d.Opcode.SET_M then
				index = self:_bytecode_next16() -- offset in words
				local v: uint32 = self:popu()
				local ptr: int32 = self:popi()

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("ERROR: invalid word write address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("ERROR: misaligned word write address 0x%08X\n", ptr)
					return false
				end
				
				if not self:_set_ramw((@uint32)(ptr + (@int32)(index) * 4), v) then
					self.error = string.format("ERROR: cannot write word to ROM address 0x%08X\n", ptr)
					return false
				end
			case e3d.Opcode.SET_MX then
				-- stack:
				-- > osp
				-- struct (size words)
				-- ptr
				index = self:_bytecode_next16() -- offset in words
				local size: uint16 = self:_bytecode_next16()
				local ptr: int32 = self.opstack[(self.osp - 1) - size].i

				if ptr > e3d.RAM_MAX_ADDR then
					self.error = string.format("ERROR: invalid word read address 0x%08X\n", ptr)
					return false
				elseif (ptr & 0b11) ~= 0 then
					self.error = string.format("ERROR: misaligned word read address 0x%08X\n", ptr)
					return false
				end

				local start_addr: uint32 = (@uint32)(ptr + (@int32)(index) * 4)
				local struct_start: uinteger = self.osp - size
				for i = 0, < size do
					local mem_addr: uint32 = start_addr + i * 4
					local struct_word_index: uint32 = struct_start + i

					if mem_addr > e3d.RAM_MAX_ADDR then
						self.error = string.format("ERROR: invalid word read address 0x%08X\n", mem_addr)
						return false
					end
					
					self:_set_ramw(mem_addr, self.opstack[struct_word_index].u)
				end

				self.osp = (self.osp - 1) - size -- pop ptr and struct from stack
			case e3d.Opcode.ADDROF_G then
				index = self:_bytecode_next16()
				self:pushu(self:_address_of_global(index))
			case e3d.Opcode.ADDROF_L then
				index = self:_bytecode_next16()
				self:pushu(self:_address_of_local(index))
			case e3d.Opcode.ADDROF_A then
				index = self:_bytecode_next16()
				self:pushu(self:_address_of_arg(index))
			case e3d.Opcode.PUSH_ZERO then
				self:pushu(0)
			case e3d.Opcode.PUSH_ONE then
				self:pushu(1)
			case e3d.Opcode.PUSH_CHAR then
				self:pushu((@uint32)(self:_bytecode_next8()))
			case e3d.Opcode.PUSH_INT then
				self:pushi((@int32)(self:_bytecode_next32()))
			case e3d.Opcode.PUSH_FLOAT then
				self:pushf(self:_bytecode_nextf())
			case e3d.Opcode.PUSH_VEC2_ZERO then
				self:pushv2({0,0})
			case e3d.Opcode.PUSH_VEC3_ZERO then
				self:pushv3({0,0,0})
			case e3d.Opcode.BIN_NOT then
				self:pushu(~self:popu())
			case e3d.Opcode.BIN_OR then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a | b)
			case e3d.Opcode.BIN_XOR then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a ~ b)
			case e3d.Opcode.BIN_AND then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a & b)
			case e3d.Opcode.BIN_LSHIFT then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a << b)
			case e3d.Opcode.BIN_RSHIFT then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a >> b)
			case e3d.Opcode.BIN_ARSHIFT then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a >>> b)
			case e3d.Opcode.NEG then
				self:pushi(-self:popi())
			case e3d.Opcode.NEGF then
				self:pushf(-self:popf())
			case e3d.Opcode.NEGV then
				index = (@uint16)(self:_bytecode_next8())
				if index == 0 then
					local v: rl.vector2 = self:popv2()
					self:pushv2({-v.x,-v.y})
				else
					local v: rl.vector3 = self:popv3()
					self:pushv3({-v.x,-v.y,-v.z})
				end
			case e3d.Opcode.ADD then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a + b)
			case e3d.Opcode.ADDF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushf(a + b)
			case e3d.Opcode.ADDV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 + vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
							a.x + b.x,
							a.y + b.y})
					case 1 then -- vec3 + vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
							a.x + b.x,
							a.y + b.y,
							a.z + b.z})
				end
			case e3d.Opcode.ADDP then
				index = self:_bytecode_next16() -- size of type pointed to (in words)
				local v: int32 = self:popi()
				local p: int32 = self:popi()
				self:pushi(p + (v * (index * 4)))
			case e3d.Opcode.SUB then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a - b)
			case e3d.Opcode.SUBF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushf(a - b)
			case e3d.Opcode.SUBV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 - vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
							a.x - b.x,
							a.y - b.y})
					case 1 then -- vec3 - vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
							a.x - b.x,
							a.y - b.y,
							a.z - b.z})
				end
			case e3d.Opcode.SUBP then
				index = self:_bytecode_next16() -- size of type pointed to (in words)
				local v: int32 = self:popi()
				local p: int32 = self:popi()
				self:pushi(p - (v * (index * 4)))
			case e3d.Opcode.MUL then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a * b)
			case e3d.Opcode.MULF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushf(a * b)
			case e3d.Opcode.MULV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case e3d.MulVMode.INT_V2 then
						local a: rl.vector2 = self:popv2()
						local b: int32 = self:popi()
						self:pushv2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case e3d.MulVMode.INT_V3 then
						local a: rl.vector3 = self:popv3()
						local b: int32 = self:popi()
						self:pushv3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case e3d.MulVMode.FLOAT_V2 then
						local a: rl.vector2 = self:popv2()
						local b: float32 = self:popf()
						self:pushv2({
								a.x * b,
								a.y * b
							}
						)
					case e3d.MulVMode.FLOAT_V3 then
						local a: rl.vector3 = self:popv3()
						local b: float32 = self:popf()
						self:pushv3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case e3d.MulVMode.V2_INT then
						local b: int32 = self:popi()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x * (@float32)(b),
								a.y * (@float32)(b)
							}
						)
					case e3d.MulVMode.V2_FLOAT then
						local b: float32 = self:popf()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x * b,
								a.y * b
							}
						)
					case e3d.MulVMode.V2_V2 then
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x * b.x,
								a.y * b.y
							}
						)
					case e3d.MulVMode.V3_INT then
						local b: int32 = self:popi()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x * (@float32)(b),
								a.y * (@float32)(b),
								a.z * (@float32)(b)
							}
						)
					case e3d.MulVMode.V3_FLOAT then
						local b: float32 = self:popf()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x * b,
								a.y * b,
								a.z * b
							}
						)
					case e3d.MulVMode.V3_V3 then
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x * b.x,
								a.y * b.y,
								a.z * b.z
							}
						)
				end
			case e3d.Opcode.DIV then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a /// b)
			case e3d.Opcode.DIVU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a /// b)
			case e3d.Opcode.DIVF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushf(a / b)
			case e3d.Opcode.DIVV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case e3d.DivVMode.V2_INT then
						local b: int32 = self:popi()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x / (@float32)(b),
								a.y / (@float32)(b)
							}
						)
					case e3d.DivVMode.V2_FLOAT then
						local b: float32 = self:popf()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x / b,
								a.y / b
							}
						)
					case e3d.DivVMode.V2_V2 then
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushv2({
								a.x / b.x,
								a.y / b.y
							}
						)
					case e3d.DivVMode.V3_INT then
						local b: int32 = self:popi()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x / (@float32)(b),
								a.y / (@float32)(b),
								a.z / (@float32)(b)
							}
						)
					case e3d.DivVMode.V3_FLOAT then
						local b: float32 = self:popf()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x / b,
								a.y / b,
								a.z / b
							}
						)
					case e3d.DivVMode.V3_V3 then
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushv3({
								a.x / b.x,
								a.y / b.y,
								a.z / b.z
							}
						)
				end
			case e3d.Opcode.MOD then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushi(a %%% b)
			case e3d.Opcode.MODU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu(a %%% b)
			case e3d.Opcode.MODF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushf(math.fmod(a, b))
			case e3d.Opcode.LOGIC_NOT then
				local v: uint32 = self:popu()
				self:pushu(v == 0 and 1 or 0)
			case e3d.Opcode.LOGIC_OR then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a ~= 0 or b ~= 0) and 1 or 0)
			case e3d.Opcode.LOGIC_AND then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a ~= 0 and b ~= 0) and 1 or 0)
			case e3d.Opcode.EQ then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a == b) and 1 or 0)
			case e3d.Opcode.EQF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a == b) and 1 or 0)
			case e3d.Opcode.EQV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushu((a.x == b.x and a.y == b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushu((a.x == b.x and a.y == b.y and a.z == b.z) and 1 or 0)
				end
			case e3d.Opcode.NE then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a ~= b) and 1 or 0)
			case e3d.Opcode.NEF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a ~= b) and 1 or 0)
			case e3d.Opcode.NEV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 / vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						self:pushu((a.x ~= b.x and a.y ~= b.y) and 1 or 0)
					case 1 then -- vec3 / vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						self:pushu((a.x ~= b.x and a.y ~= b.y and a.z ~= b.z) and 1 or 0)
				end
			case e3d.Opcode.LTI then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushu((a < b) and 1 or 0)
			case e3d.Opcode.LTU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a < b) and 1 or 0)
			case e3d.Opcode.LTF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a < b) and 1 or 0)
			case e3d.Opcode.LTV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 < vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						if a.x == b.x then
							self:pushu((a.y < b.y) and 1 or 0)
						else
							self:pushu((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 < vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushu((a.z < b.z) and 1 or 0)
							else
								self:pushu((a.y < b.y) and 1 or 0)
							end
						else
							self:pushu((a.x < b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.GTI then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushu((a > b) and 1 or 0)
			case e3d.Opcode.GTU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a > b) and 1 or 0)
			case e3d.Opcode.GTF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a > b) and 1 or 0)
			case e3d.Opcode.GTV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 > vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						if a.x == b.x then
							self:pushu((a.y > b.y) and 1 or 0)
						else
							self:pushu((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 > vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushu((a.z > b.z) and 1 or 0)
							else
								self:pushu((a.y > b.y) and 1 or 0)
							end
						else
							self:pushu((a.x > b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.LEI then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushu((a <= b) and 1 or 0)
			case e3d.Opcode.LEU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a <= b) and 1 or 0)
			case e3d.Opcode.LEF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a <= b) and 1 or 0)
			case e3d.Opcode.LEV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 <= vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						if a.x == b.x then
							self:pushu((a.y <= b.y) and 1 or 0)
						else
							self:pushu((a.x < b.x) and 1 or 0)
						end
					case 1 then -- vec3 <= vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushu((a.z <= b.z) and 1 or 0)
							else
								self:pushu((a.y < b.y) and 1 or 0)
							end
						else
							self:pushu((a.x < b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.GEI then
				local b: int32 = self:popi()
				local a: int32 = self:popi()
				self:pushu((a >= b) and 1 or 0)
			case e3d.Opcode.GEU then
				local b: uint32 = self:popu()
				local a: uint32 = self:popu()
				self:pushu((a >= b) and 1 or 0)
			case e3d.Opcode.GEF then
				local b: float32 = self:popf()
				local a: float32 = self:popf()
				self:pushu((a >= b) and 1 or 0)
			case e3d.Opcode.GEV then
				index = (@uint16)(self:_bytecode_next8())
				switch index do
					case 0 then -- vec2 >= vec2
						local b: rl.vector2 = self:popv2()
						local a: rl.vector2 = self:popv2()
						if a.x == b.x then
							self:pushu((a.y >= b.y) and 1 or 0)
						else
							self:pushu((a.x > b.x) and 1 or 0)
						end
					case 1 then -- vec3 >= vec3
						local b: rl.vector3 = self:popv3()
						local a: rl.vector3 = self:popv3()
						if a.x == b.x then
							if a.y == b.y then
								self:pushu((a.z >= b.z) and 1 or 0)
							else
								self:pushu((a.y > b.y) and 1 or 0)
							end
						else
							self:pushu((a.x > b.x) and 1 or 0)
						end
				end
			case e3d.Opcode.JUMP then
				index = self:_bytecode_next16()
				self.cf.pc = index
			case e3d.Opcode.JUMP_Z then
				index = self:_bytecode_next16()
				local v: uint32 = self:popu()

				if v == 0 then
					self.cf.pc = index
				end
			case e3d.Opcode.CALL then
				index = self:_bytecode_next16()
				local argc: uint16 = self:_bytecode_next16()
				self:_push_args(argc)
				self:_push_callframe(argc)
				self.cf.pc = index
			case e3d.Opcode.CALL_PTR then
				local addr: uint32 = self:popu()
				if addr < e3d.BYTECODE_SIZE then
					self:_push_callframe(0)
					self.cf.pc = addr
				else
					self.error = string.format("ERROR: invalid call address 0x%08X\n", addr)
					return false
				end
			case e3d.Opcode.RETURN then
				-- if returning from first function call, halt the program
				if self.csp == 1 then
					return true
				else
					self:_pop_callframe()
				end
			case e3d.Opcode.FTOI then
				self:pushi((@int32)(self:popf()))
			case e3d.Opcode.ITOF then
				self:pushf((@float32)(self:popi()))
			case e3d.Opcode.API then
				index = self:_bytecode_next16()
				local argc: uint16 = self:_bytecode_next16()
				local func: e3d.APIFunction = self.api_funcs[index]
				if func ~= nilptr then
					self:_push_args(argc)
					self:_push_callframe(argc)
					if not func(self) then
						self:_pop_callframe()
						return false
					end
					self:_pop_callframe()
				else
					self.error = string.format("ERROR: attempt to call unregistered API function at index %d\n", index)
					return false
				end
			else
				-- invalid opcode
				self.error = string.format("ERROR: attempt to execute invalid opcode %d\n", op)
				return false
		end

		if self.cf.pc >= self.bytecode_len then
			running = false
		elseif cycles > 0 then
			cycles = cycles - 1
			running = cycles > 0
		end
	end
	
	return true
end

function e3d.EVM:call_hook(hook: integer, argc: uint16): boolean
	if self.hook_flags[hook] then
		self.current_hook = hook
		self.cf.pc = self.hook_addresses[hook]
		self:_push_callframe(argc)
		local result: boolean = self:run(0)
		self:_pop_callframe()
		return result
	end
	return true
end

function e3d.EVM:__gc(): void
	self.gpu:cleanup()
end

function e3d.new_vm(): *e3d.EVM
	local vm: *e3d.EVM = new(@e3d.EVM)

	vm:_register_api()
	vm:_register_builtins()
	
	vm.gpu:init(&vm.tmem)
	vm:reset(false)
	return vm
end
